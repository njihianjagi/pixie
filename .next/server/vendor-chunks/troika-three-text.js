/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/troika-three-text";
exports.ids = ["vendor-chunks/troika-three-text"];
exports.modules = {
  /***/ "(ssr)/./node_modules/troika-three-text/dist/troika-three-text.umd.js":
    /*!**********************************************************************!*\
  !*** ./node_modules/troika-three-text/dist/troika-three-text.umd.js ***!
  \**********************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      eval(
        '(function (global, factory) {\n   true ? factory(exports, __webpack_require__(/*! three */ "(ssr)/./node_modules/three/build/three.js"), __webpack_require__(/*! troika-worker-utils */ "(ssr)/./node_modules/troika-worker-utils/dist/troika-worker-utils.umd.js"), __webpack_require__(/*! troika-three-utils */ "(ssr)/./node_modules/troika-three-utils/dist/troika-three-utils.umd.js")) :\n  0;\n}(this, (function (exports, three, troikaWorkerUtils, troikaThreeUtils) { \'use strict\';\n\n  /**\n   * Initializes and returns a function to generate an SDF texture for a given glyph.\n   * @param {function} createGlyphSegmentsQuadtree - factory for a GlyphSegmentsQuadtree implementation.\n   * @param {number} config.sdfDistancePercent - see docs for SDF_DISTANCE_PERCENT in TextBuilder.js\n   *\n   * @return {function(Object): {renderingBounds: [minX, minY, maxX, maxY], textureData: Uint8Array}}\n   */\n  function createSDFGenerator(createGlyphSegmentsQuadtree, config) {\n    var sdfDistancePercent = config.sdfDistancePercent;\n\n    /**\n     * How many straight line segments to use when approximating a glyph\'s quadratic/cubic bezier curves.\n     */\n    var CURVE_POINTS = 16;\n\n    /**\n     * Find the point on a quadratic bezier curve at t where t is in the range [0, 1]\n     */\n    function pointOnQuadraticBezier(x0, y0, x1, y1, x2, y2, t) {\n      var t2 = 1 - t;\n      return {\n        x: t2 * t2 * x0 + 2 * t2 * t * x1 + t * t * x2,\n        y: t2 * t2 * y0 + 2 * t2 * t * y1 + t * t * y2\n      }\n    }\n\n    /**\n     * Find the point on a cubic bezier curve at t where t is in the range [0, 1]\n     */\n    function pointOnCubicBezier(x0, y0, x1, y1, x2, y2, x3, y3, t) {\n      var t2 = 1 - t;\n      return {\n        x: t2 * t2 * t2 * x0 + 3 * t2 * t2 * t * x1 + 3 * t2 * t * t * x2 + t * t * t * x3,\n        y: t2 * t2 * t2 * y0 + 3 * t2 * t2 * t * y1 + 3 * t2 * t * t * y2 + t * t * t * y3\n      }\n    }\n\n    /**\n     * Generate an SDF texture segment for a single glyph.\n     * @param {object} glyphObj\n     * @param {number} sdfSize - the length of one side of the SDF image.\n     *        Larger images encode more details. Must be a power of 2.\n     * @return {{textureData: Uint8Array, renderingBounds: *[]}}\n     */\n    function generateSDF(glyphObj, sdfSize) {\n      //console.time(\'glyphSDF\')\n\n      var textureData = new Uint8Array(sdfSize * sdfSize);\n\n      // Determine mapping between glyph grid coords and sdf grid coords\n      var glyphW = glyphObj.xMax - glyphObj.xMin;\n      var glyphH = glyphObj.yMax - glyphObj.yMin;\n\n      // Choose a maximum distance radius in font units, based on the glyph\'s max dimensions\n      var fontUnitsMaxDist = Math.max(glyphW, glyphH) * sdfDistancePercent;\n\n      // Use that, extending to the texture edges, to find conversion ratios between texture units and font units\n      var fontUnitsPerXTexel = (glyphW + fontUnitsMaxDist * 2) / sdfSize;\n      var fontUnitsPerYTexel = (glyphH + fontUnitsMaxDist * 2) / sdfSize;\n\n      var textureMinFontX = glyphObj.xMin - fontUnitsMaxDist - fontUnitsPerXTexel;\n      var textureMinFontY = glyphObj.yMin - fontUnitsMaxDist - fontUnitsPerYTexel;\n      var textureMaxFontX = glyphObj.xMax + fontUnitsMaxDist + fontUnitsPerXTexel;\n      var textureMaxFontY = glyphObj.yMax + fontUnitsMaxDist + fontUnitsPerYTexel;\n\n      function textureXToFontX(x) {\n        return textureMinFontX + (textureMaxFontX - textureMinFontX) * x / sdfSize\n      }\n\n      function textureYToFontY(y) {\n        return textureMinFontY + (textureMaxFontY - textureMinFontY) * y / sdfSize\n      }\n\n      if (glyphObj.pathCommandCount) { //whitespace chars will have no commands, so we can skip all this\n        // Decompose all paths into straight line segments and add them to a quadtree\n        var lineSegmentsIndex = createGlyphSegmentsQuadtree(glyphObj);\n        var firstX, firstY, prevX, prevY;\n        glyphObj.forEachPathCommand(function (type, x0, y0, x1, y1, x2, y2) {\n          switch (type) {\n            case \'M\':\n              prevX = firstX = x0;\n              prevY = firstY = y0;\n              break\n            case \'L\':\n              if (x0 !== prevX || y0 !== prevY) { //yup, some fonts have zero-length line commands\n                lineSegmentsIndex.addLineSegment(prevX, prevY, (prevX = x0), (prevY = y0));\n              }\n              break\n            case \'Q\': {\n              var prevPoint = {x: prevX, y: prevY};\n              for (var i = 1; i < CURVE_POINTS; i++) {\n                var nextPoint = pointOnQuadraticBezier(\n                  prevX, prevY,\n                  x0, y0,\n                  x1, y1,\n                  i / (CURVE_POINTS - 1)\n                );\n                lineSegmentsIndex.addLineSegment(prevPoint.x, prevPoint.y, nextPoint.x, nextPoint.y);\n                prevPoint = nextPoint;\n              }\n              prevX = x1;\n              prevY = y1;\n              break\n            }\n            case \'C\': {\n              var prevPoint$1 = {x: prevX, y: prevY};\n              for (var i$1 = 1; i$1 < CURVE_POINTS; i$1++) {\n                var nextPoint$1 = pointOnCubicBezier(\n                  prevX, prevY,\n                  x0, y0,\n                  x1, y1,\n                  x2, y2,\n                  i$1 / (CURVE_POINTS - 1)\n                );\n                lineSegmentsIndex.addLineSegment(prevPoint$1.x, prevPoint$1.y, nextPoint$1.x, nextPoint$1.y);\n                prevPoint$1 = nextPoint$1;\n              }\n              prevX = x2;\n              prevY = y2;\n              break\n            }\n            case \'Z\':\n              if (prevX !== firstX || prevY !== firstY) {\n                lineSegmentsIndex.addLineSegment(prevX, prevY, firstX, firstY);\n              }\n              break\n          }\n        });\n\n        // For each target SDF texel, find the distance from its center to its nearest line segment,\n        // map that distance to an alpha value, and write that alpha to the texel\n        for (var sdfX = 0; sdfX < sdfSize; sdfX++) {\n          for (var sdfY = 0; sdfY < sdfSize; sdfY++) {\n            var signedDist = lineSegmentsIndex.findNearestSignedDistance(\n              textureXToFontX(sdfX + 0.5),\n              textureYToFontY(sdfY + 0.5),\n              fontUnitsMaxDist\n            );\n            //if (!isFinite(signedDist)) throw \'infinite distance!\'\n            var alpha = isFinite(signedDist) ? Math.round(255 * (1 + signedDist / fontUnitsMaxDist) * 0.5) : signedDist;\n            alpha = Math.max(0, Math.min(255, alpha)); //clamp\n            textureData[sdfY * sdfSize + sdfX] = alpha;\n          }\n        }\n      }\n\n      //console.timeEnd(\'glyphSDF\')\n\n      return {\n        textureData: textureData,\n\n        renderingBounds: [\n          textureMinFontX,\n          textureMinFontY,\n          textureMaxFontX,\n          textureMaxFontY\n        ]\n      }\n    }\n\n\n    return generateSDF\n  }\n\n  /**\n   * Creates a self-contained environment for processing text rendering requests.\n   *\n   * It is important that this function has no closure dependencies, so that it can be easily injected\n   * into the source for a Worker without requiring a build step or complex dependency loading. All its\n   * dependencies must be passed in at initialization.\n   *\n   * @param {function} fontParser - a function that accepts an ArrayBuffer of the font data and returns\n   * a standardized structure giving access to the font and its glyphs:\n   *   {\n   *     unitsPerEm: number,\n   *     ascender: number,\n   *     descender: number,\n   *     forEachGlyph(string, fontSize, letterSpacing, callback) {\n   *       //invokes callback for each glyph to render, passing it an object:\n   *       callback({\n   *         index: number,\n   *         advanceWidth: number,\n   *         xMin: number,\n   *         yMin: number,\n   *         xMax: number,\n   *         yMax: number,\n   *         pathCommandCount: number,\n   *         forEachPathCommand(callback) {\n   *           //invokes callback for each path command, with args:\n   *           callback(\n   *             type: \'M|L|C|Q|Z\',\n   *             ...args //0 to 6 args depending on the type\n   *           )\n   *         }\n   *       })\n   *     }\n   *   }\n   * @param {function} sdfGenerator - a function that accepts a glyph object and generates an SDF texture\n   * from it.\n   * @param {Object} config\n   * @return {Object}\n   */\n  function createFontProcessor(fontParser, sdfGenerator, config) {\n\n    var defaultFontUrl = config.defaultFontUrl;\n\n\n    /**\n     * @private\n     * Holds data about font glyphs and how they relate to SDF atlases\n     *\n     * {\n     *   \'fontUrl@sdfSize\': {\n     *     fontObj: {}, //result of the fontParser\n     *     glyphs: {\n     *       [glyphIndex]: {\n     *         atlasIndex: 0,\n     *         glyphObj: {}, //glyph object from the fontParser\n     *         renderingBounds: [x0, y0, x1, y1]\n     *       },\n     *       ...\n     *     },\n     *     glyphCount: 123\n     *   }\n     * }\n     */\n    var fontAtlases = Object.create(null);\n\n    /**\n     * Holds parsed font objects by url\n     */\n    var fonts = Object.create(null);\n\n    var INF = Infinity;\n\n\n    /**\n     * Load a given font url\n     */\n    function doLoadFont(url, callback) {\n      function tryLoad() {\n        var onError = function (err) {\n          console.error(("Failure loading font " + url + (url === defaultFontUrl ? \'\' : \'; trying fallback\')), err);\n          if (url !== defaultFontUrl) {\n            url = defaultFontUrl;\n            tryLoad();\n          }\n        };\n        try {\n          var request = new XMLHttpRequest();\n          request.open(\'get\', url, true);\n          request.responseType = \'arraybuffer\';\n          request.onload = function () {\n            if (request.status >= 400) {\n              onError(new Error(request.statusText));\n            }\n            else if (request.status > 0) {\n              try {\n                var fontObj = fontParser(request.response);\n                callback(fontObj);\n              } catch (e) {\n                onError(e);\n              }\n            }\n          };\n          request.onerror = onError;\n          request.send();\n        } catch(err) {\n          onError(err);\n        }\n      }\n      tryLoad();\n    }\n\n\n    /**\n     * Load a given font url if needed, invoking a callback when it\'s loaded. If already\n     * loaded, the callback will be called synchronously.\n     */\n    function loadFont(fontUrl, callback) {\n      if (!fontUrl) { fontUrl = defaultFontUrl; }\n      var font = fonts[fontUrl];\n      if (font) {\n        // if currently loading font, add to callbacks, otherwise execute immediately\n        if (font.pending) {\n          font.pending.push(callback);\n        } else {\n          callback(font);\n        }\n      } else {\n        fonts[fontUrl] = {pending: [callback]};\n        doLoadFont(fontUrl, function (fontObj) {\n          var callbacks = fonts[fontUrl].pending;\n          fonts[fontUrl] = fontObj;\n          callbacks.forEach(function (cb) { return cb(fontObj); });\n        });\n      }\n    }\n\n\n    /**\n     * Get the atlas data for a given font url, loading it from the network and initializing\n     * its atlas data objects if necessary.\n     */\n    function getSdfAtlas(fontUrl, sdfGlyphSize, callback) {\n      if (!fontUrl) { fontUrl = defaultFontUrl; }\n      var atlasKey = fontUrl + "@" + sdfGlyphSize;\n      var atlas = fontAtlases[atlasKey];\n      if (atlas) {\n        callback(atlas);\n      } else {\n        loadFont(fontUrl, function (fontObj) {\n          atlas = fontAtlases[atlasKey] || (fontAtlases[atlasKey] = {\n            fontObj: fontObj,\n            glyphs: {},\n            glyphCount: 0\n          });\n          callback(atlas);\n        });\n      }\n    }\n\n\n    /**\n     * Main entry point.\n     * Process a text string with given font and formatting parameters, and return all info\n     * necessary to render all its glyphs.\n     */\n    function process(\n      ref,\n      callback,\n      metricsOnly\n    ) {\n      var text = ref.text; if ( text === void 0 ) text = \'\';\n      var font = ref.font; if ( font === void 0 ) font = defaultFontUrl;\n      var sdfGlyphSize = ref.sdfGlyphSize; if ( sdfGlyphSize === void 0 ) sdfGlyphSize = 64;\n      var fontSize = ref.fontSize; if ( fontSize === void 0 ) fontSize = 1;\n      var letterSpacing = ref.letterSpacing; if ( letterSpacing === void 0 ) letterSpacing = 0;\n      var lineHeight = ref.lineHeight; if ( lineHeight === void 0 ) lineHeight = \'normal\';\n      var maxWidth = ref.maxWidth; if ( maxWidth === void 0 ) maxWidth = INF;\n      var textAlign = ref.textAlign; if ( textAlign === void 0 ) textAlign = \'left\';\n      var textIndent = ref.textIndent; if ( textIndent === void 0 ) textIndent = 0;\n      var whiteSpace = ref.whiteSpace; if ( whiteSpace === void 0 ) whiteSpace = \'normal\';\n      var overflowWrap = ref.overflowWrap; if ( overflowWrap === void 0 ) overflowWrap = \'normal\';\n      var anchorX = ref.anchorX; if ( anchorX === void 0 ) anchorX = 0;\n      var anchorY = ref.anchorY; if ( anchorY === void 0 ) anchorY = 0;\n      var includeCaretPositions = ref.includeCaretPositions; if ( includeCaretPositions === void 0 ) includeCaretPositions = false;\n      var chunkedBoundsSize = ref.chunkedBoundsSize; if ( chunkedBoundsSize === void 0 ) chunkedBoundsSize = 8192;\n      var colorRanges = ref.colorRanges; if ( colorRanges === void 0 ) colorRanges = null;\n      if ( metricsOnly === void 0 ) metricsOnly=false;\n\n      var mainStart = now();\n      var timings = {total: 0, fontLoad: 0, layout: 0, sdf: {}, sdfTotal: 0};\n\n      // Ensure newlines are normalized\n      if (text.indexOf(\'\\r\') > -1) {\n        console.warn(\'FontProcessor.process: got text with \\\\r chars; normalizing to \\\\n\');\n        text = text.replace(/\\r\\n/g, \'\\n\').replace(/\\r/g, \'\\n\');\n      }\n\n      // Ensure we\'ve got numbers not strings\n      fontSize = +fontSize;\n      letterSpacing = +letterSpacing;\n      maxWidth = +maxWidth;\n      lineHeight = lineHeight || \'normal\';\n      textIndent = +textIndent;\n\n      getSdfAtlas(font, sdfGlyphSize, function (atlas) {\n        var fontObj = atlas.fontObj;\n        var hasMaxWidth = isFinite(maxWidth);\n        var newGlyphs = null;\n        var glyphBounds = null;\n        var glyphAtlasIndices = null;\n        var glyphColors = null;\n        var caretPositions = null;\n        var totalBounds = null;\n        var chunkedBounds = null;\n        var maxLineWidth = 0;\n        var renderableGlyphCount = 0;\n        var canWrap = whiteSpace !== \'nowrap\';\n        var ascender = fontObj.ascender;\n        var descender = fontObj.descender;\n        var unitsPerEm = fontObj.unitsPerEm;\n        timings.fontLoad = now() - mainStart;\n        var layoutStart = now();\n\n        // Find conversion between native font units and fontSize units; this will already be done\n        // for the gx/gy values below but everything else we\'ll need to convert\n        var fontSizeMult = fontSize / unitsPerEm;\n\n        // Determine appropriate value for \'normal\' line height based on the font\'s actual metrics\n        // TODO this does not guarantee individual glyphs won\'t exceed the line height, e.g. Roboto; should we use yMin/Max instead?\n        if (lineHeight === \'normal\') {\n          lineHeight = (ascender - descender) / unitsPerEm;\n        }\n\n        // Determine line height and leading adjustments\n        lineHeight = lineHeight * fontSize;\n        var halfLeading = (lineHeight - (ascender - descender) * fontSizeMult) / 2;\n        var topBaseline = -(fontSize + halfLeading);\n        var caretHeight = Math.min(lineHeight, (ascender - descender) * fontSizeMult);\n        var caretBottomOffset = (ascender + descender) / 2 * fontSizeMult - caretHeight / 2;\n\n        // Distribute glyphs into lines based on wrapping\n        var lineXOffset = textIndent;\n        var currentLine = new TextLine();\n        var lines = [currentLine];\n        fontObj.forEachGlyph(text, fontSize, letterSpacing, function (glyphObj, glyphX, charIndex) {\n          var char = text.charAt(charIndex);\n          var glyphWidth = glyphObj.advanceWidth * fontSizeMult;\n          var curLineCount = currentLine.count;\n          var nextLine;\n\n          // Calc isWhitespace and isEmpty once per glyphObj\n          if (!(\'isEmpty\' in glyphObj)) {\n            glyphObj.isWhitespace = !!char && /\\s/.test(char);\n            glyphObj.isEmpty = glyphObj.xMin === glyphObj.xMax || glyphObj.yMin === glyphObj.yMax;\n          }\n          if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {\n            renderableGlyphCount++;\n          }\n\n          // If a non-whitespace character overflows the max width, we need to soft-wrap\n          if (canWrap && hasMaxWidth && !glyphObj.isWhitespace && glyphX + glyphWidth + lineXOffset > maxWidth && curLineCount) {\n            // If it\'s the first char after a whitespace, start a new line\n            if (currentLine.glyphAt(curLineCount - 1).glyphObj.isWhitespace) {\n              nextLine = new TextLine();\n              lineXOffset = -glyphX;\n            } else {\n              // Back up looking for a whitespace character to wrap at\n              for (var i = curLineCount; i--;) {\n                // If we got the start of the line there\'s no soft break point; make hard break if overflowWrap=\'break-word\'\n                if (i === 0 && overflowWrap === \'break-word\') {\n                  nextLine = new TextLine();\n                  lineXOffset = -glyphX;\n                  break\n                }\n                // Found a soft break point; move all chars since it to a new line\n                else if (currentLine.glyphAt(i).glyphObj.isWhitespace) {\n                  nextLine = currentLine.splitAt(i + 1);\n                  var adjustX = nextLine.glyphAt(0).x;\n                  lineXOffset -= adjustX;\n                  for (var j = nextLine.count; j--;) {\n                    nextLine.glyphAt(j).x -= adjustX;\n                  }\n                  break\n                }\n              }\n            }\n            if (nextLine) {\n              currentLine.isSoftWrapped = true;\n              currentLine = nextLine;\n              lines.push(currentLine);\n              maxLineWidth = maxWidth; //after soft wrapping use maxWidth as calculated width\n            }\n          }\n\n          var fly = currentLine.glyphAt(currentLine.count);\n          fly.glyphObj = glyphObj;\n          fly.x = glyphX + lineXOffset;\n          fly.width = glyphWidth;\n          fly.charIndex = charIndex;\n\n          // Handle hard line breaks\n          if (char === \'\\n\') {\n            currentLine = new TextLine();\n            lines.push(currentLine);\n            lineXOffset = -(glyphX + glyphWidth + (letterSpacing * fontSize)) + textIndent;\n          }\n        });\n\n        // Calculate width of each line (excluding trailing whitespace) and maximum block width\n        lines.forEach(function (line) {\n          for (var i = line.count; i--;) {\n            var ref = line.glyphAt(i);\n            var glyphObj = ref.glyphObj;\n            var x = ref.x;\n            var width = ref.width;\n            if (!glyphObj.isWhitespace) {\n              line.width = x + width;\n              if (line.width > maxLineWidth) {\n                maxLineWidth = line.width;\n              }\n              return\n            }\n          }\n        });\n\n        if (!metricsOnly) {\n          // Find overall position adjustments for anchoring\n          var anchorXOffset = 0;\n          var anchorYOffset = 0;\n          if (anchorX) {\n            if (typeof anchorX === \'number\') {\n              anchorXOffset = -anchorX;\n            }\n            else if (typeof anchorX === \'string\') {\n              anchorXOffset = -maxLineWidth * (\n                anchorX === \'left\' ? 0 :\n                anchorX === \'center\' ? 0.5 :\n                anchorX === \'right\' ? 1 :\n                parsePercent(anchorX)\n              );\n            }\n          }\n          if (anchorY) {\n            if (typeof anchorY === \'number\') {\n              anchorYOffset = -anchorY;\n            }\n            else if (typeof anchorY === \'string\') {\n              var height = lines.length * lineHeight;\n              anchorYOffset = anchorY === \'top\' ? 0 :\n                anchorY === \'top-baseline\' ? -topBaseline :\n                anchorY === \'middle\' ? height / 2 :\n                anchorY === \'bottom\' ? height :\n                anchorY === \'bottom-baseline\' ? height - halfLeading + descender * fontSizeMult :\n                parsePercent(anchorY) * height;\n            }\n          }\n\n          // Process each line, applying alignment offsets, adding each glyph to the atlas, and\n          // collecting all renderable glyphs into a single collection.\n          glyphBounds = new Float32Array(renderableGlyphCount * 4);\n          glyphAtlasIndices = new Float32Array(renderableGlyphCount);\n          totalBounds = [INF, INF, -INF, -INF];\n          chunkedBounds = [];\n          var lineYOffset = topBaseline;\n          if (includeCaretPositions) {\n            caretPositions = new Float32Array(text.length * 3);\n          }\n          if (colorRanges) {\n            glyphColors = new Uint8Array(renderableGlyphCount * 3);\n          }\n          var renderableGlyphIndex = 0;\n          var prevCharIndex = -1;\n          var colorCharIndex = -1;\n          var chunk;\n          var currentColor;\n          lines.forEach(function (line) {\n            var lineGlyphCount = line.count;\n            var lineWidth = line.width;\n\n            // Ignore empty lines\n            if (lineGlyphCount > 0) {\n              // Find x offset for horizontal alignment\n              var lineXOffset = 0;\n              var justifyAdjust = 0;\n              if (textAlign === \'center\') {\n                lineXOffset = (maxLineWidth - lineWidth) / 2;\n              } else if (textAlign === \'right\') {\n                lineXOffset = maxLineWidth - lineWidth;\n              } else if (textAlign === \'justify\' && line.isSoftWrapped) {\n                // just count the non-trailing whitespace characters, and we\'ll adjust the offsets per\n                // character in the next loop\n                var whitespaceCount = 0;\n                for (var i = lineGlyphCount; i--;) {\n                  if (!line.glyphAt(i).glyphObj.isWhitespace) {\n                    while (i--) {\n                      if (!line.glyphAt(i).glyphObj) {\n                        debugger\n                      }\n                      if (line.glyphAt(i).glyphObj.isWhitespace) {\n                        whitespaceCount++;\n                      }\n                    }\n                    break\n                  }\n                }\n                justifyAdjust = (maxLineWidth - lineWidth) / whitespaceCount;\n              }\n\n              for (var i$1 = 0; i$1 < lineGlyphCount; i$1++) {\n                var glyphInfo = line.glyphAt(i$1);\n                var glyphObj = glyphInfo.glyphObj;\n\n                // Apply position adjustments\n                if (lineXOffset) { glyphInfo.x += lineXOffset; }\n\n                // Expand whitespaces for justify alignment\n                if (justifyAdjust !== 0 && glyphObj.isWhitespace) {\n                  lineXOffset += justifyAdjust;\n                  glyphInfo.width += justifyAdjust;\n                }\n\n                // Add caret positions\n                if (includeCaretPositions) {\n                  var charIndex = glyphInfo.charIndex;\n                  caretPositions[charIndex * 3] = glyphInfo.x + anchorXOffset; //left edge x\n                  caretPositions[charIndex * 3 + 1] = glyphInfo.x + glyphInfo.width + anchorXOffset; //right edge x\n                  caretPositions[charIndex * 3 + 2] = lineYOffset + caretBottomOffset + anchorYOffset; //common bottom y\n\n                  // If we skipped any chars from the previous glyph (due to ligature subs), copy the\n                  // previous glyph\'s info to those missing char indices. In the future we may try to\n                  // use the font\'s LigatureCaretList table to get interior caret positions.\n                  while (charIndex - prevCharIndex > 1) {\n                    caretPositions[(prevCharIndex + 1) * 3] = caretPositions[prevCharIndex * 3 + 1];\n                    caretPositions[(prevCharIndex + 1) * 3 + 1] = caretPositions[prevCharIndex * 3 + 1];\n                    caretPositions[(prevCharIndex + 1) * 3 + 2] = caretPositions[prevCharIndex * 3 + 2];\n                    prevCharIndex++;\n                  }\n                  prevCharIndex = charIndex;\n                }\n\n                // Track current color range\n                if (colorRanges) {\n                  var charIndex$1 = glyphInfo.charIndex;\n                  while(charIndex$1 > colorCharIndex) {\n                    colorCharIndex++;\n                    if (colorRanges.hasOwnProperty(colorCharIndex)) {\n                      currentColor = colorRanges[colorCharIndex];\n                    }\n                  }\n                }\n\n                // Get atlas data for renderable glyphs\n                if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {\n                  var idx = renderableGlyphIndex++;\n\n                  // If we haven\'t seen this glyph yet, generate its SDF\n                  var glyphAtlasInfo = atlas.glyphs[glyphObj.index];\n                  if (!glyphAtlasInfo) {\n                    var sdfStart = now();\n                    var glyphSDFData = sdfGenerator(glyphObj, sdfGlyphSize);\n                    timings.sdf[text.charAt(glyphInfo.charIndex)] = now() - sdfStart;\n\n                    // Assign this glyph the next available atlas index\n                    glyphSDFData.atlasIndex = atlas.glyphCount++;\n\n                    // Queue it up in the response\'s newGlyphs list\n                    if (!newGlyphs) { newGlyphs = []; }\n                    newGlyphs.push(glyphSDFData);\n\n                    // Store its metadata (not the texture) in our atlas info\n                    glyphAtlasInfo = atlas.glyphs[glyphObj.index] = {\n                      atlasIndex: glyphSDFData.atlasIndex,\n                      glyphObj: glyphObj,\n                      renderingBounds: glyphSDFData.renderingBounds\n                    };\n                  }\n\n                  // Determine final glyph bounds and add them to the glyphBounds array\n                  var bounds = glyphAtlasInfo.renderingBounds;\n                  var start = idx * 4;\n                  var x0 = glyphBounds[start] = glyphInfo.x + bounds[0] * fontSizeMult + anchorXOffset;\n                  var y0 = glyphBounds[start + 1] = lineYOffset + bounds[1] * fontSizeMult + anchorYOffset;\n                  var x1 = glyphBounds[start + 2] = glyphInfo.x + bounds[2] * fontSizeMult + anchorXOffset;\n                  var y1 = glyphBounds[start + 3] = lineYOffset + bounds[3] * fontSizeMult + anchorYOffset;\n\n                  // Track total bounds\n                  if (x0 < totalBounds[0]) { totalBounds[0] = x0; }\n                  if (y0 < totalBounds[1]) { totalBounds[1] = y0; }\n                  if (x1 > totalBounds[2]) { totalBounds[2] = x1; }\n                  if (y1 > totalBounds[3]) { totalBounds[3] = y1; }\n\n                  // Track bounding rects for each chunk of N glyphs\n                  if (idx % chunkedBoundsSize === 0) {\n                    chunk = {start: idx, end: idx, rect: [INF, INF, -INF, -INF]};\n                    chunkedBounds.push(chunk);\n                  }\n                  chunk.end++;\n                  if (x0 < chunk.rect[0]) { chunk.rect[0] = x0; }\n                  if (y0 < chunk.rect[1]) { chunk.rect[1] = y0; }\n                  if (x1 > chunk.rect[2]) { chunk.rect[2] = x1; }\n                  if (y1 > chunk.rect[3]) { chunk.rect[3] = y1; }\n\n                  // Add to atlas indices array\n                  glyphAtlasIndices[idx] = glyphAtlasInfo.atlasIndex;\n\n                  // Add colors\n                  if (colorRanges) {\n                    var start$1 = idx * 3;\n                    glyphColors[start$1] = currentColor >> 16 & 255;\n                    glyphColors[start$1 + 1] = currentColor >> 8 & 255;\n                    glyphColors[start$1 + 2] = currentColor & 255;\n                  }\n                }\n              }\n            }\n\n            // Increment y offset for next line\n            lineYOffset -= lineHeight;\n          });\n        }\n\n        // Timing stats\n        for (var ch in timings.sdf) {\n          timings.sdfTotal += timings.sdf[ch];\n        }\n        timings.layout = now() - layoutStart - timings.sdfTotal;\n        timings.total = now() - mainStart;\n\n        callback({\n          glyphBounds: glyphBounds, //rendering quad bounds for each glyph [x1, y1, x2, y2]\n          glyphAtlasIndices: glyphAtlasIndices, //atlas indices for each glyph\n          caretPositions: caretPositions, //x,y of bottom of cursor position before each char, plus one after last char\n          caretHeight: caretHeight, //height of cursor from bottom to top\n          glyphColors: glyphColors, //color for each glyph, if color ranges supplied\n          chunkedBounds: chunkedBounds, //total rects per (n=chunkedBoundsSize) consecutive glyphs\n          ascender: ascender * fontSizeMult, //font ascender\n          descender: descender * fontSizeMult, //font descender\n          lineHeight: lineHeight, //computed line height\n          topBaseline: topBaseline, //y coordinate of the top line\'s baseline\n          totalBounds: totalBounds, //total rect including all glyphBounds; will be slightly larger than glyph edges due to SDF padding\n          totalBlockSize: [maxLineWidth, lines.length * lineHeight], //width and height of the text block; accurate for layout measurement\n          newGlyphSDFs: newGlyphs, //if this request included any new SDFs for the atlas, they\'ll be included here\n          timings: timings\n        });\n      });\n    }\n\n\n    /**\n     * For a given text string and font parameters, determine the resulting block dimensions\n     * after wrapping for the given maxWidth.\n     * @param args\n     * @param callback\n     */\n    function measure(args, callback) {\n      process(args, function (result) {\n        callback({\n          width: result.totalBlockSize[0],\n          height: result.totalBlockSize[1]\n        });\n      }, {metricsOnly: true});\n    }\n\n    function parsePercent(str) {\n      var match = str.match(/^([\\d.]+)%$/);\n      var pct = match ? parseFloat(match[1]) : NaN;\n      return isNaN(pct) ? 0 : pct / 100\n    }\n\n    function now() {\n      return (self.performance || Date).now()\n    }\n\n    // Array-backed structure for a single line\'s glyphs data\n    function TextLine() {\n      this.data = [];\n    }\n    TextLine.prototype = {\n      width: 0,\n      isSoftWrapped: false,\n      get count() {\n        return Math.ceil(this.data.length / 4)\n      },\n      glyphAt: function glyphAt(i) {\n        var fly = TextLine.flyweight;\n        fly.data = this.data;\n        fly.index = i;\n        return fly\n      },\n      splitAt: function splitAt(i) {\n        var newLine = new TextLine();\n        newLine.data = this.data.splice(i * 4);\n        return newLine\n      }\n    };\n    TextLine.flyweight = [\'glyphObj\', \'x\', \'width\', \'charIndex\'].reduce(function (obj, prop, i, all) {\n      Object.defineProperty(obj, prop, {\n        get: function get() {\n          return this.data[this.index * 4 + i]\n        },\n        set: function set(val) {\n          this.data[this.index * 4 + i] = val;\n        }\n      });\n      return obj\n    }, {data: null, index: 0});\n\n\n    return {\n      process: process,\n      measure: measure,\n      loadFont: loadFont\n    }\n  }\n\n  /**\n   * Basic quadtree impl for performing fast spatial searches of a glyph\'s line segments.\n   */\n  function createGlyphSegmentsQuadtree(glyphObj) {\n    // Pick a good initial power-of-two bounding box that will hold all possible segments\n    var xMin = glyphObj.xMin;\n    var yMin = glyphObj.yMin;\n    var xMax = glyphObj.xMax;\n    var yMax = glyphObj.yMax;\n    var dx = xMax - xMin;\n    var dy = yMax - yMin;\n    var cx = Math.round(xMin + dx / 2);\n    var cy = Math.round(yMin + dy / 2);\n    var r = Math.pow(2, Math.floor(Math.log(Math.max(dx, dy)) * Math.LOG2E));\n    var INF = Infinity;\n\n    var root = {\n      0: null,\n      1: null,\n      2: null,\n      3: null,\n      data: null,\n      cx: cx,\n      cy: cy,\n      r: r,\n      minX: INF,\n      minY: INF,\n      maxX: -INF,\n      maxY: -INF\n    };\n\n    /**\n     * Add a line segment to the quadtree.\n     * @param x0\n     * @param y0\n     * @param x1\n     * @param y1\n     */\n    function addLineSegment(x0, y0, x1, y1) {\n      var cx = (x0 + x1) / 2;\n      var cy = (y0 + y1) / 2;\n      var segment = {\n        x0: x0, y0: y0, x1: x1, y1: y1, cx: cx, cy: cy,\n        minX: Math.min(x0, x1),\n        minY: Math.min(y0, y1),\n        maxX: Math.max(x0, x1),\n        maxY: Math.max(y0, y1),\n        next: null\n      };\n      insertSegment(segment, root);\n    }\n\n    function insertSegment(segment, node) {\n      // update node min/max stats\n      var minX = segment.minX;\n      var minY = segment.minY;\n      var maxX = segment.maxX;\n      var maxY = segment.maxY;\n      var cx = segment.cx;\n      var cy = segment.cy;\n      if (minX < node.minX) { node.minX = minX; }\n      if (minY < node.minY) { node.minY = minY; }\n      if (maxX > node.maxX) { node.maxX = maxX; }\n      if (maxY > node.maxY) { node.maxY = maxY; }\n\n      // leaf\n      var leafSegment = node.data;\n      if (leafSegment) {\n        // coincident; push as linked list\n        if (leafSegment.cx === cx && leafSegment.cy === cy) {\n          while (leafSegment.next) { leafSegment = leafSegment.next; }\n          leafSegment.next = segment;\n        }\n        // non-coincident; split leaf to branch\n        else {\n          node.data = null;\n          insertSegment(leafSegment, node);\n          insertSegment(segment, node);\n        }\n      }\n      // branch\n      else {\n        // find target sub-index for the segment\'s centerpoint\n        var subIndex = (cy < node.cy ? 0 : 2) + (cx < node.cx ? 0 : 1);\n\n        // subnode already at index: recurse\n        if (node[subIndex]) {\n          insertSegment(segment, node[subIndex]);\n        }\n        // create new leaf\n        else {\n          node[subIndex] = {\n            0: null,\n            1: null,\n            2: null,\n            3: null,\n            data: segment,\n            cx: node.cx + node.r / 2 * (subIndex % 2 ? 1 : -1),\n            cy: node.cy + node.r / 2 * (subIndex < 2 ? -1 : 1),\n            r: node.r / 2,\n            minX: minX,\n            minY: minY,\n            maxX: maxX,\n            maxY: maxY\n          };\n        }\n      }\n    }\n\n    function walkTree(callback) {\n      walkBranch(root, callback);\n    }\n\n    function walkBranch(root, callback) {\n      if (callback(root) !== false && !root.data) {\n        for (var i = 0; i < 4; i++) {\n          if (root[i] !== null) {\n            walkBranch(root[i], callback);\n          }\n        }\n      }\n    }\n\n    /**\n     * For a given x/y, search the quadtree for the closest line segment and return\n     * its signed distance.\n     * @param x\n     * @param y\n     * @param maxSearchRadius\n     * @returns {number}\n     */\n    function findNearestSignedDistance(x, y, maxSearchRadius) {\n      var closestDist = maxSearchRadius;\n      var closestDistSq = closestDist * closestDist;\n\n      walkTree(function visit(node) {\n        // Ignore nodes that can\'t possibly have segments closer than what we\'ve already found. We base\n        // this on a simple rect bounds check; radial would be more accurate but much slower.\n        if (\n          x - closestDist > node.maxX || x + closestDist < node.minX ||\n          y - closestDist > node.maxY || y + closestDist < node.minY\n        ) {\n          return false\n        }\n\n        // Leaf - check each segment\'s actual distance\n        for (var segment = node.data; segment; segment = segment.next) {\n          var distSq = absSquareDistanceToLineSegment(x, y, segment.x0, segment.y0, segment.x1, segment.y1);\n          if (distSq < closestDistSq) {\n            closestDistSq = distSq;\n            closestDist = Math.sqrt(distSq);\n          }\n        }\n      });\n\n      // Flip to negative distance if outside the poly\n      if (!isPointInPoly(x, y)) {\n        closestDist = -closestDist;\n      }\n      return closestDist\n    }\n\n    // Determine whether the given point lies inside or outside the glyph. Uses a simple\n    // ray casting algorithm using a ray pointing east from the point, optimized by using\n    // the quadtree search to test as few lines as possible.\n    function isPointInPoly(x, y) {\n      var inside = false;\n      walkTree(function (node) {\n        // Ignore nodes whose bounds can\'t possibly cross our east-pointing ray\n        if (node.maxX < x || node.minY > y || node.maxY < y) {\n          return false\n        }\n\n        // Leaf - test each segment for whether it crosses our east-pointing ray\n        for (var segment = node.data; segment; segment = segment.next) {\n          var x0 = segment.x0;\n          var y0 = segment.y0;\n          var x1 = segment.x1;\n          var y1 = segment.y1;\n          var intersects = ((y0 > y) !== (y1 > y)) && (x < (x1 - x0) * (y - y0) / (y1 - y0) + x0);\n          if (intersects) {\n            inside = !inside;\n          }\n        }\n      });\n      return inside\n    }\n\n    // Find the absolute distance from a point to a line segment at closest approach\n    function absSquareDistanceToLineSegment(x, y, lineX0, lineY0, lineX1, lineY1) {\n      var ldx = lineX1 - lineX0;\n      var ldy = lineY1 - lineY0;\n      var lengthSq = ldx * ldx + ldy * ldy;\n      var t = lengthSq ? Math.max(0, Math.min(1, ((x - lineX0) * ldx + (y - lineY0) * ldy) / lengthSq)) : 0;\n      var dx = x - (lineX0 + t * ldx);\n      var dy = y - (lineY0 + t * ldy);\n      return dx * dx + dy * dy\n    }\n\n    return {\n      addLineSegment: addLineSegment,\n      findNearestSignedDistance: findNearestSignedDistance\n    }\n  }\n\n  // Custom bundle of Typr.js (https://github.com/photopea/Typr.js) for use in troika-3d-text. \n  // Original MIT license applies: https://github.com/photopea/Typr.js/blob/gh-pages/LICENSE\n\n  function typrFactory() {\n\n  var window = self;\n\n  // Begin Typr.js\n\n\n  var Typr = {};\n\n  Typr.parse = function(buff)\n  {\n  \tvar bin = Typr._bin;\n  \tvar data = new Uint8Array(buff);\n  \t\n  \tvar tag = bin.readASCII(data, 0, 4);  \n  \tif(tag=="ttcf") {\n  \t\tvar offset = 4;\n  \t\tvar majV = bin.readUshort(data, offset);  offset+=2;\n  \t\tvar minV = bin.readUshort(data, offset);  offset+=2;\n  \t\tvar numF = bin.readUint  (data, offset);  offset+=4;\n  \t\tvar fnts = [];\n  \t\tfor(var i=0; i<numF; i++) {\n  \t\t\tvar foff = bin.readUint  (data, offset);  offset+=4;\n  \t\t\tfnts.push(Typr._readFont(data, foff));\n  \t\t}\n  \t\treturn fnts;\n  \t}\n  \telse { return [Typr._readFont(data, 0)]; }\n  };\n\n  Typr._readFont = function(data, offset) {\n  \tvar bin = Typr._bin;\n  \tvar ooff = offset;\n  \t\n  \tvar sfnt_version = bin.readFixed(data, offset);\n  \toffset += 4;\n  \tvar numTables = bin.readUshort(data, offset);\n  \toffset += 2;\n  \tvar searchRange = bin.readUshort(data, offset);\n  \toffset += 2;\n  \tvar entrySelector = bin.readUshort(data, offset);\n  \toffset += 2;\n  \tvar rangeShift = bin.readUshort(data, offset);\n  \toffset += 2;\n  \t\n  \tvar tags = [\n  \t\t"cmap",\n  \t\t"head",\n  \t\t"hhea",\n  \t\t"maxp",\n  \t\t"hmtx",\n  \t\t"name",\n  \t\t"OS/2",\n  \t\t"post",\n  \t\t\n  \t\t//"cvt",\n  \t\t//"fpgm",\n  \t\t"loca",\n  \t\t"glyf",\n  \t\t"kern",\n  \t\t\n  \t\t//"prep"\n  \t\t//"gasp"\n  \t\t\n  \t\t"CFF ",\n  \t\t\n  \t\t\n  \t\t"GPOS",\n  \t\t"GSUB",\n  \t\t\n  \t\t"SVG " ];\n  \t\n  \tvar obj = {_data:data, _offset:ooff};\n  \t//console.log(sfnt_version, numTables, searchRange, entrySelector, rangeShift);\n  \t\n  \tvar tabs = {};\n  \t\n  \tfor(var i=0; i<numTables; i++)\n  \t{\n  \t\tvar tag = bin.readASCII(data, offset, 4);   offset += 4;\n  \t\tvar checkSum = bin.readUint(data, offset);  offset += 4;\n  \t\tvar toffset = bin.readUint(data, offset);   offset += 4;\n  \t\tvar length = bin.readUint(data, offset);    offset += 4;\n  \t\ttabs[tag] = {offset:toffset, length:length};\n  \t\t\n  \t\t//if(tags.indexOf(tag)==-1) console.log("unknown tag", tag, length);\n  \t}\n  \t\n  \tfor(var i=0; i< tags.length; i++)\n  \t{\n  \t\tvar t = tags[i];\n  \t\t//console.log(t);\n  \t\t//if(tabs[t]) console.log(t, tabs[t].offset, tabs[t].length);\n  \t\tif(tabs[t]) { obj[t.trim()] = Typr[t.trim()].parse(data, tabs[t].offset, tabs[t].length, obj); }\n  \t}\n  \t\n  \treturn obj;\n  };\n\n  Typr._tabOffset = function(data, tab, foff)\n  {\n  \tvar bin = Typr._bin;\n  \tvar numTables = bin.readUshort(data, foff+4);\n  \tvar offset = foff+12;\n  \tfor(var i=0; i<numTables; i++)\n  \t{\n  \t\tvar tag = bin.readASCII(data, offset, 4);   offset += 4;\n  \t\tvar checkSum = bin.readUint(data, offset);  offset += 4;\n  \t\tvar toffset = bin.readUint(data, offset);   offset += 4;\n  \t\tvar length = bin.readUint(data, offset);    offset += 4;\n  \t\tif(tag==tab) { return toffset; }\n  \t}\n  \treturn 0;\n  };\n\n\n\n\n\n  Typr._bin = {\n  \treadFixed : function(data, o)\n  \t{\n  \t\treturn ((data[o]<<8) | data[o+1]) +  (((data[o+2]<<8)|data[o+3])/(256*256+4));\n  \t},\n  \treadF2dot14 : function(data, o)\n  \t{\n  \t\tvar num = Typr._bin.readShort(data, o);\n  \t\treturn num / 16384;\n  \t},\n  \treadInt : function(buff, p)\n  \t{\n  \t\t//if(p>=buff.length) throw "error";\n  \t\tvar a = Typr._bin.t.uint8;\n  \t\ta[0] = buff[p+3];\n  \t\ta[1] = buff[p+2];\n  \t\ta[2] = buff[p+1];\n  \t\ta[3] = buff[p];\n  \t\treturn Typr._bin.t.int32[0];\n  \t},\n  \t\n  \treadInt8 : function(buff, p)\n  \t{\n  \t\t//if(p>=buff.length) throw "error";\n  \t\tvar a = Typr._bin.t.uint8;\n  \t\ta[0] = buff[p];\n  \t\treturn Typr._bin.t.int8[0];\n  \t},\n  \treadShort : function(buff, p)\n  \t{\n  \t\t//if(p>=buff.length) throw "error";\n  \t\tvar a = Typr._bin.t.uint8;\n  \t\ta[1] = buff[p]; a[0] = buff[p+1];\n  \t\treturn Typr._bin.t.int16[0];\n  \t},\n  \treadUshort : function(buff, p)\n  \t{\n  \t\t//if(p>=buff.length) throw "error";\n  \t\treturn (buff[p]<<8) | buff[p+1];\n  \t},\n  \treadUshorts : function(buff, p, len)\n  \t{\n  \t\tvar arr = [];\n  \t\tfor(var i=0; i<len; i++) { arr.push(Typr._bin.readUshort(buff, p+i*2)); }\n  \t\treturn arr;\n  \t},\n  \treadUint : function(buff, p)\n  \t{\n  \t\t//if(p>=buff.length) throw "error";\n  \t\tvar a = Typr._bin.t.uint8;\n  \t\ta[3] = buff[p];  a[2] = buff[p+1];  a[1] = buff[p+2];  a[0] = buff[p+3];\n  \t\treturn Typr._bin.t.uint32[0];\n  \t},\n  \treadUint64 : function(buff, p)\n  \t{\n  \t\t//if(p>=buff.length) throw "error";\n  \t\treturn (Typr._bin.readUint(buff, p)*(0xffffffff+1)) + Typr._bin.readUint(buff, p+4);\n  \t},\n  \treadASCII : function(buff, p, l)\t// l : length in Characters (not Bytes)\n  \t{\n  \t\t//if(p>=buff.length) throw "error";\n  \t\tvar s = "";\n  \t\tfor(var i = 0; i < l; i++) { s += String.fromCharCode(buff[p+i]); }\n  \t\treturn s;\n  \t},\n  \treadUnicode : function(buff, p, l)\n  \t{\n  \t\t//if(p>=buff.length) throw "error";\n  \t\tvar s = "";\n  \t\tfor(var i = 0; i < l; i++)\t\n  \t\t{\n  \t\t\tvar c = (buff[p++]<<8) | buff[p++];\n  \t\t\ts += String.fromCharCode(c);\n  \t\t}\n  \t\treturn s;\n  \t},\n  \t_tdec : window["TextDecoder"] ? new window["TextDecoder"]() : null,\n  \treadUTF8 : function(buff, p, l) {\n  \t\tvar tdec = Typr._bin._tdec;\n  \t\tif(tdec && p==0 && l==buff.length) { return tdec["decode"](buff); }\n  \t\treturn Typr._bin.readASCII(buff,p,l);\n  \t},\n  \treadBytes : function(buff, p, l)\n  \t{\n  \t\t//if(p>=buff.length) throw "error";\n  \t\tvar arr = [];\n  \t\tfor(var i=0; i<l; i++) { arr.push(buff[p+i]); }\n  \t\treturn arr;\n  \t},\n  \treadASCIIArray : function(buff, p, l)\t// l : length in Characters (not Bytes)\n  \t{\n  \t\t//if(p>=buff.length) throw "error";\n  \t\tvar s = [];\n  \t\tfor(var i = 0; i < l; i++)\t\n  \t\t\t{ s.push(String.fromCharCode(buff[p+i])); }\n  \t\treturn s;\n  \t}\n  };\n\n  Typr._bin.t = {\n  \tbuff: new ArrayBuffer(8),\n  };\n  Typr._bin.t.int8   = new Int8Array  (Typr._bin.t.buff);\n  Typr._bin.t.uint8  = new Uint8Array (Typr._bin.t.buff);\n  Typr._bin.t.int16  = new Int16Array (Typr._bin.t.buff);\n  Typr._bin.t.uint16 = new Uint16Array(Typr._bin.t.buff);\n  Typr._bin.t.int32  = new Int32Array (Typr._bin.t.buff);\n  Typr._bin.t.uint32 = new Uint32Array(Typr._bin.t.buff);\n\n\n\n\n\n  // OpenType Layout Common Table Formats\n\n  Typr._lctf = {};\n\n  Typr._lctf.parse = function(data, offset, length, font, subt)\n  {\n  \tvar bin = Typr._bin;\n  \tvar obj = {};\n  \tvar offset0 = offset;\n  \tvar tableVersion = bin.readFixed(data, offset);  offset += 4;\n  \t\n  \tvar offScriptList  = bin.readUshort(data, offset);  offset += 2;\n  \tvar offFeatureList = bin.readUshort(data, offset);  offset += 2;\n  \tvar offLookupList  = bin.readUshort(data, offset);  offset += 2;\n  \t\n  \t\n  \tobj.scriptList  = Typr._lctf.readScriptList (data, offset0 + offScriptList);\n  \tobj.featureList = Typr._lctf.readFeatureList(data, offset0 + offFeatureList);\n  \tobj.lookupList  = Typr._lctf.readLookupList (data, offset0 + offLookupList, subt);\n  \t\n  \treturn obj;\n  };\n\n  Typr._lctf.readLookupList = function(data, offset, subt)\n  {\n  \tvar bin = Typr._bin;\n  \tvar offset0 = offset;\n  \tvar obj = [];\n  \tvar count = bin.readUshort(data, offset);  offset+=2;\n  \tfor(var i=0; i<count; i++) \n  \t{\n  \t\tvar noff = bin.readUshort(data, offset);  offset+=2;\n  \t\tvar lut = Typr._lctf.readLookupTable(data, offset0 + noff, subt);\n  \t\tobj.push(lut);\n  \t}\n  \treturn obj;\n  };\n\n  Typr._lctf.readLookupTable = function(data, offset, subt)\n  {\n  \t//console.log("Parsing lookup table", offset);\n  \tvar bin = Typr._bin;\n  \tvar offset0 = offset;\n  \tvar obj = {tabs:[]};\n  \t\n  \tobj.ltype = bin.readUshort(data, offset);  offset+=2;\n  \tobj.flag  = bin.readUshort(data, offset);  offset+=2;\n  \tvar cnt   = bin.readUshort(data, offset);  offset+=2;\n  \t\n  \tfor(var i=0; i<cnt; i++)\n  \t{\n  \t\tvar noff = bin.readUshort(data, offset);  offset+=2;\n  \t\tvar tab = subt(data, obj.ltype, offset0 + noff);\n  \t\t//console.log(obj.type, tab);\n  \t\tobj.tabs.push(tab);\n  \t}\n  \treturn obj;\n  };\n\n  Typr._lctf.numOfOnes = function(n)\n  {\n  \tvar num = 0;\n  \tfor(var i=0; i<32; i++) { if(((n>>>i)&1) != 0) { num++; } }\n  \treturn num;\n  };\n\n  Typr._lctf.readClassDef = function(data, offset)\n  {\n  \tvar bin = Typr._bin;\n  \tvar obj = [];\n  \tvar format = bin.readUshort(data, offset);  offset+=2;\n  \tif(format==1) \n  \t{\n  \t\tvar startGlyph  = bin.readUshort(data, offset);  offset+=2;\n  \t\tvar glyphCount  = bin.readUshort(data, offset);  offset+=2;\n  \t\tfor(var i=0; i<glyphCount; i++)\n  \t\t{\n  \t\t\tobj.push(startGlyph+i);\n  \t\t\tobj.push(startGlyph+i);\n  \t\t\tobj.push(bin.readUshort(data, offset));  offset+=2;\n  \t\t}\n  \t}\n  \tif(format==2)\n  \t{\n  \t\tvar count = bin.readUshort(data, offset);  offset+=2;\n  \t\tfor(var i=0; i<count; i++)\n  \t\t{\n  \t\t\tobj.push(bin.readUshort(data, offset));  offset+=2;\n  \t\t\tobj.push(bin.readUshort(data, offset));  offset+=2;\n  \t\t\tobj.push(bin.readUshort(data, offset));  offset+=2;\n  \t\t}\n  \t}\n  \treturn obj;\n  };\n  Typr._lctf.getInterval = function(tab, val)\n  {\n  \tfor(var i=0; i<tab.length; i+=3)\n  \t{\n  \t\tvar start = tab[i], end = tab[i+1], index = tab[i+2];\n  \t\tif(start<=val && val<=end) { return i; }\n  \t}\n  \treturn -1;\n  };\n\n\n  Typr._lctf.readCoverage = function(data, offset)\n  {\n  \tvar bin = Typr._bin;\n  \tvar cvg = {};\n  \tcvg.fmt   = bin.readUshort(data, offset);  offset+=2;\n  \tvar count = bin.readUshort(data, offset);  offset+=2;\n  \t//console.log("parsing coverage", offset-4, format, count);\n  \tif(cvg.fmt==1) { cvg.tab = bin.readUshorts(data, offset, count); } \n  \tif(cvg.fmt==2) { cvg.tab = bin.readUshorts(data, offset, count*3); }\n  \treturn cvg;\n  };\n\n  Typr._lctf.coverageIndex = function(cvg, val)\n  {\n  \tvar tab = cvg.tab;\n  \tif(cvg.fmt==1) { return tab.indexOf(val); }\n  \tif(cvg.fmt==2) {\n  \t\tvar ind = Typr._lctf.getInterval(tab, val);\n  \t\tif(ind!=-1) { return tab[ind+2] + (val - tab[ind]); }\n  \t}\n  \treturn -1;\n  };\n\n  Typr._lctf.readFeatureList = function(data, offset)\n  {\n  \tvar bin = Typr._bin;\n  \tvar offset0 = offset;\n  \tvar obj = [];\n  \t\n  \tvar count = bin.readUshort(data, offset);  offset+=2;\n  \t\n  \tfor(var i=0; i<count; i++)\n  \t{\n  \t\tvar tag = bin.readASCII(data, offset, 4);  offset+=4;\n  \t\tvar noff = bin.readUshort(data, offset);  offset+=2;\n  \t\tobj.push({tag: tag.trim(), tab:Typr._lctf.readFeatureTable(data, offset0 + noff)});\n  \t}\n  \treturn obj;\n  };\n\n  Typr._lctf.readFeatureTable = function(data, offset)\n  {\n  \tvar bin = Typr._bin;\n  \t\n  \tvar featureParams = bin.readUshort(data, offset);  offset+=2;\t// = 0\n  \tvar lookupCount = bin.readUshort(data, offset);  offset+=2;\n  \t\n  \tvar indices = [];\n  \tfor(var i=0; i<lookupCount; i++) { indices.push(bin.readUshort(data, offset+2*i)); }\n  \treturn indices;\n  };\n\n\n  Typr._lctf.readScriptList = function(data, offset)\n  {\n  \tvar bin = Typr._bin;\n  \tvar offset0 = offset;\n  \tvar obj = {};\n  \t\n  \tvar count = bin.readUshort(data, offset);  offset+=2;\n  \t\n  \tfor(var i=0; i<count; i++)\n  \t{\n  \t\tvar tag = bin.readASCII(data, offset, 4);  offset+=4;\n  \t\tvar noff = bin.readUshort(data, offset);  offset+=2;\n  \t\tobj[tag.trim()] = Typr._lctf.readScriptTable(data, offset0 + noff);\n  \t}\n  \treturn obj;\n  };\n\n  Typr._lctf.readScriptTable = function(data, offset)\n  {\n  \tvar bin = Typr._bin;\n  \tvar offset0 = offset;\n  \tvar obj = {};\n  \t\n  \tvar defLangSysOff = bin.readUshort(data, offset);  offset+=2;\n  \tobj.default = Typr._lctf.readLangSysTable(data, offset0 + defLangSysOff);\n  \t\n  \tvar langSysCount = bin.readUshort(data, offset);  offset+=2;\n  \t\n  \tfor(var i=0; i<langSysCount; i++)\n  \t{\n  \t\tvar tag = bin.readASCII(data, offset, 4);  offset+=4;\n  \t\tvar langSysOff = bin.readUshort(data, offset);  offset+=2;\n  \t\tobj[tag.trim()] = Typr._lctf.readLangSysTable(data, offset0 + langSysOff);\n  \t}\n  \treturn obj;\n  };\n\n  Typr._lctf.readLangSysTable = function(data, offset)\n  {\n  \tvar bin = Typr._bin;\n  \tvar obj = {};\n  \t\n  \tvar lookupOrder = bin.readUshort(data, offset);  offset+=2;\n  \t//if(lookupOrder!=0)  throw "lookupOrder not 0";\n  \tobj.reqFeature = bin.readUshort(data, offset);  offset+=2;\n  \t//if(obj.reqFeature != 0xffff) throw "reqFeatureIndex != 0xffff";\n  \t\n  \t//console.log(lookupOrder, obj.reqFeature);\n  \t\n  \tvar featureCount = bin.readUshort(data, offset);  offset+=2;\n  \tobj.features = bin.readUshorts(data, offset, featureCount);\n  \treturn obj;\n  };\n\n  \tTypr.CFF = {};\n  \tTypr.CFF.parse = function(data, offset, length)\n  \t{\n  \t\tvar bin = Typr._bin;\n  \t\t\n  \t\tdata = new Uint8Array(data.buffer, offset, length);\n  \t\toffset = 0;\n  \t\t\n  \t\t// Header\n  \t\tvar major = data[offset];  offset++;\n  \t\tvar minor = data[offset];  offset++;\n  \t\tvar hdrSize = data[offset];  offset++;\n  \t\tvar offsize = data[offset];  offset++;\n  \t\t//console.log(major, minor, hdrSize, offsize);\n  \t\t\n  \t\t// Name INDEX\n  \t\tvar ninds = [];\n  \t\toffset = Typr.CFF.readIndex(data, offset, ninds);\n  \t\tvar names = [];\n  \t\t\n  \t\tfor(var i=0; i<ninds.length-1; i++) { names.push(bin.readASCII(data, offset+ninds[i], ninds[i+1]-ninds[i])); }\n  \t\toffset += ninds[ninds.length-1];\n  \t\t\n  \t\t\n  \t\t// Top DICT INDEX\n  \t\tvar tdinds = [];\n  \t\toffset = Typr.CFF.readIndex(data, offset, tdinds);  //console.log(tdinds);\n  \t\t// Top DICT Data\n  \t\tvar topDicts = [];\n  \t\tfor(var i=0; i<tdinds.length-1; i++) { topDicts.push( Typr.CFF.readDict(data, offset+tdinds[i], offset+tdinds[i+1]) ); }\n  \t\toffset += tdinds[tdinds.length-1];\n  \t\tvar topdict = topDicts[0];\n  \t\t//console.log(topdict);\n  \t\t\n  \t\t// String INDEX\n  \t\tvar sinds = [];\n  \t\toffset = Typr.CFF.readIndex(data, offset, sinds);\n  \t\t// String Data\n  \t\tvar strings = [];\n  \t\tfor(var i=0; i<sinds.length-1; i++) { strings.push(bin.readASCII(data, offset+sinds[i], sinds[i+1]-sinds[i])); }\n  \t\toffset += sinds[sinds.length-1];\n  \t\t\n  \t\t// Global Subr INDEX  (subroutines)\t\t\n  \t\tTypr.CFF.readSubrs(data, offset, topdict);\n  \t\t\n  \t\t// charstrings\n  \t\tif(topdict.CharStrings)\n  \t\t{\n  \t\t\toffset = topdict.CharStrings;\n  \t\t\tvar sinds = [];\n  \t\t\toffset = Typr.CFF.readIndex(data, offset, sinds);\n  \t\t\t\n  \t\t\tvar cstr = [];\n  \t\t\tfor(var i=0; i<sinds.length-1; i++) { cstr.push(bin.readBytes(data, offset+sinds[i], sinds[i+1]-sinds[i])); }\n  \t\t\t//offset += sinds[sinds.length-1];\n  \t\t\ttopdict.CharStrings = cstr;\n  \t\t\t//console.log(topdict.CharStrings);\n  \t\t}\n  \t\t\n  \t\t// CID font\n  \t\tif(topdict.ROS) {\n  \t\t\toffset = topdict.FDArray;\n  \t\t\tvar fdind = [];\n  \t\t\toffset = Typr.CFF.readIndex(data, offset, fdind);\n  \t\t\t\n  \t\t\ttopdict.FDArray = [];\n  \t\t\tfor(var i=0; i<fdind.length-1; i++) {\n  \t\t\t\tvar dict = Typr.CFF.readDict(data, offset+fdind[i], offset+fdind[i+1]);\n  \t\t\t\tTypr.CFF._readFDict(data, dict, strings);\n  \t\t\t\ttopdict.FDArray.push( dict );\n  \t\t\t}\n  \t\t\toffset += fdind[fdind.length-1];\n  \t\t\t\n  \t\t\toffset = topdict.FDSelect;\n  \t\t\ttopdict.FDSelect = [];\n  \t\t\tvar fmt = data[offset];  offset++;\n  \t\t\tif(fmt==3) {\n  \t\t\t\tvar rns = bin.readUshort(data, offset);  offset+=2;\n  \t\t\t\tfor(var i=0; i<rns+1; i++) {\n  \t\t\t\t\ttopdict.FDSelect.push(bin.readUshort(data, offset), data[offset+2]);  offset+=3;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\telse { throw fmt; }\n  \t\t}\n  \t\t\n  \t\t// Encoding\n  \t\tif(topdict.Encoding) { topdict.Encoding = Typr.CFF.readEncoding(data, topdict.Encoding, topdict.CharStrings.length); }\n  \t\t\n  \t\t// charset\n  \t\tif(topdict.charset ) { topdict.charset  = Typr.CFF.readCharset (data, topdict.charset , topdict.CharStrings.length); }\n  \t\t\n  \t\tTypr.CFF._readFDict(data, topdict, strings);\n  \t\treturn topdict;\n  \t};\n  \tTypr.CFF._readFDict = function(data, dict, ss) {\n  \t\tvar offset;\n  \t\tif(dict.Private) {\n  \t\t\toffset = dict.Private[1];\n  \t\t\tdict.Private = Typr.CFF.readDict(data, offset, offset+dict.Private[0]);\n  \t\t\tif(dict.Private.Subrs)  { Typr.CFF.readSubrs(data, offset+dict.Private.Subrs, dict.Private); }\n  \t\t}\n  \t\tfor(var p in dict) { if(["FamilyName","FontName","FullName","Notice","version","Copyright"].indexOf(p)!=-1)  { dict[p]=ss[dict[p] -426 + 35]; } }\n  \t};\n  \t\n  \tTypr.CFF.readSubrs = function(data, offset, obj)\n  \t{\n  \t\tvar bin = Typr._bin;\n  \t\tvar gsubinds = [];\n  \t\toffset = Typr.CFF.readIndex(data, offset, gsubinds);\n  \t\t\n  \t\tvar bias, nSubrs = gsubinds.length;\n  \t\tif (nSubrs <  1240) { bias = 107; }\n  \t\telse if (nSubrs < 33900) { bias = 1131; }\n  \t\telse { bias = 32768; }\n  \t\tobj.Bias = bias;\n  \t\t\n  \t\tobj.Subrs = [];\n  \t\tfor(var i=0; i<gsubinds.length-1; i++) { obj.Subrs.push(bin.readBytes(data, offset+gsubinds[i], gsubinds[i+1]-gsubinds[i])); }\n  \t\t//offset += gsubinds[gsubinds.length-1];\n  \t};\n  \t\n  \tTypr.CFF.tableSE = [\n        0,   0,   0,   0,   0,   0,   0,   0,\n        0,   0,   0,   0,   0,   0,   0,   0,\n        0,   0,   0,   0,   0,   0,   0,   0,\n        0,   0,   0,   0,   0,   0,   0,   0,\n        1,   2,   3,   4,   5,   6,   7,   8,\n        9,  10,  11,  12,  13,  14,  15,  16,\n       17,  18,  19,  20,  21,  22,  23,  24,\n       25,  26,  27,  28,  29,  30,  31,  32,\n       33,  34,  35,  36,  37,  38,  39,  40,\n       41,  42,  43,  44,  45,  46,  47,  48,\n       49,  50,  51,  52,  53,  54,  55,  56,\n       57,  58,  59,  60,  61,  62,  63,  64,\n       65,  66,  67,  68,  69,  70,  71,  72,\n       73,  74,  75,  76,  77,  78,  79,  80,\n       81,  82,  83,  84,  85,  86,  87,  88,\n       89,  90,  91,  92,  93,  94,  95,   0,\n        0,   0,   0,   0,   0,   0,   0,   0,\n        0,   0,   0,   0,   0,   0,   0,   0,\n        0,   0,   0,   0,   0,   0,   0,   0,\n        0,   0,   0,   0,   0,   0,   0,   0,\n        0,  96,  97,  98,  99, 100, 101, 102,\n      103, 104, 105, 106, 107, 108, 109, 110,\n        0, 111, 112, 113, 114,   0, 115, 116,\n      117, 118, 119, 120, 121, 122,   0, 123,\n        0, 124, 125, 126, 127, 128, 129, 130,\n      131,   0, 132, 133,   0, 134, 135, 136,\n      137,   0,   0,   0,   0,   0,   0,   0,\n        0,   0,   0,   0,   0,   0,   0,   0,\n        0, 138,   0, 139,   0,   0,   0,   0,\n      140, 141, 142, 143,   0,   0,   0,   0,\n        0, 144,   0,   0,   0, 145,   0,   0,\n      146, 147, 148, 149,   0,   0,   0,   0\n    ];\n    \n  \tTypr.CFF.glyphByUnicode = function(cff, code)\n  \t{\n  \t\tfor(var i=0; i<cff.charset.length; i++) { if(cff.charset[i]==code) { return i; } }\n  \t\treturn -1;\n  \t};\n  \t\n  \tTypr.CFF.glyphBySE = function(cff, charcode)\t// glyph by standard encoding\n  \t{\n  \t\tif ( charcode < 0 || charcode > 255 ) { return -1; }\n  \t\treturn Typr.CFF.glyphByUnicode(cff, Typr.CFF.tableSE[charcode]);\t\t\n  \t};\n  \t\n  \tTypr.CFF.readEncoding = function(data, offset, num)\n  \t{\n  \t\tvar bin = Typr._bin;\n  \t\t\n  \t\tvar array = [\'.notdef\'];\n  \t\tvar format = data[offset];  offset++;\n  \t\t//console.log("Encoding");\n  \t\t//console.log(format);\n  \t\t\n  \t\tif(format==0)\n  \t\t{\n  \t\t\tvar nCodes = data[offset];  offset++;\n  \t\t\tfor(var i=0; i<nCodes; i++)  { array.push(data[offset+i]); }\n  \t\t}\n  \t\t/*\n  \t\telse if(format==1 || format==2)\n  \t\t{\n  \t\t\twhile(charset.length<num)\n  \t\t\t{\n  \t\t\t\tvar first = bin.readUshort(data, offset);  offset+=2;\n  \t\t\t\tvar nLeft=0;\n  \t\t\t\tif(format==1) {  nLeft = data[offset];  offset++;  }\n  \t\t\t\telse          {  nLeft = bin.readUshort(data, offset);  offset+=2;  }\n  \t\t\t\tfor(var i=0; i<=nLeft; i++)  {  charset.push(first);  first++;  }\n  \t\t\t}\n  \t\t}\n  \t\t*/\n  \t\telse { throw "error: unknown encoding format: " + format; }\n  \t\t\n  \t\treturn array;\n  \t};\n\n  \tTypr.CFF.readCharset = function(data, offset, num)\n  \t{\n  \t\tvar bin = Typr._bin;\n  \t\t\n  \t\tvar charset = [\'.notdef\'];\n  \t\tvar format = data[offset];  offset++;\n  \t\t\n  \t\tif(format==0)\n  \t\t{\n  \t\t\tfor(var i=0; i<num; i++) \n  \t\t\t{\n  \t\t\t\tvar first = bin.readUshort(data, offset);  offset+=2;\n  \t\t\t\tcharset.push(first);\n  \t\t\t}\n  \t\t}\n  \t\telse if(format==1 || format==2)\n  \t\t{\n  \t\t\twhile(charset.length<num)\n  \t\t\t{\n  \t\t\t\tvar first = bin.readUshort(data, offset);  offset+=2;\n  \t\t\t\tvar nLeft=0;\n  \t\t\t\tif(format==1) {  nLeft = data[offset];  offset++;  }\n  \t\t\t\telse          {  nLeft = bin.readUshort(data, offset);  offset+=2;  }\n  \t\t\t\tfor(var i=0; i<=nLeft; i++)  {  charset.push(first);  first++;  }\n  \t\t\t}\n  \t\t}\n  \t\telse { throw "error: format: " + format; }\n  \t\t\n  \t\treturn charset;\n  \t};\n\n  \tTypr.CFF.readIndex = function(data, offset, inds)\n  \t{\n  \t\tvar bin = Typr._bin;\n  \t\t\n  \t\tvar count = bin.readUshort(data, offset)+1;  offset+=2;\n  \t\tvar offsize = data[offset];  offset++;\n  \t\t\n  \t\tif     (offsize==1) { for(var i=0; i<count; i++) { inds.push( data[offset+i] ); } }\n  \t\telse if(offsize==2) { for(var i=0; i<count; i++) { inds.push( bin.readUshort(data, offset+i*2) ); } }\n  \t\telse if(offsize==3) { for(var i=0; i<count; i++) { inds.push( bin.readUint  (data, offset+i*3 - 1) & 0x00ffffff ); } }\n  \t\telse if(count!=1) { throw "unsupported offset size: " + offsize + ", count: " + count; }\n  \t\t\n  \t\toffset += count*offsize;\n  \t\treturn offset-1;\n  \t};\n  \t\n  \tTypr.CFF.getCharString = function(data, offset, o)\n  \t{\n  \t\tvar bin = Typr._bin;\n  \t\t\n  \t\tvar b0 = data[offset], b1 = data[offset+1], b2 = data[offset+2], b3 = data[offset+3], b4=data[offset+4];\n  \t\tvar vs = 1;\n  \t\tvar op=null, val=null;\n  \t\t// operand\n  \t\tif(b0<=20) { op = b0;  vs=1;  }\n  \t\tif(b0==12) { op = b0*100+b1;  vs=2;  }\n  \t\t//if(b0==19 || b0==20) { op = b0/*+" "+b1*/;  vs=2; }\n  \t\tif(21 <=b0 && b0<= 27) { op = b0;  vs=1; }\n  \t\tif(b0==28) { val = bin.readShort(data,offset+1);  vs=3; }\n  \t\tif(29 <=b0 && b0<= 31) { op = b0;  vs=1; }\n  \t\tif(32 <=b0 && b0<=246) { val = b0-139;  vs=1; }\n  \t\tif(247<=b0 && b0<=250) { val = (b0-247)*256+b1+108;  vs=2; }\n  \t\tif(251<=b0 && b0<=254) { val =-(b0-251)*256-b1-108;  vs=2; }\n  \t\tif(b0==255) {  val = bin.readInt(data, offset+1)/0xffff;  vs=5;   }\n  \t\t\n  \t\to.val = val!=null ? val : "o"+op;\n  \t\to.size = vs;\n  \t};\n  \t\n  \tTypr.CFF.readCharString = function(data, offset, length)\n  \t{\n  \t\tvar end = offset + length;\n  \t\tvar bin = Typr._bin;\n  \t\tvar arr = [];\n  \t\t\n  \t\twhile(offset<end)\n  \t\t{\n  \t\t\tvar b0 = data[offset], b1 = data[offset+1], b2 = data[offset+2], b3 = data[offset+3], b4=data[offset+4];\n  \t\t\tvar vs = 1;\n  \t\t\tvar op=null, val=null;\n  \t\t\t// operand\n  \t\t\tif(b0<=20) { op = b0;  vs=1;  }\n  \t\t\tif(b0==12) { op = b0*100+b1;  vs=2;  }\n  \t\t\tif(b0==19 || b0==20) { op = b0/*+" "+b1*/;  vs=2; }\n  \t\t\tif(21 <=b0 && b0<= 27) { op = b0;  vs=1; }\n  \t\t\tif(b0==28) { val = bin.readShort(data,offset+1);  vs=3; }\n  \t\t\tif(29 <=b0 && b0<= 31) { op = b0;  vs=1; }\n  \t\t\tif(32 <=b0 && b0<=246) { val = b0-139;  vs=1; }\n  \t\t\tif(247<=b0 && b0<=250) { val = (b0-247)*256+b1+108;  vs=2; }\n  \t\t\tif(251<=b0 && b0<=254) { val =-(b0-251)*256-b1-108;  vs=2; }\n  \t\t\tif(b0==255) {  val = bin.readInt(data, offset+1)/0xffff;  vs=5;   }\n  \t\t\t\n  \t\t\tarr.push(val!=null ? val : "o"+op);\n  \t\t\toffset += vs;\t\n\n  \t\t\t//var cv = arr[arr.length-1];\n  \t\t\t//if(cv==undefined) throw "error";\n  \t\t\t//console.log()\n  \t\t}\t\n  \t\treturn arr;\n  \t};\n\n  \tTypr.CFF.readDict = function(data, offset, end)\n  \t{\n  \t\tvar bin = Typr._bin;\n  \t\t//var dict = [];\n  \t\tvar dict = {};\n  \t\tvar carr = [];\n  \t\t\n  \t\twhile(offset<end)\n  \t\t{\n  \t\t\tvar b0 = data[offset], b1 = data[offset+1], b2 = data[offset+2], b3 = data[offset+3], b4=data[offset+4];\n  \t\t\tvar vs = 1;\n  \t\t\tvar key=null, val=null;\n  \t\t\t// operand\n  \t\t\tif(b0==28) { val = bin.readShort(data,offset+1);  vs=3; }\n  \t\t\tif(b0==29) { val = bin.readInt  (data,offset+1);  vs=5; }\n  \t\t\tif(32 <=b0 && b0<=246) { val = b0-139;  vs=1; }\n  \t\t\tif(247<=b0 && b0<=250) { val = (b0-247)*256+b1+108;  vs=2; }\n  \t\t\tif(251<=b0 && b0<=254) { val =-(b0-251)*256-b1-108;  vs=2; }\n  \t\t\tif(b0==255) {  val = bin.readInt(data, offset+1)/0xffff;  vs=5;  throw "unknown number";  }\n  \t\t\t\n  \t\t\tif(b0==30) \n  \t\t\t{  \n  \t\t\t\tvar nibs = [];\n  \t\t\t\tvs = 1;\n  \t\t\t\twhile(true)\n  \t\t\t\t{\n  \t\t\t\t\tvar b = data[offset+vs];  vs++;\n  \t\t\t\t\tvar nib0 = b>>4, nib1 = b&0xf;\n  \t\t\t\t\tif(nib0 != 0xf) { nibs.push(nib0); }  if(nib1!=0xf) { nibs.push(nib1); }\n  \t\t\t\t\tif(nib1==0xf) { break; }\n  \t\t\t\t}\n  \t\t\t\tvar s = "";\n  \t\t\t\tvar chars = [0,1,2,3,4,5,6,7,8,9,".","e","e-","reserved","-","endOfNumber"];\n  \t\t\t\tfor(var i=0; i<nibs.length; i++) { s += chars[nibs[i]]; }\n  \t\t\t\t//console.log(nibs);\n  \t\t\t\tval = parseFloat(s);\n  \t\t\t}\n  \t\t\t\n  \t\t\tif(b0<=21)\t// operator\n  \t\t\t{\n  \t\t\t\tvar keys = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues","FamilyOtherBlues",\n  \t\t\t\t\t"StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", \n  \t\t\t\t\t"defaultWidthX", "nominalWidthX"];\n  \t\t\t\t\t\n  \t\t\t\tkey = keys[b0];  vs=1;\n  \t\t\t\tif(b0==12) { \n  \t\t\t\t\tvar keys = [ "Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale",\n  \t\t\t\t\t"BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0,0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed",\n  \t\t\t\t\t"SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0,0,0,0,0,0, \n  \t\t\t\t\t"ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"];\n  \t\t\t\t\tkey = keys[b1];  vs=2; \n  \t\t\t\t}\n  \t\t\t}\n  \t\t\t\n  \t\t\tif(key!=null) {  dict[key] = carr.length==1 ? carr[0] : carr;  carr=[]; }\n  \t\t\telse  { carr.push(val); }  \n  \t\t\t\n  \t\t\toffset += vs;\t\t\n  \t\t}\t\n  \t\treturn dict;\n  \t};\n\n\n  Typr.cmap = {};\n  Typr.cmap.parse = function(data, offset, length)\n  {\n  \tdata = new Uint8Array(data.buffer, offset, length);\n  \toffset = 0;\n  \tvar bin = Typr._bin;\n  \tvar obj = {};\n  \tvar version   = bin.readUshort(data, offset);  offset += 2;\n  \tvar numTables = bin.readUshort(data, offset);  offset += 2;\n  \t\n  \t//console.log(version, numTables);\n  \t\n  \tvar offs = [];\n  \tobj.tables = [];\n  \t\n  \t\n  \tfor(var i=0; i<numTables; i++)\n  \t{\n  \t\tvar platformID = bin.readUshort(data, offset);  offset += 2;\n  \t\tvar encodingID = bin.readUshort(data, offset);  offset += 2;\n  \t\tvar noffset = bin.readUint(data, offset);       offset += 4;\n  \t\t\n  \t\tvar id = "p"+platformID+"e"+encodingID;\n  \t\t\n  \t\t//console.log("cmap subtable", platformID, encodingID, noffset);\n  \t\t\n  \t\t\n  \t\tvar tind = offs.indexOf(noffset);\n  \t\t\n  \t\tif(tind==-1)\n  \t\t{\n  \t\t\ttind = obj.tables.length;\n  \t\t\tvar subt;\n  \t\t\toffs.push(noffset);\n  \t\t\tvar format = bin.readUshort(data, noffset);\n  \t\t\tif     (format== 0) { subt = Typr.cmap.parse0(data, noffset); }\n  \t\t\telse if(format== 4) { subt = Typr.cmap.parse4(data, noffset); }\n  \t\t\telse if(format== 6) { subt = Typr.cmap.parse6(data, noffset); }\n  \t\t\telse if(format==12) { subt = Typr.cmap.parse12(data,noffset); }\n  \t\t\telse { console.log("unknown format: "+format, platformID, encodingID, noffset); }\n  \t\t\tobj.tables.push(subt);\n  \t\t}\n  \t\t\n  \t\tif(obj[id]!=null) { throw "multiple tables for one platform+encoding"; }\n  \t\tobj[id] = tind;\n  \t}\n  \treturn obj;\n  };\n\n  Typr.cmap.parse0 = function(data, offset)\n  {\n  \tvar bin = Typr._bin;\n  \tvar obj = {};\n  \tobj.format = bin.readUshort(data, offset);  offset += 2;\n  \tvar len    = bin.readUshort(data, offset);  offset += 2;\n  \tvar lang   = bin.readUshort(data, offset);  offset += 2;\n  \tobj.map = [];\n  \tfor(var i=0; i<len-6; i++) { obj.map.push(data[offset+i]); }\n  \treturn obj;\n  };\n\n  Typr.cmap.parse4 = function(data, offset)\n  {\n  \tvar bin = Typr._bin;\n  \tvar offset0 = offset;\n  \tvar obj = {};\n  \t\n  \tobj.format = bin.readUshort(data, offset);  offset+=2;\n  \tvar length = bin.readUshort(data, offset);  offset+=2;\n  \tvar language = bin.readUshort(data, offset);  offset+=2;\n  \tvar segCountX2 = bin.readUshort(data, offset);  offset+=2;\n  \tvar segCount = segCountX2/2;\n  \tobj.searchRange = bin.readUshort(data, offset);  offset+=2;\n  \tobj.entrySelector = bin.readUshort(data, offset);  offset+=2;\n  \tobj.rangeShift = bin.readUshort(data, offset);  offset+=2;\n  \tobj.endCount   = bin.readUshorts(data, offset, segCount);  offset += segCount*2;\n  \toffset+=2;\n  \tobj.startCount = bin.readUshorts(data, offset, segCount);  offset += segCount*2;\n  \tobj.idDelta = [];\n  \tfor(var i=0; i<segCount; i++) {obj.idDelta.push(bin.readShort(data, offset));  offset+=2;}\n  \tobj.idRangeOffset = bin.readUshorts(data, offset, segCount);  offset += segCount*2;\n  \tobj.glyphIdArray = [];\n  \twhile(offset< offset0+length) {obj.glyphIdArray.push(bin.readUshort(data, offset));  offset+=2;}\n  \treturn obj;\n  };\n\n  Typr.cmap.parse6 = function(data, offset)\n  {\n  \tvar bin = Typr._bin;\n  \tvar obj = {};\n  \t\n  \tobj.format = bin.readUshort(data, offset);  offset+=2;\n  \tvar length = bin.readUshort(data, offset);  offset+=2;\n  \tvar language = bin.readUshort(data, offset);  offset+=2;\n  \tobj.firstCode = bin.readUshort(data, offset);  offset+=2;\n  \tvar entryCount = bin.readUshort(data, offset);  offset+=2;\n  \tobj.glyphIdArray = [];\n  \tfor(var i=0; i<entryCount; i++) {obj.glyphIdArray.push(bin.readUshort(data, offset));  offset+=2;}\n  \t\n  \treturn obj;\n  };\n\n  Typr.cmap.parse12 = function(data, offset)\n  {\n  \tvar bin = Typr._bin;\n  \tvar obj = {};\n  \t\n  \tobj.format = bin.readUshort(data, offset);  offset+=2;\n  \toffset += 2;\n  \tvar length = bin.readUint(data, offset);  offset+=4;\n  \tvar lang   = bin.readUint(data, offset);  offset+=4;\n  \tvar nGroups= bin.readUint(data, offset);  offset+=4;\n  \tobj.groups = [];\n  \t\n  \tfor(var i=0; i<nGroups; i++)  \n  \t{\n  \t\tvar off = offset + i * 12;\n  \t\tvar startCharCode = bin.readUint(data, off+0);\n  \t\tvar endCharCode   = bin.readUint(data, off+4);\n  \t\tvar startGlyphID  = bin.readUint(data, off+8);\n  \t\tobj.groups.push([  startCharCode, endCharCode, startGlyphID  ]);\n  \t}\n  \treturn obj;\n  };\n\n  Typr.glyf = {};\n  Typr.glyf.parse = function(data, offset, length, font)\n  {\n  \tvar obj = [];\n  \tfor(var g=0; g<font.maxp.numGlyphs; g++) { obj.push(null); }\n  \treturn obj;\n  };\n\n  Typr.glyf._parseGlyf = function(font, g)\n  {\n  \tvar bin = Typr._bin;\n  \tvar data = font._data;\n  \t\n  \tvar offset = Typr._tabOffset(data, "glyf", font._offset) + font.loca[g];\n  \t\t\n  \tif(font.loca[g]==font.loca[g+1]) { return null; }\n  \t\t\n  \tvar gl = {};\n  \t\t\n  \tgl.noc  = bin.readShort(data, offset);  offset+=2;\t\t// number of contours\n  \tgl.xMin = bin.readShort(data, offset);  offset+=2;\n  \tgl.yMin = bin.readShort(data, offset);  offset+=2;\n  \tgl.xMax = bin.readShort(data, offset);  offset+=2;\n  \tgl.yMax = bin.readShort(data, offset);  offset+=2;\n  \t\n  \tif(gl.xMin>=gl.xMax || gl.yMin>=gl.yMax) { return null; }\n  \t\t\n  \tif(gl.noc>0)\n  \t{\n  \t\tgl.endPts = [];\n  \t\tfor(var i=0; i<gl.noc; i++) { gl.endPts.push(bin.readUshort(data,offset)); offset+=2; }\n  \t\t\n  \t\tvar instructionLength = bin.readUshort(data,offset); offset+=2;\n  \t\tif((data.length-offset)<instructionLength) { return null; }\n  \t\tgl.instructions = bin.readBytes(data, offset, instructionLength);   offset+=instructionLength;\n  \t\t\n  \t\tvar crdnum = gl.endPts[gl.noc-1]+1;\n  \t\tgl.flags = [];\n  \t\tfor(var i=0; i<crdnum; i++ ) \n  \t\t{ \n  \t\t\tvar flag = data[offset];  offset++; \n  \t\t\tgl.flags.push(flag); \n  \t\t\tif((flag&8)!=0)\n  \t\t\t{\n  \t\t\t\tvar rep = data[offset];  offset++;\n  \t\t\t\tfor(var j=0; j<rep; j++) { gl.flags.push(flag); i++; }\n  \t\t\t}\n  \t\t}\n  \t\tgl.xs = [];\n  \t\tfor(var i=0; i<crdnum; i++) {\n  \t\t\tvar i8=((gl.flags[i]&2)!=0), same=((gl.flags[i]&16)!=0);  \n  \t\t\tif(i8) { gl.xs.push(same ? data[offset] : -data[offset]);  offset++; }\n  \t\t\telse\n  \t\t\t{\n  \t\t\t\tif(same) { gl.xs.push(0); }\n  \t\t\t\telse { gl.xs.push(bin.readShort(data, offset));  offset+=2; }\n  \t\t\t}\n  \t\t}\n  \t\tgl.ys = [];\n  \t\tfor(var i=0; i<crdnum; i++) {\n  \t\t\tvar i8=((gl.flags[i]&4)!=0), same=((gl.flags[i]&32)!=0);  \n  \t\t\tif(i8) { gl.ys.push(same ? data[offset] : -data[offset]);  offset++; }\n  \t\t\telse\n  \t\t\t{\n  \t\t\t\tif(same) { gl.ys.push(0); }\n  \t\t\t\telse { gl.ys.push(bin.readShort(data, offset));  offset+=2; }\n  \t\t\t}\n  \t\t}\n  \t\tvar x = 0, y = 0;\n  \t\tfor(var i=0; i<crdnum; i++) { x += gl.xs[i]; y += gl.ys[i];  gl.xs[i]=x;  gl.ys[i]=y; }\n  \t\t//console.log(endPtsOfContours, instructionLength, instructions, flags, xCoordinates, yCoordinates);\n  \t}\n  \telse\n  \t{\n  \t\tvar ARG_1_AND_2_ARE_WORDS\t= 1<<0;\n  \t\tvar ARGS_ARE_XY_VALUES\t\t= 1<<1;\n  \t\tvar WE_HAVE_A_SCALE\t\t\t= 1<<3;\n  \t\tvar MORE_COMPONENTS\t\t\t= 1<<5;\n  \t\tvar WE_HAVE_AN_X_AND_Y_SCALE= 1<<6;\n  \t\tvar WE_HAVE_A_TWO_BY_TWO\t= 1<<7;\n  \t\tvar WE_HAVE_INSTRUCTIONS\t= 1<<8;\n  \t\t\n  \t\tgl.parts = [];\n  \t\tvar flags;\n  \t\tdo {\n  \t\t\tflags = bin.readUshort(data, offset);  offset += 2;\n  \t\t\tvar part = { m:{a:1,b:0,c:0,d:1,tx:0,ty:0}, p1:-1, p2:-1 };  gl.parts.push(part);\n  \t\t\tpart.glyphIndex = bin.readUshort(data, offset);  offset += 2;\n  \t\t\tif ( flags & ARG_1_AND_2_ARE_WORDS) {\n  \t\t\t\tvar arg1 = bin.readShort(data, offset);  offset += 2;\n  \t\t\t\tvar arg2 = bin.readShort(data, offset);  offset += 2;\n  \t\t\t} else {\n  \t\t\t\tvar arg1 = bin.readInt8(data, offset);  offset ++;\n  \t\t\t\tvar arg2 = bin.readInt8(data, offset);  offset ++;\n  \t\t\t}\n  \t\t\t\n  \t\t\tif(flags & ARGS_ARE_XY_VALUES) { part.m.tx = arg1;  part.m.ty = arg2; }\n  \t\t\telse  {  part.p1=arg1;  part.p2=arg2;  }\n  \t\t\t//part.m.tx = arg1;  part.m.ty = arg2;\n  \t\t\t//else { throw "params are not XY values"; }\n  \t\t\t\n  \t\t\tif ( flags & WE_HAVE_A_SCALE ) {\n  \t\t\t\tpart.m.a = part.m.d = bin.readF2dot14(data, offset);  offset += 2;    \n  \t\t\t} else if ( flags & WE_HAVE_AN_X_AND_Y_SCALE ) {\n  \t\t\t\tpart.m.a = bin.readF2dot14(data, offset);  offset += 2; \n  \t\t\t\tpart.m.d = bin.readF2dot14(data, offset);  offset += 2; \n  \t\t\t} else if ( flags & WE_HAVE_A_TWO_BY_TWO ) {\n  \t\t\t\tpart.m.a = bin.readF2dot14(data, offset);  offset += 2; \n  \t\t\t\tpart.m.b = bin.readF2dot14(data, offset);  offset += 2; \n  \t\t\t\tpart.m.c = bin.readF2dot14(data, offset);  offset += 2; \n  \t\t\t\tpart.m.d = bin.readF2dot14(data, offset);  offset += 2; \n  \t\t\t}\n  \t\t} while ( flags & MORE_COMPONENTS ) \n  \t\tif (flags & WE_HAVE_INSTRUCTIONS){\n  \t\t\tvar numInstr = bin.readUshort(data, offset);  offset += 2;\n  \t\t\tgl.instr = [];\n  \t\t\tfor(var i=0; i<numInstr; i++) { gl.instr.push(data[offset]);  offset++; }\n  \t\t}\n  \t}\n  \treturn gl;\n  };\n\n\n  Typr.GPOS = {};\n  Typr.GPOS.parse = function(data, offset, length, font) {  return Typr._lctf.parse(data, offset, length, font, Typr.GPOS.subt);  };\n\n\n  Typr.GPOS.subt = function(data, ltype, offset)\t// lookup type\n  {\n  \tvar bin = Typr._bin, offset0 = offset, tab = {};\n  \t\n  \ttab.fmt  = bin.readUshort(data, offset);  offset+=2;\n  \t\n  \t//console.log(ltype, tab.fmt);\n  \t\n  \tif(ltype==1 || ltype==2 || ltype==3 || ltype==7 || (ltype==8 && tab.fmt<=2)) {\n  \t\tvar covOff  = bin.readUshort(data, offset);  offset+=2;\n  \t\ttab.coverage = Typr._lctf.readCoverage(data, covOff+offset0);\n  \t}\n  \tif(ltype==1 && tab.fmt==1) {\n  \t\tvar valFmt1 = bin.readUshort(data, offset);  offset+=2;\n  \t\tvar ones1 = Typr._lctf.numOfOnes(valFmt1);\n  \t\tif(valFmt1!=0)  { tab.pos = Typr.GPOS.readValueRecord(data, offset, valFmt1); }\n  \t}\n  \telse if(ltype==2) {\n  \t\tvar valFmt1 = bin.readUshort(data, offset);  offset+=2;\n  \t\tvar valFmt2 = bin.readUshort(data, offset);  offset+=2;\n  \t\tvar ones1 = Typr._lctf.numOfOnes(valFmt1);\n  \t\tvar ones2 = Typr._lctf.numOfOnes(valFmt2);\n  \t\tif(tab.fmt==1)\n  \t\t{\n  \t\t\ttab.pairsets = [];\n  \t\t\tvar psc = bin.readUshort(data, offset);  offset+=2;  // PairSetCount\n  \t\t\t\n  \t\t\tfor(var i=0; i<psc; i++)\n  \t\t\t{\n  \t\t\t\tvar psoff = offset0 + bin.readUshort(data, offset);  offset+=2;\n  \t\t\t\t\n  \t\t\t\tvar pvc = bin.readUshort(data, psoff);  psoff+=2;\n  \t\t\t\tvar arr = [];\n  \t\t\t\tfor(var j=0; j<pvc; j++)\n  \t\t\t\t{\n  \t\t\t\t\tvar gid2 = bin.readUshort(data, psoff);  psoff+=2;\n  \t\t\t\t\tvar value1, value2;\n  \t\t\t\t\tif(valFmt1!=0) {  value1 = Typr.GPOS.readValueRecord(data, psoff, valFmt1);  psoff+=ones1*2;  }\n  \t\t\t\t\tif(valFmt2!=0) {  value2 = Typr.GPOS.readValueRecord(data, psoff, valFmt2);  psoff+=ones2*2;  }\n  \t\t\t\t\t//if(value1!=null) throw "e";\n  \t\t\t\t\tarr.push({gid2:gid2, val1:value1, val2:value2});\n  \t\t\t\t}\n  \t\t\t\ttab.pairsets.push(arr);\n  \t\t\t}\n  \t\t}\n  \t\tif(tab.fmt==2)\n  \t\t{\n  \t\t\tvar classDef1 = bin.readUshort(data, offset);  offset+=2;\n  \t\t\tvar classDef2 = bin.readUshort(data, offset);  offset+=2;\n  \t\t\tvar class1Count = bin.readUshort(data, offset);  offset+=2;\n  \t\t\tvar class2Count = bin.readUshort(data, offset);  offset+=2;\n  \t\t\t\n  \t\t\ttab.classDef1 = Typr._lctf.readClassDef(data, offset0 + classDef1);\n  \t\t\ttab.classDef2 = Typr._lctf.readClassDef(data, offset0 + classDef2);\n  \t\t\t\n  \t\t\ttab.matrix = [];\n  \t\t\tfor(var i=0; i<class1Count; i++)\n  \t\t\t{\n  \t\t\t\tvar row = [];\n  \t\t\t\tfor(var j=0; j<class2Count; j++)\n  \t\t\t\t{\n  \t\t\t\t\tvar value1 = null, value2 = null;\n  \t\t\t\t\tif(tab.valFmt1!=0) { value1 = Typr.GPOS.readValueRecord(data, offset, tab.valFmt1);  offset+=ones1*2; }\n  \t\t\t\t\tif(tab.valFmt2!=0) { value2 = Typr.GPOS.readValueRecord(data, offset, tab.valFmt2);  offset+=ones2*2; }\n  \t\t\t\t\trow.push({val1:value1, val2:value2});\n  \t\t\t\t}\n  \t\t\t\ttab.matrix.push(row);\n  \t\t\t}\n  \t\t}\n  \t}\n  \treturn tab;\n  };\n\n\n  Typr.GPOS.readValueRecord = function(data, offset, valFmt)\n  {\n  \tvar bin = Typr._bin;\n  \tvar arr = [];\n  \tarr.push( (valFmt&1) ? bin.readShort(data, offset) : 0 );  offset += (valFmt&1) ? 2 : 0;  // X_PLACEMENT\n  \tarr.push( (valFmt&2) ? bin.readShort(data, offset) : 0 );  offset += (valFmt&2) ? 2 : 0;  // Y_PLACEMENT\n  \tarr.push( (valFmt&4) ? bin.readShort(data, offset) : 0 );  offset += (valFmt&4) ? 2 : 0;  // X_ADVANCE\n  \tarr.push( (valFmt&8) ? bin.readShort(data, offset) : 0 );  offset += (valFmt&8) ? 2 : 0;  // Y_ADVANCE\n  \treturn arr;\n  };\n\n  Typr.GSUB = {};\n  Typr.GSUB.parse = function(data, offset, length, font) {  return Typr._lctf.parse(data, offset, length, font, Typr.GSUB.subt);  };\n\n\n  Typr.GSUB.subt = function(data, ltype, offset)\t// lookup type\n  {\n  \tvar bin = Typr._bin, offset0 = offset, tab = {};\n  \t\n  \ttab.fmt  = bin.readUshort(data, offset);  offset+=2;\n  \t\n  \tif(ltype!=1 && ltype!=4 && ltype!=5 && ltype!=6) { return null; }\n  \t\n  \tif(ltype==1 || ltype==4 || (ltype==5 && tab.fmt<=2) || (ltype==6 && tab.fmt<=2)) {\n  \t\tvar covOff  = bin.readUshort(data, offset);  offset+=2;\n  \t\ttab.coverage = Typr._lctf.readCoverage(data, offset0+covOff);\t// not always is coverage here\n  \t}\n  \t\n  \tif(ltype==1) {\t\n  \t\tif(tab.fmt==1) {\n  \t\t\ttab.delta = bin.readShort(data, offset);  offset+=2;\n  \t\t}\n  \t\telse if(tab.fmt==2) {\n  \t\t\tvar cnt = bin.readUshort(data, offset);  offset+=2;\n  \t\t\ttab.newg = bin.readUshorts(data, offset, cnt);  offset+=tab.newg.length*2;\n  \t\t}\n  \t}\n  \t//  Ligature Substitution Subtable\n  \telse if(ltype==4) {\n  \t\ttab.vals = [];\n  \t\tvar cnt = bin.readUshort(data, offset);  offset+=2;\n  \t\tfor(var i=0; i<cnt; i++) {\n  \t\t\tvar loff = bin.readUshort(data, offset);  offset+=2;\n  \t\t\ttab.vals.push(Typr.GSUB.readLigatureSet(data, offset0+loff));\n  \t\t}\n  \t\t//console.log(tab.coverage);\n  \t\t//console.log(tab.vals);\n  \t} \n  \t//  Contextual Substitution Subtable\n  \telse if(ltype==5) {\n  \t\tif(tab.fmt==2) {\n  \t\t\tvar cDefOffset = bin.readUshort(data, offset);  offset+=2;\n  \t\t\ttab.cDef = Typr._lctf.readClassDef(data, offset0 + cDefOffset);\n  \t\t\ttab.scset = [];\n  \t\t\tvar subClassSetCount = bin.readUshort(data, offset);  offset+=2;\n  \t\t\tfor(var i=0; i<subClassSetCount; i++)\n  \t\t\t{\n  \t\t\t\tvar scsOff = bin.readUshort(data, offset);  offset+=2;\n  \t\t\t\ttab.scset.push(  scsOff==0 ? null : Typr.GSUB.readSubClassSet(data, offset0 + scsOff)  );\n  \t\t\t}\n  \t\t}\n  \t\t//else console.log("unknown table format", tab.fmt);\n  \t}\n  \t//*\n  \telse if(ltype==6) {\n  \t\t/*\n  \t\tif(tab.fmt==2) {\n  \t\t\tvar btDef = bin.readUshort(data, offset);  offset+=2;\n  \t\t\tvar inDef = bin.readUshort(data, offset);  offset+=2;\n  \t\t\tvar laDef = bin.readUshort(data, offset);  offset+=2;\n  \t\t\t\n  \t\t\ttab.btDef = Typr._lctf.readClassDef(data, offset0 + btDef);\n  \t\t\ttab.inDef = Typr._lctf.readClassDef(data, offset0 + inDef);\n  \t\t\ttab.laDef = Typr._lctf.readClassDef(data, offset0 + laDef);\n  \t\t\t\n  \t\t\ttab.scset = [];\n  \t\t\tvar cnt = bin.readUshort(data, offset);  offset+=2;\n  \t\t\tfor(var i=0; i<cnt; i++) {\n  \t\t\t\tvar loff = bin.readUshort(data, offset);  offset+=2;\n  \t\t\t\ttab.scset.push(Typr.GSUB.readChainSubClassSet(data, offset0+loff));\n  \t\t\t}\n  \t\t}\n  \t\t*/\n  \t\tif(tab.fmt==3) {\n  \t\t\tfor(var i=0; i<3; i++) {\n  \t\t\t\tvar cnt = bin.readUshort(data, offset);  offset+=2;\n  \t\t\t\tvar cvgs = [];\n  \t\t\t\tfor(var j=0; j<cnt; j++) { cvgs.push(  Typr._lctf.readCoverage(data, offset0 + bin.readUshort(data, offset+j*2))   ); }\n  \t\t\t\toffset+=cnt*2;\n  \t\t\t\tif(i==0) { tab.backCvg = cvgs; }\n  \t\t\t\tif(i==1) { tab.inptCvg = cvgs; }\n  \t\t\t\tif(i==2) { tab.ahedCvg = cvgs; }\n  \t\t\t}\n  \t\t\tvar cnt = bin.readUshort(data, offset);  offset+=2;\n  \t\t\ttab.lookupRec = Typr.GSUB.readSubstLookupRecords(data, offset, cnt);\n  \t\t}\n  \t\t//console.log(tab);\n  \t} //*/\n  \t//if(tab.coverage.indexOf(3)!=-1) console.log(ltype, fmt, tab);\n  \t\n  \treturn tab;\n  };\n\n  Typr.GSUB.readSubClassSet = function(data, offset)\n  {\n  \tvar rUs = Typr._bin.readUshort, offset0 = offset, lset = [];\n  \tvar cnt = rUs(data, offset);  offset+=2;\n  \tfor(var i=0; i<cnt; i++) {\n  \t\tvar loff = rUs(data, offset);  offset+=2;\n  \t\tlset.push(Typr.GSUB.readSubClassRule(data, offset0+loff));\n  \t}\n  \treturn lset;\n  };\n  Typr.GSUB.readSubClassRule= function(data, offset)\n  {\n  \tvar rUs = Typr._bin.readUshort, rule = {};\n  \tvar gcount = rUs(data, offset);  offset+=2;\n  \tvar scount = rUs(data, offset);  offset+=2;\n  \trule.input = [];\n  \tfor(var i=0; i<gcount-1; i++) {\n  \t\trule.input.push(rUs(data, offset));  offset+=2;\n  \t}\n  \trule.substLookupRecords = Typr.GSUB.readSubstLookupRecords(data, offset, scount);\n  \treturn rule;\n  };\n  Typr.GSUB.readSubstLookupRecords = function(data, offset, cnt)\n  {\n  \tvar rUs = Typr._bin.readUshort;\n  \tvar out = [];\n  \tfor(var i=0; i<cnt; i++) {  out.push(rUs(data, offset), rUs(data, offset+2));  offset+=4;  }\n  \treturn out;\n  };\n\n  Typr.GSUB.readChainSubClassSet = function(data, offset)\n  {\n  \tvar bin = Typr._bin, offset0 = offset, lset = [];\n  \tvar cnt = bin.readUshort(data, offset);  offset+=2;\n  \tfor(var i=0; i<cnt; i++) {\n  \t\tvar loff = bin.readUshort(data, offset);  offset+=2;\n  \t\tlset.push(Typr.GSUB.readChainSubClassRule(data, offset0+loff));\n  \t}\n  \treturn lset;\n  };\n  Typr.GSUB.readChainSubClassRule= function(data, offset)\n  {\n  \tvar bin = Typr._bin, rule = {};\n  \tvar pps = ["backtrack", "input", "lookahead"];\n  \tfor(var pi=0; pi<pps.length; pi++) {\n  \t\tvar cnt = bin.readUshort(data, offset);  offset+=2;  if(pi==1) { cnt--; }\n  \t\trule[pps[pi]]=bin.readUshorts(data, offset, cnt);  offset+= rule[pps[pi]].length*2;\n  \t}\n  \tvar cnt = bin.readUshort(data, offset);  offset+=2;\n  \trule.subst = bin.readUshorts(data, offset, cnt*2);  offset += rule.subst.length*2;\n  \treturn rule;\n  };\n\n  Typr.GSUB.readLigatureSet = function(data, offset)\n  {\n  \tvar bin = Typr._bin, offset0 = offset, lset = [];\n  \tvar lcnt = bin.readUshort(data, offset);  offset+=2;\n  \tfor(var j=0; j<lcnt; j++) {\n  \t\tvar loff = bin.readUshort(data, offset);  offset+=2;\n  \t\tlset.push(Typr.GSUB.readLigature(data, offset0+loff));\n  \t}\n  \treturn lset;\n  };\n  Typr.GSUB.readLigature = function(data, offset)\n  {\n  \tvar bin = Typr._bin, lig = {chain:[]};\n  \tlig.nglyph = bin.readUshort(data, offset);  offset+=2;\n  \tvar ccnt = bin.readUshort(data, offset);  offset+=2;\n  \tfor(var k=0; k<ccnt-1; k++) {  lig.chain.push(bin.readUshort(data, offset));  offset+=2;  }\n  \treturn lig;\n  };\n\n\n\n  Typr.head = {};\n  Typr.head.parse = function(data, offset, length)\n  {\n  \tvar bin = Typr._bin;\n  \tvar obj = {};\n  \tvar tableVersion = bin.readFixed(data, offset);  offset += 4;\n  \tobj.fontRevision = bin.readFixed(data, offset);  offset += 4;\n  \tvar checkSumAdjustment = bin.readUint(data, offset);  offset += 4;\n  \tvar magicNumber = bin.readUint(data, offset);  offset += 4;\n  \tobj.flags = bin.readUshort(data, offset);  offset += 2;\n  \tobj.unitsPerEm = bin.readUshort(data, offset);  offset += 2;\n  \tobj.created  = bin.readUint64(data, offset);  offset += 8;\n  \tobj.modified = bin.readUint64(data, offset);  offset += 8;\n  \tobj.xMin = bin.readShort(data, offset);  offset += 2;\n  \tobj.yMin = bin.readShort(data, offset);  offset += 2;\n  \tobj.xMax = bin.readShort(data, offset);  offset += 2;\n  \tobj.yMax = bin.readShort(data, offset);  offset += 2;\n  \tobj.macStyle = bin.readUshort(data, offset);  offset += 2;\n  \tobj.lowestRecPPEM = bin.readUshort(data, offset);  offset += 2;\n  \tobj.fontDirectionHint = bin.readShort(data, offset);  offset += 2;\n  \tobj.indexToLocFormat  = bin.readShort(data, offset);  offset += 2;\n  \tobj.glyphDataFormat   = bin.readShort(data, offset);  offset += 2;\n  \treturn obj;\n  };\n\n\n  Typr.hhea = {};\n  Typr.hhea.parse = function(data, offset, length)\n  {\n  \tvar bin = Typr._bin;\n  \tvar obj = {};\n  \tvar tableVersion = bin.readFixed(data, offset);  offset += 4;\n  \tobj.ascender  = bin.readShort(data, offset);  offset += 2;\n  \tobj.descender = bin.readShort(data, offset);  offset += 2;\n  \tobj.lineGap = bin.readShort(data, offset);  offset += 2;\n  \t\n  \tobj.advanceWidthMax = bin.readUshort(data, offset);  offset += 2;\n  \tobj.minLeftSideBearing  = bin.readShort(data, offset);  offset += 2;\n  \tobj.minRightSideBearing = bin.readShort(data, offset);  offset += 2;\n  \tobj.xMaxExtent = bin.readShort(data, offset);  offset += 2;\n  \t\n  \tobj.caretSlopeRise = bin.readShort(data, offset);  offset += 2;\n  \tobj.caretSlopeRun  = bin.readShort(data, offset);  offset += 2;\n  \tobj.caretOffset    = bin.readShort(data, offset);  offset += 2;\n  \t\n  \toffset += 4*2;\n  \t\n  \tobj.metricDataFormat = bin.readShort (data, offset);  offset += 2;\n  \tobj.numberOfHMetrics = bin.readUshort(data, offset);  offset += 2;\n  \treturn obj;\n  };\n\n\n  Typr.hmtx = {};\n  Typr.hmtx.parse = function(data, offset, length, font)\n  {\n  \tvar bin = Typr._bin;\n  \tvar obj = {};\n  \t\n  \tobj.aWidth = [];\n  \tobj.lsBearing = [];\n  \t\n  \t\n  \tvar aw = 0, lsb = 0;\n  \t\n  \tfor(var i=0; i<font.maxp.numGlyphs; i++)\n  \t{\n  \t\tif(i<font.hhea.numberOfHMetrics) {  aw=bin.readUshort(data, offset);  offset += 2;  lsb=bin.readShort(data, offset);  offset+=2;  }\n  \t\tobj.aWidth.push(aw);\n  \t\tobj.lsBearing.push(lsb);\n  \t}\n  \t\n  \treturn obj;\n  };\n\n\n  Typr.kern = {};\n  Typr.kern.parse = function(data, offset, length, font)\n  {\n  \tvar bin = Typr._bin;\n  \t\n  \tvar version = bin.readUshort(data, offset);  offset+=2;\n  \tif(version==1) { return Typr.kern.parseV1(data, offset-2, length, font); }\n  \tvar nTables = bin.readUshort(data, offset);  offset+=2;\n  \t\n  \tvar map = {glyph1: [], rval:[]};\n  \tfor(var i=0; i<nTables; i++)\n  \t{\n  \t\toffset+=2;\t// skip version\n  \t\tvar length  = bin.readUshort(data, offset);  offset+=2;\n  \t\tvar coverage = bin.readUshort(data, offset);  offset+=2;\n  \t\tvar format = coverage>>>8;\n  \t\t/* I have seen format 128 once, that\'s why I do */ format &= 0xf;\n  \t\tif(format==0) { offset = Typr.kern.readFormat0(data, offset, map); }\n  \t\telse { throw "unknown kern table format: "+format; }\n  \t}\n  \treturn map;\n  };\n\n  Typr.kern.parseV1 = function(data, offset, length, font)\n  {\n  \tvar bin = Typr._bin;\n  \t\n  \tvar version = bin.readFixed(data, offset);  offset+=4;\n  \tvar nTables = bin.readUint(data, offset);  offset+=4;\n  \t\n  \tvar map = {glyph1: [], rval:[]};\n  \tfor(var i=0; i<nTables; i++)\n  \t{\n  \t\tvar length = bin.readUint(data, offset);   offset+=4;\n  \t\tvar coverage = bin.readUshort(data, offset);  offset+=2;\n  \t\tvar tupleIndex = bin.readUshort(data, offset);  offset+=2;\n  \t\tvar format = coverage>>>8;\n  \t\t/* I have seen format 128 once, that\'s why I do */ format &= 0xf;\n  \t\tif(format==0) { offset = Typr.kern.readFormat0(data, offset, map); }\n  \t\telse { throw "unknown kern table format: "+format; }\n  \t}\n  \treturn map;\n  };\n\n  Typr.kern.readFormat0 = function(data, offset, map)\n  {\n  \tvar bin = Typr._bin;\n  \tvar pleft = -1;\n  \tvar nPairs        = bin.readUshort(data, offset);  offset+=2;\n  \tvar searchRange   = bin.readUshort(data, offset);  offset+=2;\n  \tvar entrySelector = bin.readUshort(data, offset);  offset+=2;\n  \tvar rangeShift    = bin.readUshort(data, offset);  offset+=2;\n  \tfor(var j=0; j<nPairs; j++)\n  \t{\n  \t\tvar left  = bin.readUshort(data, offset);  offset+=2;\n  \t\tvar right = bin.readUshort(data, offset);  offset+=2;\n  \t\tvar value = bin.readShort (data, offset);  offset+=2;\n  \t\tif(left!=pleft) { map.glyph1.push(left);  map.rval.push({ glyph2:[], vals:[] }); }\n  \t\tvar rval = map.rval[map.rval.length-1];\n  \t\trval.glyph2.push(right);   rval.vals.push(value);\n  \t\tpleft = left;\n  \t}\n  \treturn offset;\n  };\n\n\n\n  Typr.loca = {};\n  Typr.loca.parse = function(data, offset, length, font)\n  {\n  \tvar bin = Typr._bin;\n  \tvar obj = [];\n  \t\n  \tvar ver = font.head.indexToLocFormat;\n  \t//console.log("loca", ver, length, 4*font.maxp.numGlyphs);\n  \tvar len = font.maxp.numGlyphs+1;\n  \t\n  \tif(ver==0) { for(var i=0; i<len; i++) { obj.push(bin.readUshort(data, offset+(i<<1))<<1); } }\n  \tif(ver==1) { for(var i=0; i<len; i++) { obj.push(bin.readUint  (data, offset+(i<<2))   ); } }\n  \t\n  \treturn obj;\n  };\n\n\n  Typr.maxp = {};\n  Typr.maxp.parse = function(data, offset, length)\n  {\n  \t//console.log(data.length, offset, length);\n  \t\n  \tvar bin = Typr._bin;\n  \tvar obj = {};\n  \t\n  \t// both versions 0.5 and 1.0\n  \tvar ver = bin.readUint(data, offset); offset += 4;\n  \tobj.numGlyphs = bin.readUshort(data, offset);  offset += 2;\n  \t\n  \t// only 1.0\n  \tif(ver == 0x00010000)\n  \t{\n  \t\tobj.maxPoints             = bin.readUshort(data, offset);  offset += 2;\n  \t\tobj.maxContours           = bin.readUshort(data, offset);  offset += 2;\n  \t\tobj.maxCompositePoints    = bin.readUshort(data, offset);  offset += 2;\n  \t\tobj.maxCompositeContours  = bin.readUshort(data, offset);  offset += 2;\n  \t\tobj.maxZones              = bin.readUshort(data, offset);  offset += 2;\n  \t\tobj.maxTwilightPoints     = bin.readUshort(data, offset);  offset += 2;\n  \t\tobj.maxStorage            = bin.readUshort(data, offset);  offset += 2;\n  \t\tobj.maxFunctionDefs       = bin.readUshort(data, offset);  offset += 2;\n  \t\tobj.maxInstructionDefs    = bin.readUshort(data, offset);  offset += 2;\n  \t\tobj.maxStackElements      = bin.readUshort(data, offset);  offset += 2;\n  \t\tobj.maxSizeOfInstructions = bin.readUshort(data, offset);  offset += 2;\n  \t\tobj.maxComponentElements  = bin.readUshort(data, offset);  offset += 2;\n  \t\tobj.maxComponentDepth     = bin.readUshort(data, offset);  offset += 2;\n  \t}\n  \t\n  \treturn obj;\n  };\n\n\n  Typr.name = {};\n  Typr.name.parse = function(data, offset, length)\n  {\n  \tvar bin = Typr._bin;\n  \tvar obj = {};\n  \tvar format = bin.readUshort(data, offset);  offset += 2;\n  \tvar count  = bin.readUshort(data, offset);  offset += 2;\n  \tvar stringOffset = bin.readUshort(data, offset);  offset += 2;\n  \t\n  \t//console.log(format,count);\n  \t\n  \tvar names = [\n  \t\t"copyright",\n  \t\t"fontFamily",\n  \t\t"fontSubfamily",\n  \t\t"ID",\n  \t\t"fullName",\n  \t\t"version",\n  \t\t"postScriptName",\n  \t\t"trademark",\n  \t\t"manufacturer",\n  \t\t"designer",\n  \t\t"description",\n  \t\t"urlVendor",\n  \t\t"urlDesigner",\n  \t\t"licence",\n  \t\t"licenceURL",\n  \t\t"---",\n  \t\t"typoFamilyName",\n  \t\t"typoSubfamilyName",\n  \t\t"compatibleFull",\n  \t\t"sampleText",\n  \t\t"postScriptCID",\n  \t\t"wwsFamilyName",\n  \t\t"wwsSubfamilyName",\n  \t\t"lightPalette",\n  \t\t"darkPalette"\n  \t];\n  \t\n  \tvar offset0 = offset;\n  \t\n  \tfor(var i=0; i<count; i++)\n  \t{\n  \t\tvar platformID = bin.readUshort(data, offset);  offset += 2;\n  \t\tvar encodingID = bin.readUshort(data, offset);  offset += 2;\n  \t\tvar languageID = bin.readUshort(data, offset);  offset += 2;\n  \t\tvar nameID     = bin.readUshort(data, offset);  offset += 2;\n  \t\tvar slen       = bin.readUshort(data, offset);  offset += 2;\n  \t\tvar noffset    = bin.readUshort(data, offset);  offset += 2;\n  \t\t//console.log(platformID, encodingID, languageID.toString(16), nameID, length, noffset);\n  \t\t\n  \t\tvar cname = names[nameID];\n  \t\tvar soff = offset0 + count*12 + noffset;\n  \t\tvar str;\n  \t\tif(platformID == 0) { str = bin.readUnicode(data, soff, slen/2); }\n  \t\telse if(platformID == 3 && encodingID == 0) { str = bin.readUnicode(data, soff, slen/2); }\n  \t\telse if(encodingID == 0) { str = bin.readASCII  (data, soff, slen); }\n  \t\telse if(encodingID == 1) { str = bin.readUnicode(data, soff, slen/2); }\n  \t\telse if(encodingID == 3) { str = bin.readUnicode(data, soff, slen/2); }\n  \t\t\n  \t\telse if(platformID == 1) { str = bin.readASCII(data, soff, slen);  console.log("reading unknown MAC encoding "+encodingID+" as ASCII"); }\n  \t\telse { throw "unknown encoding "+encodingID + ", platformID: "+platformID; }\n  \t\t\n  \t\tvar tid = "p"+platformID+","+(languageID).toString(16);//Typr._platforms[platformID];\n  \t\tif(obj[tid]==null) { obj[tid] = {}; }\n  \t\tobj[tid][cname] = str;\n  \t\tobj[tid]._lang = languageID;\n  \t\t//console.log(tid, obj[tid]);\n  \t}\n  \t/*\n  \tif(format == 1)\n  \t{\n  \t\tvar langTagCount = bin.readUshort(data, offset);  offset += 2;\n  \t\tfor(var i=0; i<langTagCount; i++)\n  \t\t{\n  \t\t\tvar length  = bin.readUshort(data, offset);  offset += 2;\n  \t\t\tvar noffset = bin.readUshort(data, offset);  offset += 2;\n  \t\t}\n  \t}\n  \t*/\n  \t\n  \t//console.log(obj);\n  \t\n  \tfor(var p in obj) { if(obj[p].postScriptName!=null && obj[p]._lang==0x0409) { return obj[p]; } }\t\t// United States\n  \tfor(var p in obj) { if(obj[p].postScriptName!=null && obj[p]._lang==0x0000) { return obj[p]; } }\t\t// Universal\n  \tfor(var p in obj) { if(obj[p].postScriptName!=null && obj[p]._lang==0x0c0c) { return obj[p]; } }\t\t// Canada\n  \tfor(var p in obj) { if(obj[p].postScriptName!=null) { return obj[p]; } }\n  \t\n  \tvar tname;\n  \tfor(var p in obj) { tname=p; break; }\n  \tconsole.log("returning name table with languageID "+ obj[tname]._lang);\n  \treturn obj[tname];\n  };\n\n\n  Typr["OS/2"] = {};\n  Typr["OS/2"].parse = function(data, offset, length)\n  {\n  \tvar bin = Typr._bin;\n  \tvar ver = bin.readUshort(data, offset); offset += 2;\n  \t\n  \tvar obj = {};\n  \tif     (ver==0) { Typr["OS/2"].version0(data, offset, obj); }\n  \telse if(ver==1) { Typr["OS/2"].version1(data, offset, obj); }\n  \telse if(ver==2 || ver==3 || ver==4) { Typr["OS/2"].version2(data, offset, obj); }\n  \telse if(ver==5) { Typr["OS/2"].version5(data, offset, obj); }\n  \telse { throw "unknown OS/2 table version: "+ver; }\n  \t\n  \treturn obj;\n  };\n\n  Typr["OS/2"].version0 = function(data, offset, obj)\n  {\n  \tvar bin = Typr._bin;\n  \tobj.xAvgCharWidth = bin.readShort(data, offset); offset += 2;\n  \tobj.usWeightClass = bin.readUshort(data, offset); offset += 2;\n  \tobj.usWidthClass  = bin.readUshort(data, offset); offset += 2;\n  \tobj.fsType = bin.readUshort(data, offset); offset += 2;\n  \tobj.ySubscriptXSize = bin.readShort(data, offset); offset += 2;\n  \tobj.ySubscriptYSize = bin.readShort(data, offset); offset += 2;\n  \tobj.ySubscriptXOffset = bin.readShort(data, offset); offset += 2;\n  \tobj.ySubscriptYOffset = bin.readShort(data, offset); offset += 2; \n  \tobj.ySuperscriptXSize = bin.readShort(data, offset); offset += 2; \n  \tobj.ySuperscriptYSize = bin.readShort(data, offset); offset += 2; \n  \tobj.ySuperscriptXOffset = bin.readShort(data, offset); offset += 2;\n  \tobj.ySuperscriptYOffset = bin.readShort(data, offset); offset += 2;\n  \tobj.yStrikeoutSize = bin.readShort(data, offset); offset += 2;\n  \tobj.yStrikeoutPosition = bin.readShort(data, offset); offset += 2;\n  \tobj.sFamilyClass = bin.readShort(data, offset); offset += 2;\n  \tobj.panose = bin.readBytes(data, offset, 10);  offset += 10;\n  \tobj.ulUnicodeRange1\t= bin.readUint(data, offset);  offset += 4;\n  \tobj.ulUnicodeRange2\t= bin.readUint(data, offset);  offset += 4;\n  \tobj.ulUnicodeRange3\t= bin.readUint(data, offset);  offset += 4;\n  \tobj.ulUnicodeRange4\t= bin.readUint(data, offset);  offset += 4;\n  \tobj.achVendID = [bin.readInt8(data, offset), bin.readInt8(data, offset+1),bin.readInt8(data, offset+2),bin.readInt8(data, offset+3)];  offset += 4;\n  \tobj.fsSelection\t = bin.readUshort(data, offset); offset += 2;\n  \tobj.usFirstCharIndex = bin.readUshort(data, offset); offset += 2;\n  \tobj.usLastCharIndex = bin.readUshort(data, offset); offset += 2;\n  \tobj.sTypoAscender = bin.readShort(data, offset); offset += 2;\n  \tobj.sTypoDescender = bin.readShort(data, offset); offset += 2;\n  \tobj.sTypoLineGap = bin.readShort(data, offset); offset += 2;\n  \tobj.usWinAscent = bin.readUshort(data, offset); offset += 2;\n  \tobj.usWinDescent = bin.readUshort(data, offset); offset += 2;\n  \treturn offset;\n  };\n\n  Typr["OS/2"].version1 = function(data, offset, obj)\n  {\n  \tvar bin = Typr._bin;\n  \toffset = Typr["OS/2"].version0(data, offset, obj);\n  \t\n  \tobj.ulCodePageRange1 = bin.readUint(data, offset); offset += 4;\n  \tobj.ulCodePageRange2 = bin.readUint(data, offset); offset += 4;\n  \treturn offset;\n  };\n\n  Typr["OS/2"].version2 = function(data, offset, obj)\n  {\n  \tvar bin = Typr._bin;\n  \toffset = Typr["OS/2"].version1(data, offset, obj);\n  \t\n  \tobj.sxHeight = bin.readShort(data, offset); offset += 2;\n  \tobj.sCapHeight = bin.readShort(data, offset); offset += 2;\n  \tobj.usDefault = bin.readUshort(data, offset); offset += 2;\n  \tobj.usBreak = bin.readUshort(data, offset); offset += 2;\n  \tobj.usMaxContext = bin.readUshort(data, offset); offset += 2;\n  \treturn offset;\n  };\n\n  Typr["OS/2"].version5 = function(data, offset, obj)\n  {\n  \tvar bin = Typr._bin;\n  \toffset = Typr["OS/2"].version2(data, offset, obj);\n\n  \tobj.usLowerOpticalPointSize = bin.readUshort(data, offset); offset += 2;\n  \tobj.usUpperOpticalPointSize = bin.readUshort(data, offset); offset += 2;\n  \treturn offset;\n  };\n\n  Typr.post = {};\n  Typr.post.parse = function(data, offset, length)\n  {\n  \tvar bin = Typr._bin;\n  \tvar obj = {};\n  \t\n  \tobj.version           = bin.readFixed(data, offset);  offset+=4;\n  \tobj.italicAngle       = bin.readFixed(data, offset);  offset+=4;\n  \tobj.underlinePosition = bin.readShort(data, offset);  offset+=2;\n  \tobj.underlineThickness = bin.readShort(data, offset);  offset+=2;\n\n  \treturn obj;\n  };\n  Typr.SVG = {};\n  Typr.SVG.parse = function(data, offset, length)\n  {\n  \tvar bin = Typr._bin;\n  \tvar obj = { entries: []};\n\n  \tvar offset0 = offset;\n\n  \tvar tableVersion = bin.readUshort(data, offset);\toffset += 2;\n  \tvar svgDocIndexOffset = bin.readUint(data, offset);\toffset += 4;\n  \tvar reserved = bin.readUint(data, offset); offset += 4;\n\n  \toffset = svgDocIndexOffset + offset0;\n\n  \tvar numEntries = bin.readUshort(data, offset);\toffset += 2;\n\n  \tfor(var i=0; i<numEntries; i++)\n  \t{\n  \t\tvar startGlyphID = bin.readUshort(data, offset);  offset += 2;\n  \t\tvar endGlyphID   = bin.readUshort(data, offset);  offset += 2;\n  \t\tvar svgDocOffset = bin.readUint  (data, offset);  offset += 4;\n  \t\tvar svgDocLength = bin.readUint  (data, offset);  offset += 4;\n\n  \t\tvar sbuf = new Uint8Array(data.buffer, offset0 + svgDocOffset + svgDocIndexOffset, svgDocLength);\n  \t\tvar svg = bin.readUTF8(sbuf, 0, sbuf.length);\n  \t\t\n  \t\tfor(var f=startGlyphID; f<=endGlyphID; f++) {\n  \t\t\tobj.entries[f] = svg;\n  \t\t}\n  \t}\n  \treturn obj;\n  };\n\n  Typr.SVG.toPath = function(str)\n  {\n  \tvar pth = {cmds:[], crds:[]};\n  \tif(str==null) { return pth; }\n  \t\n  \tvar prsr = new DOMParser();\n  \tvar doc = prsr["parseFromString"](str,"image/svg+xml");\n  \t\n  \tvar svg = doc.firstChild;  while(svg.tagName!="svg") { svg = svg.nextSibling; }\n  \tvar vb = svg.getAttribute("viewBox");\n  \tif(vb) { vb = vb.trim().split(" ").map(parseFloat); }  else   { vb = [0,0,1000,1000]; }\n  \tTypr.SVG._toPath(svg.children, pth);\n  \tfor(var i=0; i<pth.crds.length; i+=2) {\n  \t\tvar x = pth.crds[i], y = pth.crds[i+1];\n  \t\tx -= vb[0];\n  \t\ty -= vb[1];\n  \t\ty = -y;\n  \t\tpth.crds[i] = x;\n  \t\tpth.crds[i+1] = y;\n  \t}\n  \treturn pth;\n  };\n\n  Typr.SVG._toPath = function(nds, pth, fill) {\n  \tfor(var ni=0; ni<nds.length; ni++) {\n  \t\tvar nd = nds[ni], tn = nd.tagName;\n  \t\tvar cfl = nd.getAttribute("fill");  if(cfl==null) { cfl = fill; }\n  \t\tif(tn=="g") { Typr.SVG._toPath(nd.children, pth, cfl); }\n  \t\telse if(tn=="path") {\n  \t\t\tpth.cmds.push(cfl?cfl:"#000000");\n  \t\t\tvar d = nd.getAttribute("d");  //console.log(d);\n  \t\t\tvar toks = Typr.SVG._tokens(d);  //console.log(toks);\n  \t\t\tTypr.SVG._toksToPath(toks, pth);  pth.cmds.push("X");\n  \t\t}\n  \t\telse if(tn=="defs") ;\n  \t\telse { console.log(tn, nd); }\n  \t}\n  };\n\n  Typr.SVG._tokens = function(d) {\n  \tvar ts = [], off = 0, rn=false, cn="";  // reading number, current number\n  \twhile(off<d.length){\n  \t\tvar cc=d.charCodeAt(off), ch = d.charAt(off);  off++;\n  \t\tvar isNum = (48<=cc && cc<=57) || ch=="." || ch=="-";\n  \t\t\n  \t\tif(rn) {\n  \t\t\tif(ch=="-") {  ts.push(parseFloat(cn));  cn=ch;  }\n  \t\t\telse if(isNum) { cn+=ch; }\n  \t\t\telse {  ts.push(parseFloat(cn));  if(ch!="," && ch!=" ") { ts.push(ch); }  rn=false;  }\n  \t\t}\n  \t\telse {\n  \t\t\tif(isNum) {  cn=ch;  rn=true;  }\n  \t\t\telse if(ch!="," && ch!=" ") { ts.push(ch); }\n  \t\t}\n  \t}\n  \tif(rn) { ts.push(parseFloat(cn)); }\n  \treturn ts;\n  };\n\n  Typr.SVG._toksToPath = function(ts, pth) {\t\n  \tvar i = 0, x = 0, y = 0, ox = 0, oy = 0;\n  \tvar pc = {"M":2,"L":2,"H":1,"V":1,   "S":4,   "C":6};\n  \tvar cmds = pth.cmds, crds = pth.crds;\n  \t\n  \twhile(i<ts.length) {\n  \t\tvar cmd = ts[i];  i++;\n  \t\t\n  \t\tif(cmd=="z") {  cmds.push("Z");  x=ox;  y=oy;  }\n  \t\telse {\n  \t\t\tvar cmu = cmd.toUpperCase();\n  \t\t\tvar ps = pc[cmu], reps = Typr.SVG._reps(ts, i, ps);\n  \t\t\n  \t\t\tfor(var j=0; j<reps; j++) {\n  \t\t\t\tvar xi = 0, yi = 0;   if(cmd!=cmu) {  xi=x;  yi=y;  }\n  \t\t\t\t\n  \t\t\t\tif(cmu=="M") {  x = xi+ts[i++];  y = yi+ts[i++];  cmds.push("M");  crds.push(x,y);  ox=x;  oy=y; }\n  \t\t\t\telse if(cmu=="L") {  x = xi+ts[i++];  y = yi+ts[i++];  cmds.push("L");  crds.push(x,y);  }\n  \t\t\t\telse if(cmu=="H") {  x = xi+ts[i++];                   cmds.push("L");  crds.push(x,y);  }\n  \t\t\t\telse if(cmu=="V") {  y = yi+ts[i++];                   cmds.push("L");  crds.push(x,y);  }\n  \t\t\t\telse if(cmu=="C") {\n  \t\t\t\t\tvar x1=xi+ts[i++], y1=yi+ts[i++], x2=xi+ts[i++], y2=yi+ts[i++], x3=xi+ts[i++], y3=yi+ts[i++];\n  \t\t\t\t\tcmds.push("C");  crds.push(x1,y1,x2,y2,x3,y3);  x=x3;  y=y3;\n  \t\t\t\t}\n  \t\t\t\telse if(cmu=="S") {\n  \t\t\t\t\tvar co = Math.max(crds.length-4, 0);\n  \t\t\t\t\tvar x1 = x+x-crds[co], y1 = y+y-crds[co+1];\n  \t\t\t\t\tvar x2=xi+ts[i++], y2=yi+ts[i++], x3=xi+ts[i++], y3=yi+ts[i++];  \n  \t\t\t\t\tcmds.push("C");  crds.push(x1,y1,x2,y2,x3,y3);  x=x3;  y=y3;\n  \t\t\t\t}\n  \t\t\t\telse { console.log("Unknown SVG command "+cmd); }\n  \t\t\t}\n  \t\t}\n  \t}\n  };\n  Typr.SVG._reps = function(ts, off, ps) {\n  \tvar i = off;\n  \twhile(i<ts.length) {  if((typeof ts[i]) == "string") { break; }  i+=ps;  }\n  \treturn (i-off)/ps;\n  };\n  // End Typr.js\n\n  // Begin Typr.U.js\n\n  if(Typr  ==null) { Typr   = {}; }\n  if(Typr.U==null) { Typr.U = {}; }\n\n\n  Typr.U.codeToGlyph = function(font, code)\n  {\n  \tvar cmap = font.cmap;\n  \t\n  \tvar tind = -1;\n  \tif(cmap.p0e4!=null) { tind = cmap.p0e4; }\n  \telse if(cmap.p3e1!=null) { tind = cmap.p3e1; }\n  \telse if(cmap.p1e0!=null) { tind = cmap.p1e0; }\n  \telse if(cmap.p0e3!=null) { tind = cmap.p0e3; }\n  \t\n  \tif(tind==-1) { throw "no familiar platform and encoding!"; }\n  \t\n  \tvar tab = cmap.tables[tind];\n  \t\n  \tif(tab.format==0)\n  \t{\n  \t\tif(code>=tab.map.length) { return 0; }\n  \t\treturn tab.map[code];\n  \t}\n  \telse if(tab.format==4)\n  \t{\n  \t\tvar sind = -1;\n  \t\tfor(var i=0; i<tab.endCount.length; i++)   { if(code<=tab.endCount[i]){  sind=i;  break;  } } \n  \t\tif(sind==-1) { return 0; }\n  \t\tif(tab.startCount[sind]>code) { return 0; }\n  \t\t\n  \t\tvar gli = 0;\n  \t\tif(tab.idRangeOffset[sind]!=0) { gli = tab.glyphIdArray[(code-tab.startCount[sind]) + (tab.idRangeOffset[sind]>>1) - (tab.idRangeOffset.length-sind)]; }\n  \t\telse                           { gli = code + tab.idDelta[sind]; }\n  \t\treturn gli & 0xFFFF;\n  \t}\n  \telse if(tab.format==12)\n  \t{\n  \t\tif(code>tab.groups[tab.groups.length-1][1]) { return 0; }\n  \t\tfor(var i=0; i<tab.groups.length; i++)\n  \t\t{\n  \t\t\tvar grp = tab.groups[i];\n  \t\t\tif(grp[0]<=code && code<=grp[1]) { return grp[2] + (code-grp[0]); }\n  \t\t}\n  \t\treturn 0;\n  \t}\n  \telse { throw "unknown cmap table format "+tab.format; }\n  };\n\n\n  Typr.U.glyphToPath = function(font, gid)\n  {\n  \tvar path = { cmds:[], crds:[] };\n  \tif(font.SVG && font.SVG.entries[gid]) {\n  \t\tvar p = font.SVG.entries[gid];  if(p==null) { return path; }\n  \t\tif(typeof p == "string") {  p = Typr.SVG.toPath(p);  font.SVG.entries[gid]=p;  }\n  \t\treturn p;\n  \t}\n  \telse if(font.CFF) {\n  \t\tvar state = {x:0,y:0,stack:[],nStems:0,haveWidth:false,width: font.CFF.Private ? font.CFF.Private.defaultWidthX : 0,open:false};\n  \t\tvar cff=font.CFF, pdct = font.CFF.Private;\n  \t\tif(cff.ROS) {\n  \t\t\tvar gi = 0;\n  \t\t\twhile(cff.FDSelect[gi+2]<=gid) { gi+=2; }\n  \t\t\tpdct = cff.FDArray[cff.FDSelect[gi+1]].Private;\n  \t\t}\n  \t\tTypr.U._drawCFF(font.CFF.CharStrings[gid], state, cff, pdct, path);\n  \t}\n  \telse if(font.glyf) {  Typr.U._drawGlyf(gid, font, path);  }\n  \treturn path;\n  };\n\n  Typr.U._drawGlyf = function(gid, font, path)\n  {\n  \tvar gl = font.glyf[gid];\n  \tif(gl==null) { gl = font.glyf[gid] = Typr.glyf._parseGlyf(font, gid); }\n  \tif(gl!=null){\n  \t\tif(gl.noc>-1) { Typr.U._simpleGlyph(gl, path); }\n  \t\telse          { Typr.U._compoGlyph (gl, font, path); }\n  \t}\n  };\n  Typr.U._simpleGlyph = function(gl, p)\n  {\n  \tfor(var c=0; c<gl.noc; c++)\n  \t{\n  \t\tvar i0 = (c==0) ? 0 : (gl.endPts[c-1] + 1);\n  \t\tvar il = gl.endPts[c];\n  \t\t\n  \t\tfor(var i=i0; i<=il; i++)\n  \t\t{\n  \t\t\tvar pr = (i==i0)?il:(i-1);\n  \t\t\tvar nx = (i==il)?i0:(i+1);\n  \t\t\tvar onCurve = gl.flags[i]&1;\n  \t\t\tvar prOnCurve = gl.flags[pr]&1;\n  \t\t\tvar nxOnCurve = gl.flags[nx]&1;\n  \t\t\t\n  \t\t\tvar x = gl.xs[i], y = gl.ys[i];\n  \t\t\t\n  \t\t\tif(i==i0) { \n  \t\t\t\tif(onCurve)  \n  \t\t\t\t{\n  \t\t\t\t\tif(prOnCurve) { Typr.U.P.moveTo(p, gl.xs[pr], gl.ys[pr]); } \n  \t\t\t\t\telse          {  Typr.U.P.moveTo(p,x,y);  continue;  /*  will do curveTo at il  */  }\n  \t\t\t\t}\n  \t\t\t\telse        \n  \t\t\t\t{\n  \t\t\t\t\tif(prOnCurve) { Typr.U.P.moveTo(p,  gl.xs[pr],       gl.ys[pr]        ); }\n  \t\t\t\t\telse          { Typr.U.P.moveTo(p, (gl.xs[pr]+x)/2, (gl.ys[pr]+y)/2   ); } \n  \t\t\t\t}\n  \t\t\t}\n  \t\t\tif(onCurve)\n  \t\t\t{\n  \t\t\t\tif(prOnCurve) { Typr.U.P.lineTo(p,x,y); }\n  \t\t\t}\n  \t\t\telse\n  \t\t\t{\n  \t\t\t\tif(nxOnCurve) { Typr.U.P.qcurveTo(p, x, y, gl.xs[nx], gl.ys[nx]); } \n  \t\t\t\telse          { Typr.U.P.qcurveTo(p, x, y, (x+gl.xs[nx])/2, (y+gl.ys[nx])/2); } \n  \t\t\t}\n  \t\t}\n  \t\tTypr.U.P.closePath(p);\n  \t}\n  };\n  Typr.U._compoGlyph = function(gl, font, p)\n  {\n  \tfor(var j=0; j<gl.parts.length; j++)\n  \t{\n  \t\tvar path = { cmds:[], crds:[] };\n  \t\tvar prt = gl.parts[j];\n  \t\tTypr.U._drawGlyf(prt.glyphIndex, font, path);\n  \t\t\n  \t\tvar m = prt.m;\n  \t\tfor(var i=0; i<path.crds.length; i+=2)\n  \t\t{\n  \t\t\tvar x = path.crds[i  ], y = path.crds[i+1];\n  \t\t\tp.crds.push(x*m.a + y*m.b + m.tx);\n  \t\t\tp.crds.push(x*m.c + y*m.d + m.ty);\n  \t\t}\n  \t\tfor(var i=0; i<path.cmds.length; i++) { p.cmds.push(path.cmds[i]); }\n  \t}\n  };\n\n\n  Typr.U._getGlyphClass = function(g, cd)\n  {\n  \tvar intr = Typr._lctf.getInterval(cd, g);\n  \treturn intr==-1 ? 0 : cd[intr+2];\n  \t//for(var i=0; i<cd.start.length; i++) \n  \t//\tif(cd.start[i]<=g && cd.end[i]>=g) return cd.class[i];\n  \t//return 0;\n  };\n\n  Typr.U.getPairAdjustment = function(font, g1, g2)\n  {\n  \t//return 0;\n  \tif(font.GPOS) {\n  \t\tvar gpos = font["GPOS"];\n  \t\tvar llist = gpos.lookupList, flist = gpos.featureList;\n  \t\tvar tused = [];\n  \t\tfor(var i=0; i<flist.length; i++) \n  \t\t{\n  \t\t\tvar fl = flist[i];  //console.log(fl);\n  \t\t\tif(fl.tag!="kern") { continue; }\n  \t\t\tfor(var ti=0; ti<fl.tab.length; ti++) {\n  \t\t\t\tif(tused[fl.tab[ti]]) { continue; }  tused[fl.tab[ti]] = true;\n  \t\t\t\tvar tab = llist[fl.tab[ti]];\n  \t\t\t\t//console.log(tab);\n  \t\t\t\t\n  \t\t\t\tfor(var j=0; j<tab.tabs.length; j++)\n  \t\t\t\t{\n  \t\t\t\t\tif(tab.tabs[i]==null) { continue; }\n  \t\t\t\t\tvar ltab = tab.tabs[j], ind;\n  \t\t\t\t\tif(ltab.coverage) {  ind = Typr._lctf.coverageIndex(ltab.coverage, g1);  if(ind==-1) { continue; }  }\n  \t\t\t\t\t\n  \t\t\t\t\tif(tab.ltype==1) ;\n  \t\t\t\t\telse if(tab.ltype==2)\n  \t\t\t\t\t{\n  \t\t\t\t\t\tvar adj;\n  \t\t\t\t\t\tif(ltab.fmt==1)\n  \t\t\t\t\t\t{\n  \t\t\t\t\t\t\tvar right = ltab.pairsets[ind];\n  \t\t\t\t\t\t\tfor(var i=0; i<right.length; i++) { if(right[i].gid2==g2) { adj = right[i]; } }\n  \t\t\t\t\t\t}\n  \t\t\t\t\t\telse if(ltab.fmt==2)\n  \t\t\t\t\t\t{\n  \t\t\t\t\t\t\tvar c1 = Typr.U._getGlyphClass(g1, ltab.classDef1);\n  \t\t\t\t\t\t\tvar c2 = Typr.U._getGlyphClass(g2, ltab.classDef2);\n  \t\t\t\t\t\t\tadj = ltab.matrix[c1][c2];\n  \t\t\t\t\t\t}\n  \t\t\t\t\t\t//if(adj) console.log(ltab, adj);\n  \t\t\t\t\t\tif(adj && adj.val2) { return adj.val2[2]; }\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t}\n  \tif(font.kern)\n  \t{\n  \t\tvar ind1 = font.kern.glyph1.indexOf(g1);\n  \t\tif(ind1!=-1)\n  \t\t{\n  \t\t\tvar ind2 = font.kern.rval[ind1].glyph2.indexOf(g2);\n  \t\t\tif(ind2!=-1) { return font.kern.rval[ind1].vals[ind2]; }\n  \t\t}\n  \t}\n  \t\n  \treturn 0;\n  };\n\n  Typr.U.stringToGlyphs = function(font, str)\n  {\n  \tvar gls = [];\n  \tfor(var i=0; i<str.length; i++) {\n  \t\tvar cc = str.codePointAt(i);  if(cc>0xffff) { i++; }\n  \t\tgls.push(Typr.U.codeToGlyph(font, cc));\n  \t}\n  \tfor(var i=0; i<str.length; i++) {\n  \t\tvar cc = str.codePointAt(i);  //\n  \t\tif(cc==2367) {  var t=gls[i-1];  gls[i-1]=gls[i];  gls[i]=t;  }\n  \t\t//if(cc==2381) {  var t=gls[i+1];  gls[i+1]=gls[i];  gls[i]=t;  }\n  \t\tif(cc>0xffff) { i++; }\n  \t}\n  \t//console.log(gls.slice(0));\n  \t\n  \t//console.log(gls);  return gls;\n  \t\n  \tvar gsub = font["GSUB"];  if(gsub==null) { return gls; }\n  \tvar llist = gsub.lookupList, flist = gsub.featureList;\n  \t\n  \tvar cligs = ["rlig", "liga", "mset",  "isol","init","fina","medi",   "half", "pres", \n  \t\t\t\t"blws" /* Tibetan fonts like Himalaya.ttf */ ];\n  \t\n  \t//console.log(gls.slice(0));\n  \tvar tused = [];\n  \tfor(var fi=0; fi<flist.length; fi++)\n  \t{\n  \t\tvar fl = flist[fi];  if(cligs.indexOf(fl.tag)==-1) { continue; }\n  \t\t//if(fl.tag=="blwf") continue;\n  \t\t//console.log(fl);\n  \t\t//console.log(fl.tag);\n  \t\tfor(var ti=0; ti<fl.tab.length; ti++) {\n  \t\t\tif(tused[fl.tab[ti]]) { continue; }  tused[fl.tab[ti]] = true;\n  \t\t\tvar tab = llist[fl.tab[ti]];\n  \t\t\t//console.log(fl.tab[ti], tab.ltype);\n  \t\t\t//console.log(fl.tag, tab);\n  \t\t\tfor(var ci=0; ci<gls.length; ci++) {\n  \t\t\t\tvar feat = Typr.U._getWPfeature(str, ci);\n  \t\t\t\tif("isol,init,fina,medi".indexOf(fl.tag)!=-1 && fl.tag!=feat) { continue; }\n  \t\t\t\t\n  \t\t\t\tTypr.U._applySubs(gls, ci, tab, llist);\n  \t\t\t}\n  \t\t}\n  \t}\n  \t\n  \treturn gls;\n  };\n  Typr.U._getWPfeature = function(str, ci) {  // get Word Position feature\n  \tvar wsep = "\\n\\t\\" ,.:;!?()  ،";\n  \tvar R = "آأؤإاةدذرزوٱٲٳٵٶٷڈډڊڋڌڍڎڏڐڑڒړڔڕږڗژڙۀۃۄۅۆۇۈۉۊۋۍۏےۓەۮۯܐܕܖܗܘܙܞܨܪܬܯݍݙݚݛݫݬݱݳݴݸݹࡀࡆࡇࡉࡔࡧࡩࡪࢪࢫࢬࢮࢱࢲࢹૅેૉ૊૎૏ૐ૑૒૝ૡ૤૯஁ஃ஄அஉ஌எஏ஑னப஫஬";\n  \tvar L = "ꡲ્૗";\n  \t\n  \tvar slft = ci==0            || wsep.indexOf(str[ci-1])!=-1;\n  \tvar srgt = ci==str.length-1 || wsep.indexOf(str[ci+1])!=-1;\n  \t\t\n  \tif(!slft && R.indexOf(str[ci-1])!=-1) { slft=true; }\n  \tif(!srgt && R.indexOf(str[ci  ])!=-1) { srgt=true; }\n  \t\t\n  \tif(!srgt && L.indexOf(str[ci+1])!=-1) { srgt=true; }\n  \tif(!slft && L.indexOf(str[ci  ])!=-1) { slft=true; }\n  \t\t\n  \tvar feat = null;\n  \tif(slft) { feat = srgt ? "isol" : "init"; }\n  \telse     { feat = srgt ? "fina" : "medi"; }\n  \t\n  \treturn feat;\n  };\n  Typr.U._applySubs = function(gls, ci, tab, llist) {\n  \tvar rlim = gls.length-ci-1;\n  \t//if(ci==0) console.log("++++ ", tab.ltype);\n  \tfor(var j=0; j<tab.tabs.length; j++)\n  \t{\n  \t\tif(tab.tabs[j]==null) { continue; }\n  \t\tvar ltab = tab.tabs[j], ind;\n  \t\tif(ltab.coverage) {  ind = Typr._lctf.coverageIndex(ltab.coverage, gls[ci]);  if(ind==-1) { continue; }  }\n  \t\t//if(ci==0) console.log(ind, ltab);\n  \t\t//*\n  \t\tif(tab.ltype==1) {\n  \t\t\tvar gl = gls[ci];\n  \t\t\tif(ltab.fmt==1) { gls[ci] = gls[ci]+ltab.delta; }\n  \t\t\telse            { gls[ci] = ltab.newg[ind]; }\n  \t\t\t//console.log("applying ... 1", ci, gl, gls[ci]);\n  \t\t}//*\n  \t\telse if(tab.ltype==4) {\n  \t\t\tvar vals = ltab.vals[ind];\n  \t\t\t\n  \t\t\tfor(var k=0; k<vals.length; k++) {\n  \t\t\t\tvar lig = vals[k], rl = lig.chain.length;  if(rl>rlim) { continue; }\n  \t\t\t\tvar good = true, em1 = 0;\n  \t\t\t\tfor(var l=0; l<rl; l++) {  while(gls[ci+em1+(1+l)]==-1){ em1++; }  if(lig.chain[l]!=gls[ci+em1+(1+l)]) { good=false; }  }\n  \t\t\t\tif(!good) { continue; }\n  \t\t\t\tgls[ci]=lig.nglyph;\n  \t\t\t\tfor(var l=0; l<rl+em1; l++) { gls[ci+l+1]=-1; }   break;  // first character changed, other ligatures do not apply anymore\n  \t\t\t\t//console.log("lig", ci, lig.chain, lig.nglyph);\n  \t\t\t\t//console.log("applying ...");\n  \t\t\t}\n  \t\t}\n  \t\telse  if(tab.ltype==5 && ltab.fmt==2) {\n  \t\t\tvar cind = Typr._lctf.getInterval(ltab.cDef, gls[ci]);\n  \t\t\tvar cls = ltab.cDef[cind+2], scs = ltab.scset[cls]; \n  \t\t\tfor(var i=0; i<scs.length; i++) {\n  \t\t\t\tvar sc = scs[i], inp = sc.input;\n  \t\t\t\tif(inp.length>rlim) { continue; }\n  \t\t\t\tvar good = true;\n  \t\t\t\tfor(var l=0; l<inp.length; l++) {\n  \t\t\t\t\tvar cind2 = Typr._lctf.getInterval(ltab.cDef, gls[ci+1+l]);\n  \t\t\t\t\tif(cind==-1 && ltab.cDef[cind2+2]!=inp[l]) {  good=false;  break;  }\n  \t\t\t\t}\n  \t\t\t\tif(!good) { continue; }\n  \t\t\t\t//console.log(ci, gl);\n  \t\t\t\tvar lrs = sc.substLookupRecords;\n  \t\t\t\tfor(var k=0; k<lrs.length; k+=2)\n  \t\t\t\t{\n  \t\t\t\t\tvar gi = lrs[k], tabi = lrs[k+1];\n  \t\t\t\t\t//Typr.U._applyType1(gls, ci+gi, llist[tabi]);\n  \t\t\t\t\t//console.log(tabi, gls[ci+gi], llist[tabi]);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\telse if(tab.ltype==6 && ltab.fmt==3) {\n  \t\t\t//if(ltab.backCvg.length==0) return;\n  \t\t\tif(!Typr.U._glsCovered(gls, ltab.backCvg, ci-ltab.backCvg.length)) { continue; }\n  \t\t\tif(!Typr.U._glsCovered(gls, ltab.inptCvg, ci)) { continue; }\n  \t\t\tif(!Typr.U._glsCovered(gls, ltab.ahedCvg, ci+ltab.inptCvg.length)) { continue; }\n  \t\t\t//console.log(ci, ltab);\n  \t\t\tvar lr = ltab.lookupRec;  //console.log(ci, gl, lr);\n  \t\t\tfor(var i=0; i<lr.length; i+=2) {\n  \t\t\t\tvar cind = lr[i], tab2 = llist[lr[i+1]];\n  \t\t\t\t//console.log("-", lr[i+1], tab2);\n  \t\t\t\tTypr.U._applySubs(gls, ci+cind, tab2, llist);\n  \t\t\t}\n  \t\t}\n  \t\t//else console.log("Unknown table", tab.ltype, ltab.fmt);\n  \t\t//*/\n  \t}\n  };\n\n  Typr.U._glsCovered = function(gls, cvgs, ci) {\n  \tfor(var i=0; i<cvgs.length; i++) {\n  \t\tvar ind = Typr._lctf.coverageIndex(cvgs[i], gls[ci+i]);  if(ind==-1) { return false; }\n  \t}\n  \treturn true;\n  };\n\n  Typr.U.glyphsToPath = function(font, gls, clr)\n  {\t\n  \t//gls = gls.reverse();//gls.slice(0,12).concat(gls.slice(12).reverse());\n  \t\n  \tvar tpath = {cmds:[], crds:[]};\n  \tvar x = 0;\n  \t\n  \tfor(var i=0; i<gls.length; i++)\n  \t{\n  \t\tvar gid = gls[i];  if(gid==-1) { continue; }\n  \t\tvar gid2 = (i<gls.length-1 && gls[i+1]!=-1)  ? gls[i+1] : 0;\n  \t\tvar path = Typr.U.glyphToPath(font, gid);\n  \t\tfor(var j=0; j<path.crds.length; j+=2)\n  \t\t{\n  \t\t\ttpath.crds.push(path.crds[j] + x);\n  \t\t\ttpath.crds.push(path.crds[j+1]);\n  \t\t}\n  \t\tif(clr) { tpath.cmds.push(clr); }\n  \t\tfor(var j=0; j<path.cmds.length; j++) { tpath.cmds.push(path.cmds[j]); }\n  \t\tif(clr) { tpath.cmds.push("X"); }\n  \t\tx += font.hmtx.aWidth[gid];// - font.hmtx.lsBearing[gid];\n  \t\tif(i<gls.length-1) { x += Typr.U.getPairAdjustment(font, gid, gid2); }\n  \t}\n  \treturn tpath;\n  };\n\n  Typr.U.pathToSVG = function(path, prec)\n  {\n  \tif(prec==null) { prec = 5; }\n  \tvar out = [], co = 0, lmap = {"M":2,"L":2,"Q":4,"C":6};\n  \tfor(var i=0; i<path.cmds.length; i++)\n  \t{\n  \t\tvar cmd = path.cmds[i], cn = co+(lmap[cmd]?lmap[cmd]:0);  \n  \t\tout.push(cmd);\n  \t\twhile(co<cn) {  var c = path.crds[co++];  out.push(parseFloat(c.toFixed(prec))+(co==cn?"":" "));  }\n  \t}\n  \treturn out.join("");\n  };\n\n  Typr.U.pathToContext = function(path, ctx)\n  {\n  \tvar c = 0, crds = path.crds;\n  \t\n  \tfor(var j=0; j<path.cmds.length; j++)\n  \t{\n  \t\tvar cmd = path.cmds[j];\n  \t\tif     (cmd=="M") {\n  \t\t\tctx.moveTo(crds[c], crds[c+1]);\n  \t\t\tc+=2;\n  \t\t}\n  \t\telse if(cmd=="L") {\n  \t\t\tctx.lineTo(crds[c], crds[c+1]);\n  \t\t\tc+=2;\n  \t\t}\n  \t\telse if(cmd=="C") {\n  \t\t\tctx.bezierCurveTo(crds[c], crds[c+1], crds[c+2], crds[c+3], crds[c+4], crds[c+5]);\n  \t\t\tc+=6;\n  \t\t}\n  \t\telse if(cmd=="Q") {\n  \t\t\tctx.quadraticCurveTo(crds[c], crds[c+1], crds[c+2], crds[c+3]);\n  \t\t\tc+=4;\n  \t\t}\n  \t\telse if(cmd.charAt(0)=="#") {\n  \t\t\tctx.beginPath();\n  \t\t\tctx.fillStyle = cmd;\n  \t\t}\n  \t\telse if(cmd=="Z") {\n  \t\t\tctx.closePath();\n  \t\t}\n  \t\telse if(cmd=="X") {\n  \t\t\tctx.fill();\n  \t\t}\n  \t}\n  };\n\n\n  Typr.U.P = {};\n  Typr.U.P.moveTo = function(p, x, y)\n  {\n  \tp.cmds.push("M");  p.crds.push(x,y);\n  };\n  Typr.U.P.lineTo = function(p, x, y)\n  {\n  \tp.cmds.push("L");  p.crds.push(x,y);\n  };\n  Typr.U.P.curveTo = function(p, a,b,c,d,e,f)\n  {\n  \tp.cmds.push("C");  p.crds.push(a,b,c,d,e,f);\n  };\n  Typr.U.P.qcurveTo = function(p, a,b,c,d)\n  {\n  \tp.cmds.push("Q");  p.crds.push(a,b,c,d);\n  };\n  Typr.U.P.closePath = function(p) {  p.cmds.push("Z");  };\n\n\n\n\n  Typr.U._drawCFF = function(cmds, state, font, pdct, p)\n  {\n  \tvar stack = state.stack;\n  \tvar nStems = state.nStems, haveWidth=state.haveWidth, width=state.width, open=state.open;\n  \tvar i=0;\n  \tvar x=state.x, y=state.y, c1x=0, c1y=0, c2x=0, c2y=0, c3x=0, c3y=0, c4x=0, c4y=0, jpx=0, jpy=0;\n  \t\n  \tvar o = {val:0,size:0};\n  \t//console.log(cmds);\n  \twhile(i<cmds.length)\n  \t{\n  \t\tTypr.CFF.getCharString(cmds, i, o);\n  \t\tvar v = o.val;\n  \t\ti += o.size;\n  \t\t\t\n  \t\tif(v=="o1" || v=="o18")  //  hstem || hstemhm\n  \t\t{\n  \t\t\tvar hasWidthArg;\n\n  \t\t\t// The number of stem operators on the stack is always even.\n  \t\t\t// If the value is uneven, that means a width is specified.\n  \t\t\thasWidthArg = stack.length % 2 !== 0;\n  \t\t\tif (hasWidthArg && !haveWidth) {\n  \t\t\t\twidth = stack.shift() + pdct.nominalWidthX;\n  \t\t\t}\n\n  \t\t\tnStems += stack.length >> 1;\n  \t\t\tstack.length = 0;\n  \t\t\thaveWidth = true;\n  \t\t}\n  \t\telse if(v=="o3" || v=="o23")  // vstem || vstemhm\n  \t\t{\n  \t\t\tvar hasWidthArg;\n\n  \t\t\t// The number of stem operators on the stack is always even.\n  \t\t\t// If the value is uneven, that means a width is specified.\n  \t\t\thasWidthArg = stack.length % 2 !== 0;\n  \t\t\tif (hasWidthArg && !haveWidth) {\n  \t\t\t\twidth = stack.shift() + pdct.nominalWidthX;\n  \t\t\t}\n\n  \t\t\tnStems += stack.length >> 1;\n  \t\t\tstack.length = 0;\n  \t\t\thaveWidth = true;\n  \t\t}\n  \t\telse if(v=="o4")\n  \t\t{\n  \t\t\tif (stack.length > 1 && !haveWidth) {\n                          width = stack.shift() + pdct.nominalWidthX;\n                          haveWidth = true;\n                      }\n  \t\t\tif(open) { Typr.U.P.closePath(p); }\n\n                      y += stack.pop();\n  \t\t\t\t\tTypr.U.P.moveTo(p,x,y);   open=true;\n  \t\t}\n  \t\telse if(v=="o5")\n  \t\t{\n  \t\t\twhile (stack.length > 0) {\n                          x += stack.shift();\n                          y += stack.shift();\n                          Typr.U.P.lineTo(p, x, y);\n                      }\n  \t\t}\n  \t\telse if(v=="o6" || v=="o7")  // hlineto || vlineto\n  \t\t{\n  \t\t\tvar count = stack.length;\n  \t\t\tvar isX = (v == "o6");\n  \t\t\t\n  \t\t\tfor(var j=0; j<count; j++) {\n  \t\t\t\tvar sval = stack.shift();\n  \t\t\t\t\n  \t\t\t\tif(isX) { x += sval; }  else  { y += sval; }\n  \t\t\t\tisX = !isX;\n  \t\t\t\tTypr.U.P.lineTo(p, x, y);\n  \t\t\t}\n  \t\t}\n  \t\telse if(v=="o8" || v=="o24")\t// rrcurveto || rcurveline\n  \t\t{\n  \t\t\tvar count = stack.length;\n  \t\t\tvar index = 0;\n  \t\t\twhile(index+6 <= count) {\n  \t\t\t\tc1x = x + stack.shift();\n  \t\t\t\tc1y = y + stack.shift();\n  \t\t\t\tc2x = c1x + stack.shift();\n  \t\t\t\tc2y = c1y + stack.shift();\n  \t\t\t\tx = c2x + stack.shift();\n  \t\t\t\ty = c2y + stack.shift();\n  \t\t\t\tTypr.U.P.curveTo(p, c1x, c1y, c2x, c2y, x, y);\n  \t\t\t\tindex+=6;\n  \t\t\t}\n  \t\t\tif(v=="o24")\n  \t\t\t{\n  \t\t\t\tx += stack.shift();\n  \t\t\t\ty += stack.shift();\n  \t\t\t\tTypr.U.P.lineTo(p, x, y);\n  \t\t\t}\n  \t\t}\n  \t\telse if(v=="o11")  { break; }\n  \t\telse if(v=="o1234" || v=="o1235" || v=="o1236" || v=="o1237")//if((v+"").slice(0,3)=="o12")\n  \t\t{\n  \t\t\tif(v=="o1234")\n  \t\t\t{\n  \t\t\t\tc1x = x   + stack.shift();    // dx1\n                  c1y = y;                      // dy1\n  \t\t\t\tc2x = c1x + stack.shift();    // dx2\n  \t\t\t\tc2y = c1y + stack.shift();    // dy2\n  \t\t\t\tjpx = c2x + stack.shift();    // dx3\n  \t\t\t\tjpy = c2y;                    // dy3\n  \t\t\t\tc3x = jpx + stack.shift();    // dx4\n  \t\t\t\tc3y = c2y;                    // dy4\n  \t\t\t\tc4x = c3x + stack.shift();    // dx5\n  \t\t\t\tc4y = y;                      // dy5\n  \t\t\t\tx = c4x + stack.shift();      // dx6\n  \t\t\t\tTypr.U.P.curveTo(p, c1x, c1y, c2x, c2y, jpx, jpy);\n  \t\t\t\tTypr.U.P.curveTo(p, c3x, c3y, c4x, c4y, x, y);\n  \t\t\t\t\n  \t\t\t}\n  \t\t\tif(v=="o1235")\n  \t\t\t{\n  \t\t\t\tc1x = x   + stack.shift();    // dx1\n  \t\t\t\tc1y = y   + stack.shift();    // dy1\n  \t\t\t\tc2x = c1x + stack.shift();    // dx2\n  \t\t\t\tc2y = c1y + stack.shift();    // dy2\n  \t\t\t\tjpx = c2x + stack.shift();    // dx3\n  \t\t\t\tjpy = c2y + stack.shift();    // dy3\n  \t\t\t\tc3x = jpx + stack.shift();    // dx4\n  \t\t\t\tc3y = jpy + stack.shift();    // dy4\n  \t\t\t\tc4x = c3x + stack.shift();    // dx5\n  \t\t\t\tc4y = c3y + stack.shift();    // dy5\n  \t\t\t\tx = c4x + stack.shift();      // dx6\n  \t\t\t\ty = c4y + stack.shift();      // dy6\n  \t\t\t\tstack.shift();                // flex depth\n  \t\t\t\tTypr.U.P.curveTo(p, c1x, c1y, c2x, c2y, jpx, jpy);\n  \t\t\t\tTypr.U.P.curveTo(p, c3x, c3y, c4x, c4y, x, y);\n  \t\t\t}\n  \t\t\tif(v=="o1236")\n  \t\t\t{\n  \t\t\t\tc1x = x   + stack.shift();    // dx1\n  \t\t\t\tc1y = y   + stack.shift();    // dy1\n  \t\t\t\tc2x = c1x + stack.shift();    // dx2\n  \t\t\t\tc2y = c1y + stack.shift();    // dy2\n  \t\t\t\tjpx = c2x + stack.shift();    // dx3\n  \t\t\t\tjpy = c2y;                    // dy3\n  \t\t\t\tc3x = jpx + stack.shift();    // dx4\n  \t\t\t\tc3y = c2y;                    // dy4\n  \t\t\t\tc4x = c3x + stack.shift();    // dx5\n  \t\t\t\tc4y = c3y + stack.shift();    // dy5\n  \t\t\t\tx = c4x + stack.shift();      // dx6\n  \t\t\t\tTypr.U.P.curveTo(p, c1x, c1y, c2x, c2y, jpx, jpy);\n  \t\t\t\tTypr.U.P.curveTo(p, c3x, c3y, c4x, c4y, x, y);\n  \t\t\t}\n  \t\t\tif(v=="o1237")\n  \t\t\t{\n  \t\t\t\tc1x = x   + stack.shift();    // dx1\n  \t\t\t\tc1y = y   + stack.shift();    // dy1\n  \t\t\t\tc2x = c1x + stack.shift();    // dx2\n  \t\t\t\tc2y = c1y + stack.shift();    // dy2\n  \t\t\t\tjpx = c2x + stack.shift();    // dx3\n  \t\t\t\tjpy = c2y + stack.shift();    // dy3\n  \t\t\t\tc3x = jpx + stack.shift();    // dx4\n  \t\t\t\tc3y = jpy + stack.shift();    // dy4\n  \t\t\t\tc4x = c3x + stack.shift();    // dx5\n  \t\t\t\tc4y = c3y + stack.shift();    // dy5\n  \t\t\t\tif (Math.abs(c4x - x) > Math.abs(c4y - y)) {\n  \t\t\t\t    x = c4x + stack.shift();\n  \t\t\t\t} else {\n  \t\t\t\t    y = c4y + stack.shift();\n  \t\t\t\t}\n  \t\t\t\tTypr.U.P.curveTo(p, c1x, c1y, c2x, c2y, jpx, jpy);\n  \t\t\t\tTypr.U.P.curveTo(p, c3x, c3y, c4x, c4y, x, y);\n  \t\t\t}\n  \t\t}\n  \t\telse if(v=="o14")\n  \t\t{\n  \t\t\tif (stack.length > 0 && !haveWidth) {\n                          width = stack.shift() + font.nominalWidthX;\n                          haveWidth = true;\n                      }\n  \t\t\tif(stack.length==4) // seac = standard encoding accented character\n  \t\t\t{\n  \t\t\t\tvar adx = stack.shift();\n  \t\t\t\tvar ady = stack.shift();\n  \t\t\t\tvar bchar = stack.shift();\n  \t\t\t\tvar achar = stack.shift();\n  \t\t\t\n  \t\t\t\t\n  \t\t\t\tvar bind = Typr.CFF.glyphBySE(font, bchar);\n  \t\t\t\tvar aind = Typr.CFF.glyphBySE(font, achar);\n  \t\t\t\t\n  \t\t\t\t//console.log(bchar, bind);\n  \t\t\t\t//console.log(achar, aind);\n  \t\t\t\t//state.x=x; state.y=y; state.nStems=nStems; state.haveWidth=haveWidth; state.width=width;  state.open=open;\n  \t\t\t\t\n  \t\t\t\tTypr.U._drawCFF(font.CharStrings[bind], state,font,pdct,p);\n  \t\t\t\tstate.x = adx; state.y = ady;\n  \t\t\t\tTypr.U._drawCFF(font.CharStrings[aind], state,font,pdct,p);\n  \t\t\t\t\n  \t\t\t\t//x=state.x; y=state.y; nStems=state.nStems; haveWidth=state.haveWidth; width=state.width;  open=state.open;\n  \t\t\t}\n  \t\t\tif(open) {  Typr.U.P.closePath(p);  open=false;  }\n  \t\t}\t\t\n  \t\telse if(v=="o19" || v=="o20") \n  \t\t{ \n  \t\t\tvar hasWidthArg;\n\n  \t\t\t// The number of stem operators on the stack is always even.\n  \t\t\t// If the value is uneven, that means a width is specified.\n  \t\t\thasWidthArg = stack.length % 2 !== 0;\n  \t\t\tif (hasWidthArg && !haveWidth) {\n  \t\t\t\twidth = stack.shift() + pdct.nominalWidthX;\n  \t\t\t}\n\n  \t\t\tnStems += stack.length >> 1;\n  \t\t\tstack.length = 0;\n  \t\t\thaveWidth = true;\n  \t\t\t\n  \t\t\ti += (nStems + 7) >> 3;\n  \t\t}\n  \t\t\n  \t\telse if(v=="o21") {\n  \t\t\tif (stack.length > 2 && !haveWidth) {\n                          width = stack.shift() + pdct.nominalWidthX;\n                          haveWidth = true;\n                      }\n\n                      y += stack.pop();\n                      x += stack.pop();\n  \t\t\t\t\t\n  \t\t\t\t\tif(open) { Typr.U.P.closePath(p); }\n                      Typr.U.P.moveTo(p,x,y);   open=true;\n  \t\t}\n  \t\telse if(v=="o22")\n  \t\t{\n  \t\t\t if (stack.length > 1 && !haveWidth) {\n                          width = stack.shift() + pdct.nominalWidthX;\n                          haveWidth = true;\n                      }\n  \t\t\t\t\t\n                      x += stack.pop();\n  \t\t\t\t\t\n  \t\t\t\t\tif(open) { Typr.U.P.closePath(p); }\n  \t\t\t\t\tTypr.U.P.moveTo(p,x,y);   open=true;                    \n  \t\t}\n  \t\telse if(v=="o25")\n  \t\t{\n  \t\t\twhile (stack.length > 6) {\n                          x += stack.shift();\n                          y += stack.shift();\n                          Typr.U.P.lineTo(p, x, y);\n                      }\n\n                      c1x = x + stack.shift();\n                      c1y = y + stack.shift();\n                      c2x = c1x + stack.shift();\n                      c2y = c1y + stack.shift();\n                      x = c2x + stack.shift();\n                      y = c2y + stack.shift();\n                      Typr.U.P.curveTo(p, c1x, c1y, c2x, c2y, x, y);\n  \t\t}\n  \t\telse if(v=="o26") \n  \t\t{\n  \t\t\tif (stack.length % 2) {\n                          x += stack.shift();\n                      }\n\n                      while (stack.length > 0) {\n                          c1x = x;\n                          c1y = y + stack.shift();\n                          c2x = c1x + stack.shift();\n                          c2y = c1y + stack.shift();\n                          x = c2x;\n                          y = c2y + stack.shift();\n                          Typr.U.P.curveTo(p, c1x, c1y, c2x, c2y, x, y);\n                      }\n\n  \t\t}\n  \t\telse if(v=="o27")\n  \t\t{\n  \t\t\tif (stack.length % 2) {\n                          y += stack.shift();\n                      }\n\n                      while (stack.length > 0) {\n                          c1x = x + stack.shift();\n                          c1y = y;\n                          c2x = c1x + stack.shift();\n                          c2y = c1y + stack.shift();\n                          x = c2x + stack.shift();\n                          y = c2y;\n                          Typr.U.P.curveTo(p, c1x, c1y, c2x, c2y, x, y);\n                      }\n  \t\t}\n  \t\telse if(v=="o10" || v=="o29")\t// callsubr || callgsubr\n  \t\t{\n  \t\t\tvar obj = (v=="o10" ? pdct : font);\n  \t\t\tif(stack.length==0) { console.log("error: empty stack");  }\n  \t\t\telse {\n  \t\t\t\tvar ind = stack.pop();\n  \t\t\t\tvar subr = obj.Subrs[ ind + obj.Bias ];\n  \t\t\t\tstate.x=x; state.y=y; state.nStems=nStems; state.haveWidth=haveWidth; state.width=width;  state.open=open;\n  \t\t\t\tTypr.U._drawCFF(subr, state,font,pdct,p);\n  \t\t\t\tx=state.x; y=state.y; nStems=state.nStems; haveWidth=state.haveWidth; width=state.width;  open=state.open;\n  \t\t\t}\n  \t\t}\n  \t\telse if(v=="o30" || v=="o31")   // vhcurveto || hvcurveto\n  \t\t{\n  \t\t\tvar count, count1 = stack.length;\n  \t\t\tvar index = 0;\n  \t\t\tvar alternate = v == "o31";\n  \t\t\t\n  \t\t\tcount  = count1 & ~2;\n  \t\t\tindex += count1 - count;\n  \t\t\t\n  \t\t\twhile ( index < count ) \n  \t\t\t{\n  \t\t\t\tif(alternate)\n  \t\t\t\t{\n  \t\t\t\t\tc1x = x + stack.shift();\n  \t\t\t\t\tc1y = y;\n  \t\t\t\t\tc2x = c1x + stack.shift();\n  \t\t\t\t\tc2y = c1y + stack.shift();\n  \t\t\t\t\ty = c2y + stack.shift();\n  \t\t\t\t\tif(count-index == 5) {  x = c2x + stack.shift();  index++;  }\n  \t\t\t\t\telse { x = c2x; }\n  \t\t\t\t\talternate = false;\n  \t\t\t\t}\n  \t\t\t\telse\n  \t\t\t\t{\n  \t\t\t\t\tc1x = x;\n  \t\t\t\t\tc1y = y + stack.shift();\n  \t\t\t\t\tc2x = c1x + stack.shift();\n  \t\t\t\t\tc2y = c1y + stack.shift();\n  \t\t\t\t\tx = c2x + stack.shift();\n  \t\t\t\t\tif(count-index == 5) {  y = c2y + stack.shift();  index++;  }\n  \t\t\t\t\telse { y = c2y; }\n  \t\t\t\t\talternate = true;\n  \t\t\t\t}\n                  Typr.U.P.curveTo(p, c1x, c1y, c2x, c2y, x, y);\n  \t\t\t\tindex += 4;\n  \t\t\t}\n  \t\t}\n  \t\t\n  \t\telse if((v+"").charAt(0)=="o") {   console.log("Unknown operation: "+v, cmds); throw v;  }\n  \t\telse { stack.push(v); }\n  \t}\n  \t//console.log(cmds);\n  \tstate.x=x; state.y=y; state.nStems=nStems; state.haveWidth=haveWidth; state.width=width; state.open=open;\n  };\n\n  // End Typr.U.js\n\n  return Typr\n\n  }\n\n  // Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with tiny-inflate \n  // (https://github.com/foliojs/tiny-inflate) for use in troika-3d-text. \n  // Original licenses apply: \n  // - tiny-inflate: https://github.com/foliojs/tiny-inflate/blob/master/LICENSE (MIT)\n  // - woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)\n\n  function woff2otfFactory() {\n\n  // Begin tinyInflate\n  var tinyInflate = (function() {\n    var module = {};\n    var TINF_OK = 0;\n  var TINF_DATA_ERROR = -3;\n\n  function Tree() {\n    this.table = new Uint16Array(16);   /* table of code length counts */\n    this.trans = new Uint16Array(288);  /* code -> symbol translation table */\n  }\n\n  function Data(source, dest) {\n    this.source = source;\n    this.sourceIndex = 0;\n    this.tag = 0;\n    this.bitcount = 0;\n    \n    this.dest = dest;\n    this.destLen = 0;\n    \n    this.ltree = new Tree();  /* dynamic length/symbol tree */\n    this.dtree = new Tree();  /* dynamic distance tree */\n  }\n\n  /* --------------------------------------------------- *\n   * -- uninitialized global data (static structures) -- *\n   * --------------------------------------------------- */\n\n  var sltree = new Tree();\n  var sdtree = new Tree();\n\n  /* extra bits and base tables for length codes */\n  var length_bits = new Uint8Array(30);\n  var length_base = new Uint16Array(30);\n\n  /* extra bits and base tables for distance codes */\n  var dist_bits = new Uint8Array(30);\n  var dist_base = new Uint16Array(30);\n\n  /* special ordering of code length codes */\n  var clcidx = new Uint8Array([\n    16, 17, 18, 0, 8, 7, 9, 6,\n    10, 5, 11, 4, 12, 3, 13, 2,\n    14, 1, 15\n  ]);\n\n  /* used by tinf_decode_trees, avoids allocations every call */\n  var code_tree = new Tree();\n  var lengths = new Uint8Array(288 + 32);\n\n  /* ----------------------- *\n   * -- utility functions -- *\n   * ----------------------- */\n\n  /* build extra bits and base tables */\n  function tinf_build_bits_base(bits, base, delta, first) {\n    var i, sum;\n\n    /* build bits table */\n    for (i = 0; i < delta; ++i) { bits[i] = 0; }\n    for (i = 0; i < 30 - delta; ++i) { bits[i + delta] = i / delta | 0; }\n\n    /* build base table */\n    for (sum = first, i = 0; i < 30; ++i) {\n      base[i] = sum;\n      sum += 1 << bits[i];\n    }\n  }\n\n  /* build the fixed huffman trees */\n  function tinf_build_fixed_trees(lt, dt) {\n    var i;\n\n    /* build fixed length tree */\n    for (i = 0; i < 7; ++i) { lt.table[i] = 0; }\n\n    lt.table[7] = 24;\n    lt.table[8] = 152;\n    lt.table[9] = 112;\n\n    for (i = 0; i < 24; ++i) { lt.trans[i] = 256 + i; }\n    for (i = 0; i < 144; ++i) { lt.trans[24 + i] = i; }\n    for (i = 0; i < 8; ++i) { lt.trans[24 + 144 + i] = 280 + i; }\n    for (i = 0; i < 112; ++i) { lt.trans[24 + 144 + 8 + i] = 144 + i; }\n\n    /* build fixed distance tree */\n    for (i = 0; i < 5; ++i) { dt.table[i] = 0; }\n\n    dt.table[5] = 32;\n\n    for (i = 0; i < 32; ++i) { dt.trans[i] = i; }\n  }\n\n  /* given an array of code lengths, build a tree */\n  var offs = new Uint16Array(16);\n\n  function tinf_build_tree(t, lengths, off, num) {\n    var i, sum;\n\n    /* clear code length count table */\n    for (i = 0; i < 16; ++i) { t.table[i] = 0; }\n\n    /* scan symbol lengths, and sum code length counts */\n    for (i = 0; i < num; ++i) { t.table[lengths[off + i]]++; }\n\n    t.table[0] = 0;\n\n    /* compute offset table for distribution sort */\n    for (sum = 0, i = 0; i < 16; ++i) {\n      offs[i] = sum;\n      sum += t.table[i];\n    }\n\n    /* create code->symbol translation table (symbols sorted by code) */\n    for (i = 0; i < num; ++i) {\n      if (lengths[off + i]) { t.trans[offs[lengths[off + i]]++] = i; }\n    }\n  }\n\n  /* ---------------------- *\n   * -- decode functions -- *\n   * ---------------------- */\n\n  /* get one bit from source stream */\n  function tinf_getbit(d) {\n    /* check if tag is empty */\n    if (!d.bitcount--) {\n      /* load next tag */\n      d.tag = d.source[d.sourceIndex++];\n      d.bitcount = 7;\n    }\n\n    /* shift bit out of tag */\n    var bit = d.tag & 1;\n    d.tag >>>= 1;\n\n    return bit;\n  }\n\n  /* read a num bit value from a stream and add base */\n  function tinf_read_bits(d, num, base) {\n    if (!num)\n      { return base; }\n\n    while (d.bitcount < 24) {\n      d.tag |= d.source[d.sourceIndex++] << d.bitcount;\n      d.bitcount += 8;\n    }\n\n    var val = d.tag & (0xffff >>> (16 - num));\n    d.tag >>>= num;\n    d.bitcount -= num;\n    return val + base;\n  }\n\n  /* given a data stream and a tree, decode a symbol */\n  function tinf_decode_symbol(d, t) {\n    while (d.bitcount < 24) {\n      d.tag |= d.source[d.sourceIndex++] << d.bitcount;\n      d.bitcount += 8;\n    }\n    \n    var sum = 0, cur = 0, len = 0;\n    var tag = d.tag;\n\n    /* get more bits while code value is above sum */\n    do {\n      cur = 2 * cur + (tag & 1);\n      tag >>>= 1;\n      ++len;\n\n      sum += t.table[len];\n      cur -= t.table[len];\n    } while (cur >= 0);\n    \n    d.tag = tag;\n    d.bitcount -= len;\n\n    return t.trans[sum + cur];\n  }\n\n  /* given a data stream, decode dynamic trees from it */\n  function tinf_decode_trees(d, lt, dt) {\n    var hlit, hdist, hclen;\n    var i, num, length;\n\n    /* get 5 bits HLIT (257-286) */\n    hlit = tinf_read_bits(d, 5, 257);\n\n    /* get 5 bits HDIST (1-32) */\n    hdist = tinf_read_bits(d, 5, 1);\n\n    /* get 4 bits HCLEN (4-19) */\n    hclen = tinf_read_bits(d, 4, 4);\n\n    for (i = 0; i < 19; ++i) { lengths[i] = 0; }\n\n    /* read code lengths for code length alphabet */\n    for (i = 0; i < hclen; ++i) {\n      /* get 3 bits code length (0-7) */\n      var clen = tinf_read_bits(d, 3, 0);\n      lengths[clcidx[i]] = clen;\n    }\n\n    /* build code length tree */\n    tinf_build_tree(code_tree, lengths, 0, 19);\n\n    /* decode code lengths for the dynamic trees */\n    for (num = 0; num < hlit + hdist;) {\n      var sym = tinf_decode_symbol(d, code_tree);\n\n      switch (sym) {\n        case 16:\n          /* copy previous code length 3-6 times (read 2 bits) */\n          var prev = lengths[num - 1];\n          for (length = tinf_read_bits(d, 2, 3); length; --length) {\n            lengths[num++] = prev;\n          }\n          break;\n        case 17:\n          /* repeat code length 0 for 3-10 times (read 3 bits) */\n          for (length = tinf_read_bits(d, 3, 3); length; --length) {\n            lengths[num++] = 0;\n          }\n          break;\n        case 18:\n          /* repeat code length 0 for 11-138 times (read 7 bits) */\n          for (length = tinf_read_bits(d, 7, 11); length; --length) {\n            lengths[num++] = 0;\n          }\n          break;\n        default:\n          /* values 0-15 represent the actual code lengths */\n          lengths[num++] = sym;\n          break;\n      }\n    }\n\n    /* build dynamic trees */\n    tinf_build_tree(lt, lengths, 0, hlit);\n    tinf_build_tree(dt, lengths, hlit, hdist);\n  }\n\n  /* ----------------------------- *\n   * -- block inflate functions -- *\n   * ----------------------------- */\n\n  /* given a stream and two trees, inflate a block of data */\n  function tinf_inflate_block_data(d, lt, dt) {\n    while (1) {\n      var sym = tinf_decode_symbol(d, lt);\n\n      /* check for end of block */\n      if (sym === 256) {\n        return TINF_OK;\n      }\n\n      if (sym < 256) {\n        d.dest[d.destLen++] = sym;\n      } else {\n        var length, dist, offs;\n        var i;\n\n        sym -= 257;\n\n        /* possibly get more bits from length code */\n        length = tinf_read_bits(d, length_bits[sym], length_base[sym]);\n\n        dist = tinf_decode_symbol(d, dt);\n\n        /* possibly get more bits from distance code */\n        offs = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);\n\n        /* copy match */\n        for (i = offs; i < offs + length; ++i) {\n          d.dest[d.destLen++] = d.dest[i];\n        }\n      }\n    }\n  }\n\n  /* inflate an uncompressed block of data */\n  function tinf_inflate_uncompressed_block(d) {\n    var length, invlength;\n    var i;\n    \n    /* unread from bitbuffer */\n    while (d.bitcount > 8) {\n      d.sourceIndex--;\n      d.bitcount -= 8;\n    }\n\n    /* get length */\n    length = d.source[d.sourceIndex + 1];\n    length = 256 * length + d.source[d.sourceIndex];\n\n    /* get one\'s complement of length */\n    invlength = d.source[d.sourceIndex + 3];\n    invlength = 256 * invlength + d.source[d.sourceIndex + 2];\n\n    /* check length */\n    if (length !== (~invlength & 0x0000ffff))\n      { return TINF_DATA_ERROR; }\n\n    d.sourceIndex += 4;\n\n    /* copy block */\n    for (i = length; i; --i)\n      { d.dest[d.destLen++] = d.source[d.sourceIndex++]; }\n\n    /* make sure we start next block on a byte boundary */\n    d.bitcount = 0;\n\n    return TINF_OK;\n  }\n\n  /* inflate stream from source to dest */\n  function tinf_uncompress(source, dest) {\n    var d = new Data(source, dest);\n    var bfinal, btype, res;\n\n    do {\n      /* read final block flag */\n      bfinal = tinf_getbit(d);\n\n      /* read block type (2 bits) */\n      btype = tinf_read_bits(d, 2, 0);\n\n      /* decompress block */\n      switch (btype) {\n        case 0:\n          /* decompress uncompressed block */\n          res = tinf_inflate_uncompressed_block(d);\n          break;\n        case 1:\n          /* decompress block with fixed huffman trees */\n          res = tinf_inflate_block_data(d, sltree, sdtree);\n          break;\n        case 2:\n          /* decompress block with dynamic huffman trees */\n          tinf_decode_trees(d, d.ltree, d.dtree);\n          res = tinf_inflate_block_data(d, d.ltree, d.dtree);\n          break;\n        default:\n          res = TINF_DATA_ERROR;\n      }\n\n      if (res !== TINF_OK)\n        { throw new Error(\'Data error\'); }\n\n    } while (!bfinal);\n\n    if (d.destLen < d.dest.length) {\n      if (typeof d.dest.slice === \'function\')\n        { return d.dest.slice(0, d.destLen); }\n      else\n        { return d.dest.subarray(0, d.destLen); }\n    }\n    \n    return d.dest;\n  }\n\n  /* -------------------- *\n   * -- initialization -- *\n   * -------------------- */\n\n  /* build fixed huffman trees */\n  tinf_build_fixed_trees(sltree, sdtree);\n\n  /* build extra bits and base tables */\n  tinf_build_bits_base(length_bits, length_base, 4, 3);\n  tinf_build_bits_base(dist_bits, dist_base, 2, 1);\n\n  /* fix a special case */\n  length_bits[28] = 0;\n  length_base[28] = 258;\n\n  module.exports = tinf_uncompress;\n\n    return module.exports\n  })();\n  // End tinyInflate\n\n  // Begin woff2otf.js\n  /*\n   Copyright 2012, Steffen Hanikel (https://github.com/hanikesn)\n   Modified by Artemy Tregubenko, 2014 (https://github.com/arty-name/woff2otf)\n   Modified by Jason Johnston, 2019 (pako --> tiny-inflate)\n   \n     Licensed under the Apache License, Version 2.0 (the "License");\n     you may not use this file except in compliance with the License.\n     You may obtain a copy of the License at\n\n         http://www.apache.org/licenses/LICENSE-2.0\n\n     Unless required by applicable law or agreed to in writing, software\n     distributed under the License is distributed on an "AS IS" BASIS,\n     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     See the License for the specific language governing permissions and\n     limitations under the License.\n\n   A tool to convert a WOFF back to a TTF/OTF font file, in pure Javascript\n  */\n\n  function convert_streams(bufferIn, tinyInflate) {\n      var dataViewIn = new DataView(bufferIn);\n      var offsetIn = 0;\n\n      function read2() {\n          var uint16 = dataViewIn.getUint16(offsetIn);\n          offsetIn += 2;\n          return uint16;\n      }\n\n      function read4() {\n          var uint32 = dataViewIn.getUint32(offsetIn);\n          offsetIn += 4;\n          return uint32;\n      }\n\n      function write2(uint16) {\n          dataViewOut.setUint16(offsetOut, uint16);\n          offsetOut += 2;\n      }\n\n      function write4(uint32) {\n          dataViewOut.setUint32(offsetOut, uint32);\n          offsetOut += 4;\n      }\n\n      var WOFFHeader = {\n          signature: read4(),\n          flavor: read4(),\n          length: read4(),\n          numTables: read2(),\n          reserved: read2(),\n          totalSfntSize: read4(),\n          majorVersion: read2(),\n          minorVersion: read2(),\n          metaOffset: read4(),\n          metaLength: read4(),\n          metaOrigLength: read4(),\n          privOffset: read4(),\n          privLength: read4()\n      };\n\n      var entrySelector = 0;\n      while (Math.pow(2, entrySelector) <= WOFFHeader.numTables) {\n          entrySelector++;\n      }\n      entrySelector--;\n\n      var searchRange = Math.pow(2, entrySelector) * 16;\n      var rangeShift = WOFFHeader.numTables * 16 - searchRange;\n\n      var offset = 4 + 2 + 2 + 2 + 2;\n      var TableDirectoryEntries = [];\n      for (var i = 0; i < WOFFHeader.numTables; i++) {\n          TableDirectoryEntries.push({\n              tag: read4(),\n              offset: read4(),\n              compLength: read4(),\n              origLength: read4(),\n              origChecksum: read4()\n          });\n          offset += 4 * 4;\n      }\n\n      var arrayOut = new Uint8Array(\n          4 + 2 + 2 + 2 + 2 +\n          TableDirectoryEntries.length * (4 + 4 + 4 + 4) +\n          TableDirectoryEntries.reduce(function(acc, entry) { return acc + entry.origLength + 4; }, 0)\n      );\n      var bufferOut = arrayOut.buffer;\n      var dataViewOut = new DataView(bufferOut);\n      var offsetOut = 0;\n\n      write4(WOFFHeader.flavor);\n      write2(WOFFHeader.numTables);\n      write2(searchRange);\n      write2(entrySelector);\n      write2(rangeShift);\n\n      TableDirectoryEntries.forEach(function(TableDirectoryEntry) {\n          write4(TableDirectoryEntry.tag);\n          write4(TableDirectoryEntry.origChecksum);\n          write4(offset);\n          write4(TableDirectoryEntry.origLength);\n\n          TableDirectoryEntry.outOffset = offset;\n          offset += TableDirectoryEntry.origLength;\n          if ((offset % 4) != 0) {\n              offset += 4 - (offset % 4);\n          }\n      });\n\n      var size;\n\n      TableDirectoryEntries.forEach(function(TableDirectoryEntry) {\n          var compressedData = bufferIn.slice(\n              TableDirectoryEntry.offset,\n              TableDirectoryEntry.offset + TableDirectoryEntry.compLength\n          );\n\n          if (TableDirectoryEntry.compLength != TableDirectoryEntry.origLength) {\n              var uncompressedData = new Uint8Array(TableDirectoryEntry.origLength);\n              tinyInflate(\n                new Uint8Array(compressedData, 2), //skip deflate header\n                uncompressedData\n              );\n          } else {\n              uncompressedData = new Uint8Array(compressedData);\n          }\n\n          arrayOut.set(uncompressedData, TableDirectoryEntry.outOffset);\n          offset = TableDirectoryEntry.outOffset + TableDirectoryEntry.origLength;\n\n          var padding = 0;\n          if ((offset % 4) != 0) {\n              padding = 4 - (offset % 4);\n          }\n          arrayOut.set(\n              new Uint8Array(padding).buffer,\n              TableDirectoryEntry.outOffset + TableDirectoryEntry.origLength\n          );\n\n          size = offset + padding;\n      });\n\n      return bufferOut.slice(0, size);\n  }\n\n  // End woff2otf.js\n\n  return function(buffer) {\n    return convert_streams(buffer, tinyInflate)\n  }\n\n  }\n\n  /**\n   * An adapter that allows Typr.js to be used as if it were (a subset of) the OpenType.js API.\n   * Also adds support for WOFF files (not WOFF2).\n   */\n\n  function parserFactory(Typr, woff2otf) {\n    var cmdArgLengths = {\n      M: 2,\n      L: 2,\n      Q: 4,\n      C: 6,\n      Z: 0\n    };\n\n    function wrapFontObj(typrFont) {\n      var glyphMap = Object.create(null);\n\n      var fontObj = {\n        unitsPerEm: typrFont.head.unitsPerEm,\n        ascender: typrFont.hhea.ascender,\n        descender: typrFont.hhea.descender,\n        forEachGlyph: function forEachGlyph(text, fontSize, letterSpacing, callback) {\n          var glyphX = 0;\n          var fontScale = 1 / fontObj.unitsPerEm * fontSize;\n\n          var glyphIndices = Typr.U.stringToGlyphs(typrFont, text);\n          var charIndex = 0;\n          glyphIndices.forEach(function (glyphIndex) {\n            // Typr returns a glyph index per string codepoint, with -1s in place of those that\n            // were omitted due to ligature substitution. So we can track original index in the\n            // string via simple increment, and skip everything else when seeing a -1.\n            if (glyphIndex !== -1) {\n              var glyphObj = glyphMap[glyphIndex];\n              if (!glyphObj) {\n                var ref = Typr.U.glyphToPath(typrFont, glyphIndex);\n                var cmds = ref.cmds;\n                var crds = ref.crds;\n\n                // Find extents - Glyf gives this in metadata but not CFF, and Typr doesn\'t\n                // normalize the two, so it\'s simplest just to iterate ourselves.\n                var xMin, yMin, xMax, yMax;\n                if (crds.length) {\n                  xMin = yMin = Infinity;\n                  xMax = yMax = -Infinity;\n                  for (var i = 0, len = crds.length; i < len; i += 2) {\n                    var x = crds[i];\n                    var y = crds[i + 1];\n                    if (x < xMin) { xMin = x; }\n                    if (y < yMin) { yMin = y; }\n                    if (x > xMax) { xMax = x; }\n                    if (y > yMax) { yMax = y; }\n                  }\n                } else {\n                  xMin = xMax = yMin = yMax = 0;\n                }\n\n                glyphObj = glyphMap[glyphIndex] = {\n                  index: glyphIndex,\n                  advanceWidth: typrFont.hmtx.aWidth[glyphIndex],\n                  xMin: xMin,\n                  yMin: yMin,\n                  xMax: xMax,\n                  yMax: yMax,\n                  pathCommandCount: cmds.length,\n                  forEachPathCommand: function forEachPathCommand(callback) {\n                    var argsIndex = 0;\n                    var argsArray = [];\n                    for (var i = 0, len = cmds.length; i < len; i++) {\n                      var numArgs = cmdArgLengths[cmds[i]];\n                      argsArray.length = 1 + numArgs;\n                      argsArray[0] = cmds[i];\n                      for (var j = 1; j <= numArgs; j++) {\n                        argsArray[j] = crds[argsIndex++];\n                      }\n                      callback.apply(null, argsArray);\n                    }\n                  }\n                };\n              }\n\n              callback.call(null, glyphObj, glyphX, charIndex);\n\n              if (glyphObj.advanceWidth) {\n                glyphX += glyphObj.advanceWidth * fontScale;\n              }\n              if (letterSpacing) {\n                glyphX += letterSpacing * fontSize;\n              }\n            }\n            charIndex += (text.codePointAt(charIndex) > 0xffff ? 2 : 1);\n          });\n          return glyphX\n        }\n      };\n\n      return fontObj\n    }\n\n    return function parse(buffer) {\n      // Look to see if we have a WOFF file and convert it if so:\n      var peek = new Uint8Array(buffer, 0, 4);\n      var tag = Typr._bin.readASCII(peek, 0, 4);\n      if (tag === \'wOFF\') {\n        buffer = woff2otf(buffer);\n      } else if (tag === \'wOF2\') {\n        throw new Error(\'woff2 fonts not supported\')\n      }\n      return wrapFontObj(Typr.parse(buffer)[0])\n    }\n  }\n\n\n  var workerModule = troikaWorkerUtils.defineWorkerModule({\n    name: \'Typr Font Parser\',\n    dependencies: [typrFactory, woff2otfFactory, parserFactory],\n    init: function init(typrFactory, woff2otfFactory, parserFactory) {\n      var Typr = typrFactory();\n      var woff2otf = woff2otfFactory();\n      return parserFactory(Typr, woff2otf)\n    }\n  });\n\n  //import fontParser from \'./FontParser_OpenType.js\'\n\n\n  var CONFIG = {\n    defaultFontURL: \'https://fonts.gstatic.com/s/roboto/v18/KFOmCnqEu92Fr1Mu4mxM.woff\', //Roboto Regular\n    sdfGlyphSize: 64,\n    textureWidth: 2048\n  };\n  var tempColor = new three.Color();\n\n  /**\n   * Customizes the text builder configuration. This must be called prior to the first font processing\n   * request, and applies to all fonts.\n   *\n   * @param {String} config.defaultFontURL - The URL of the default font to use for text processing\n   *                 requests, in case none is specified or the specifiede font fails to load or parse.\n   *                 Defaults to "Roboto Regular" from Google Fonts.\n   * @param {Number} config.sdfGlyphSize - The default size of each glyph\'s SDF (signed distance field)\n   *                 texture used for rendering. Must be a power-of-two number, and applies to all fonts,\n   *                 but note that this can also be overridden per call to `getTextRenderInfo()`.\n   *                 Larger sizes can improve the quality of glyph rendering by increasing the sharpness\n   *                 of corners and preventing loss of very thin lines, at the expense of memory. Defaults\n   *                 to 64 which is generally a good balance of size and quality.\n   * @param {Number} config.textureWidth - The width of the SDF texture; must be a power of 2. Defaults to\n   *                 2048 which is a safe maximum texture dimension according to the stats at\n   *                 https://webglstats.com/webgl/parameter/MAX_TEXTURE_SIZE and should allow for a\n   *                 reasonably large number of glyphs (default glyph size of 64 and safe texture size of\n   *                 2048^2 allows for 1024 glyphs.) This can be increased if you need to increase the\n   *                 glyph size and/or have an extraordinary number of glyphs.\n   */\n  function configureTextBuilder(config) {\n    {\n      assign(CONFIG, config);\n    }\n  }\n\n\n  /**\n   * The radial distance from glyph edges over which the SDF alpha will be calculated; if the alpha\n   * at distance:0 is 0.5, then the alpha at this distance will be zero. This is defined as a percentage\n   * of each glyph\'s maximum dimension in font space units so that it maps to the same minimum number of\n   * SDF texels regardless of the glyph\'s size. A larger value provides greater alpha gradient resolution\n   * and improves readability/antialiasing quality at small display sizes, but also decreases the number\n   * of texels available for encoding path details.\n   */\n  var SDF_DISTANCE_PERCENT = 1 / 8;\n\n\n  /**\n   * Repository for all font SDF atlas textures\n   *\n   *   {\n   *     [font]: {\n   *       sdfTexture: DataTexture\n   *     }\n   *   }\n   */\n  var atlases = Object.create(null);\n\n  /**\n   * @typedef {object} TroikaTextRenderInfo - Format of the result from `getTextRenderInfo`.\n   * @property {object} parameters - The normalized input arguments to the render call.\n   * @property {DataTexture} sdfTexture - The SDF atlas texture.\n   * @property {number} sdfGlyphSize - The size of each glyph\'s SDF.\n   * @property {number} sdfMinDistancePercent - See `SDF_DISTANCE_PERCENT`\n   * @property {Float32Array} glyphBounds - List of [minX, minY, maxX, maxY] quad bounds for each glyph.\n   * @property {Float32Array} glyphAtlasIndices - List holding each glyph\'s index in the SDF atlas.\n   * @property {Uint8Array} [glyphColors] - List holding each glyph\'s [r, g, b] color, if `colorRanges` was supplied.\n   * @property {Float32Array} [caretPositions] - A list of caret positions for all glyphs; this is\n   *           the bottom [x,y] of the cursor position before each char, plus one after the last char.\n   * @property {number} [caretHeight] - An appropriate height for all selection carets.\n   * @property {number} ascender - The font\'s ascender metric.\n   * @property {number} descender - The font\'s descender metric.\n   * @property {number} lineHeight - The final computed lineHeight measurement.\n   * @property {number} topBaseline - The y position of the top line\'s baseline.\n   * @property {Array<number>} totalBounds - The total [minX, minY, maxX, maxY] rect including all glyph\n   *           quad bounds; this will be slightly larger than the actual glyph path edges due to SDF padding.\n   * @property {Array<number>} totalBlockSize - The [width, height] of the text block; this does not include\n   *           extra SDF padding so it is accurate to use for measurement.\n   * @property {Array<number>} chunkedBounds - List of bounding rects for each consecutive set of N glyphs,\n   *           in the format `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`.\n   * @property {object} timings - Timing info for various parts of the rendering logic including SDF\n   *           generation, layout, etc.\n   * @frozen\n   */\n\n  /**\n   * @callback getTextRenderInfo~callback\n   * @param {TroikaTextRenderInfo} textRenderInfo\n   */\n\n  /**\n   * Main entry point for requesting the data needed to render a text string with given font parameters.\n   * This is an asynchronous call, performing most of the logic in a web worker thread.\n   * @param {object} args\n   * @param {getTextRenderInfo~callback} callback\n   */\n  function getTextRenderInfo(args, callback) {\n    args = assign({}, args);\n\n    // Apply default font here to avoid a \'null\' atlas, and convert relative\n    // URLs to absolute so they can be resolved in the worker\n    args.font = toAbsoluteURL(args.font || CONFIG.defaultFontURL);\n\n    // Normalize text to a string\n    args.text = \'\' + args.text;\n\n    args.sdfGlyphSize = args.sdfGlyphSize || CONFIG.sdfGlyphSize;\n\n    // Normalize colors\n    if (args.colorRanges != null) {\n      var colors = {};\n      for (var key in args.colorRanges) {\n        if (args.colorRanges.hasOwnProperty(key)) {\n          var val = args.colorRanges[key];\n          if (typeof val !== \'number\') {\n            val = tempColor.set(val).getHex();\n          }\n          colors[key] = val;\n        }\n      }\n      args.colorRanges = colors;\n    }\n\n    Object.freeze(args);\n\n    // Init the atlas for this font if needed\n    var textureWidth = CONFIG.textureWidth;\n    var sdfGlyphSize = args.sdfGlyphSize;\n    var atlasKey = (args.font) + "@" + sdfGlyphSize;\n    var atlas = atlases[atlasKey];\n    if (!atlas) {\n      atlas = atlases[atlasKey] = {\n        sdfTexture: new three.DataTexture(\n          new Uint8Array(sdfGlyphSize * textureWidth),\n          textureWidth,\n          sdfGlyphSize,\n          three.LuminanceFormat,\n          undefined,\n          undefined,\n          undefined,\n          undefined,\n          three.LinearFilter,\n          three.LinearFilter\n        )\n      };\n      atlas.sdfTexture.font = args.font;\n    }\n\n    // Issue request to the FontProcessor in the worker\n    processInWorker(args).then(function (result) {\n      // If the response has newGlyphs, copy them into the atlas texture at the specified indices\n      if (result.newGlyphSDFs) {\n        result.newGlyphSDFs.forEach(function (ref) {\n          var textureData = ref.textureData;\n          var atlasIndex = ref.atlasIndex;\n\n          var texImg = atlas.sdfTexture.image;\n\n          // Grow the texture by power of 2 if needed\n          while (texImg.data.length < (atlasIndex + 1) * sdfGlyphSize * sdfGlyphSize) {\n            var biggerArray = new Uint8Array(texImg.data.length * 2);\n            biggerArray.set(texImg.data);\n            texImg.data = biggerArray;\n            texImg.height *= 2;\n          }\n\n          // Insert the new glyph\'s data into the full texture image at the correct offsets\n          var cols = texImg.width / sdfGlyphSize;\n          for (var y = 0; y < sdfGlyphSize; y++) {\n            var srcStartIndex = y * sdfGlyphSize;\n            var tgtStartIndex = texImg.width * sdfGlyphSize * Math.floor(atlasIndex / cols) //full rows\n              + (atlasIndex % cols) * sdfGlyphSize //partial row\n              + (y * texImg.width); //row within glyph\n            for (var x = 0; x < sdfGlyphSize; x++) {\n              texImg.data[tgtStartIndex + x] = textureData[srcStartIndex + x];\n            }\n          }\n        });\n        atlas.sdfTexture.needsUpdate = true;\n      }\n\n      // Invoke callback with the text layout arrays and updated texture\n      callback(Object.freeze({\n        parameters: args,\n        sdfTexture: atlas.sdfTexture,\n        sdfGlyphSize: sdfGlyphSize,\n        sdfMinDistancePercent: SDF_DISTANCE_PERCENT,\n        glyphBounds: result.glyphBounds,\n        glyphAtlasIndices: result.glyphAtlasIndices,\n        glyphColors: result.glyphColors,\n        caretPositions: result.caretPositions,\n        caretHeight: result.caretHeight,\n        chunkedBounds: result.chunkedBounds,\n        ascender: result.ascender,\n        descender: result.descender,\n        lineHeight: result.lineHeight,\n        topBaseline: result.topBaseline,\n        totalBounds: result.totalBounds,\n        totalBlockSize: result.totalBlockSize,\n        timings: result.timings\n      }));\n    });\n  }\n\n\n  /**\n   * Preload a given font and optionally pre-generate glyph SDFs for one or more character sequences.\n   * This can be useful to avoid long pauses when first showing text in a scene, by preloading the\n   * needed fonts and glyphs up front along with other assets.\n   *\n   * @param {object} options\n   * @param {string} options.font - URL of the font file to preload. If not given, the default font will\n   *        be loaded.\n   * @param {string|string[]} options.characters - One or more character sequences for which to pre-\n   *        generate glyph SDFs. Note that this will honor ligature substitution, so you may need\n   *        to specify ligature sequences in addition to their individual characters to get all\n   *        possible glyphs, e.g. `["t", "h", "th"]` to get the "t" and "h" glyphs plus the "th" ligature.\n   * @param {number} options.sdfGlyphSize - The size at which to prerender the SDF textures for the\n   *        specified `characters`.\n   * @param {function} callback - A function that will be called when the preloading is complete.\n   */\n  function preloadFont(ref, callback) {\n    var font = ref.font;\n    var characters = ref.characters;\n    var sdfGlyphSize = ref.sdfGlyphSize;\n\n    var text = Array.isArray(characters) ? characters.join(\'\\n\') : \'\' + characters;\n    getTextRenderInfo({ font: font, sdfGlyphSize: sdfGlyphSize, text: text }, callback);\n  }\n\n\n  // Local assign impl so we don\'t have to import troika-core\n  function assign(toObj, fromObj) {\n    for (var key in fromObj) {\n      if (fromObj.hasOwnProperty(key)) {\n        toObj[key] = fromObj[key];\n      }\n    }\n    return toObj\n  }\n\n  // Utility for making URLs absolute\n  var linkEl;\n  function toAbsoluteURL(path) {\n    if (!linkEl) {\n      linkEl = typeof document === \'undefined\' ? {} : document.createElement(\'a\');\n    }\n    linkEl.href = path;\n    return linkEl.href\n  }\n\n\n  var fontProcessorWorkerModule = troikaWorkerUtils.defineWorkerModule({\n    name: \'FontProcessor\',\n    dependencies: [\n      CONFIG,\n      SDF_DISTANCE_PERCENT,\n      workerModule,\n      createGlyphSegmentsQuadtree,\n      createSDFGenerator,\n      createFontProcessor\n    ],\n    init: function init(config, sdfDistancePercent, fontParser, createGlyphSegmentsQuadtree, createSDFGenerator, createFontProcessor) {\n      var sdfGenerator = createSDFGenerator(\n        createGlyphSegmentsQuadtree,\n        {\n          sdfDistancePercent: sdfDistancePercent\n        }\n      );\n      return createFontProcessor(fontParser, sdfGenerator, {\n        defaultFontUrl: config.defaultFontURL\n      })\n    }\n  });\n\n  var processInWorker = troikaWorkerUtils.defineWorkerModule({\n    name: \'TextBuilder\',\n    dependencies: [fontProcessorWorkerModule, troikaWorkerUtils.ThenableWorkerModule],\n    init: function init(fontProcessor, Thenable) {\n      return function(args) {\n        var thenable = new Thenable();\n        fontProcessor.process(args, thenable.resolve);\n        return thenable\n      }\n    },\n    getTransferables: function getTransferables(result) {\n      // Mark array buffers as transferable to avoid cloning during postMessage\n      var transferables = [\n        result.glyphBounds.buffer,\n        result.glyphAtlasIndices.buffer\n      ];\n      if (result.caretPositions) {\n        transferables.push(result.caretPositions.buffer);\n      }\n      if (result.newGlyphSDFs) {\n        result.newGlyphSDFs.forEach(function (d) {\n          transferables.push(d.textureData.buffer);\n        });\n      }\n      return transferables\n    }\n  });\n\n  var templateGeometries = {};\n  function getTemplateGeometry(detail) {\n    var geom = templateGeometries[detail];\n    if (!geom) {\n      geom = templateGeometries[detail] = new three.PlaneBufferGeometry(1, 1, detail, detail).translate(0.5, 0.5, 0);\n    }\n    return geom\n  }\n  var tempVec3 = new three.Vector3();\n\n  var glyphBoundsAttrName = \'aTroikaGlyphBounds\';\n  var glyphIndexAttrName = \'aTroikaGlyphIndex\';\n  var glyphColorAttrName = \'aTroikaGlyphColor\';\n\n\n\n  /**\n  @class GlyphsGeometry\n\n  A specialized Geometry for rendering a set of text glyphs. Uses InstancedBufferGeometry to\n  render the glyphs using GPU instancing of a single quad, rather than constructing a whole\n  geometry with vertices, for much smaller attribute arraybuffers according to this math:\n\n    Where N = number of glyphs...\n\n    Instanced:\n    - position: 4 * 3\n    - index: 2 * 3\n    - normal: 4 * 3\n    - uv: 4 * 2\n    - glyph x/y bounds: N * 4\n    - glyph indices: N * 1\n    = 5N + 38\n\n    Non-instanced:\n    - position: N * 4 * 3\n    - index: N * 2 * 3\n    - normal: N * 4 * 3\n    - uv: N * 4 * 2\n    - glyph indices: N * 1\n    = 39N\n\n  A downside of this is the rare-but-possible lack of the instanced arrays extension,\n  which we could potentially work around with a fallback non-instanced implementation.\n\n  */\n  var GlyphsGeometry = /*@__PURE__*/(function (InstancedBufferGeometry) {\n    function GlyphsGeometry() {\n      InstancedBufferGeometry.call(this);\n\n      this.detail = 1;\n\n      // Preallocate zero-radius bounding sphere\n      this.boundingSphere = new three.Sphere();\n    }\n\n    if ( InstancedBufferGeometry ) GlyphsGeometry.__proto__ = InstancedBufferGeometry;\n    GlyphsGeometry.prototype = Object.create( InstancedBufferGeometry && InstancedBufferGeometry.prototype );\n    GlyphsGeometry.prototype.constructor = GlyphsGeometry;\n\n    var prototypeAccessors = { detail: { configurable: true } };\n\n    GlyphsGeometry.prototype.computeBoundingSphere = function computeBoundingSphere () {\n      // No-op; we\'ll sync the boundingSphere proactively in `updateGlyphs`.\n    };\n\n    prototypeAccessors.detail.set = function (detail) {\n      var this$1 = this;\n\n      if (detail !== this._detail) {\n        this._detail = detail;\n        if (typeof detail !== \'number\' || detail < 1) {\n          detail = 1;\n        }\n        var tpl = getTemplateGeometry(detail)\n        ;[\'position\', \'normal\', \'uv\'].forEach(function (attr) {\n          this$1.attributes[attr] = tpl.attributes[attr].clone();\n        });\n        this.setIndex(tpl.getIndex().clone());\n      }\n    };\n    prototypeAccessors.detail.get = function () {\n      return this._detail\n    };\n\n    /**\n     * Update the geometry for a new set of glyphs.\n     * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs\n     *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1\n     * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within\n     *        the SDF atlas texture.\n     * @param {Array} totalBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs\n     * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N\n     *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be\n     *        used with `applyClipRect` to choose an optimized `instanceCount`.\n     * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.\n     */\n    GlyphsGeometry.prototype.updateGlyphs = function updateGlyphs (glyphBounds, glyphAtlasIndices, totalBounds, chunkedBounds, glyphColors) {\n      // Update the instance attributes\n      updateBufferAttr(this, glyphBoundsAttrName, glyphBounds, 4);\n      updateBufferAttr(this, glyphIndexAttrName, glyphAtlasIndices, 1);\n      updateBufferAttr(this, glyphColorAttrName, glyphColors, 3);\n      this._chunkedBounds = chunkedBounds;\n      setInstanceCount(this, glyphAtlasIndices.length);\n\n      // Update the boundingSphere based on the total bounds\n      var sphere = this.boundingSphere;\n      sphere.center.set(\n        (totalBounds[0] + totalBounds[2]) / 2,\n        (totalBounds[1] + totalBounds[3]) / 2,\n        0\n      );\n      sphere.radius = sphere.center.distanceTo(tempVec3.set(totalBounds[0], totalBounds[1], 0));\n    };\n\n    /**\n     * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest\n     * `instanceCount` that will show all glyphs within the clipped view. This is an optimization\n     * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would\n     * be clipped anyway.\n     *\n     * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting\n     * offset, this optimization becomes less effective as the clipRect moves closer to the end of the\n     * text block. We could fix that by switching from instancing to a full geometry with a drawRange,\n     * but at the expense of much larger attribute buffers (see classdoc above.)\n     *\n     * @param {Vector4} clipRect\n     */\n    GlyphsGeometry.prototype.applyClipRect = function applyClipRect (clipRect) {\n      var count = this.getAttribute(glyphIndexAttrName).count;\n      var chunks = this._chunkedBounds;\n      if (chunks) {\n        for (var i = chunks.length; i--;) {\n          count = chunks[i].end;\n          var rect = chunks[i].rect;\n          // note: both rects are l-b-r-t\n          if (rect[1] < clipRect.w && rect[3] > clipRect.y && rect[0] < clipRect.z && rect[2] > clipRect.x) {\n            break\n          }\n        }\n      }\n      setInstanceCount(this, count);\n    };\n\n    Object.defineProperties( GlyphsGeometry.prototype, prototypeAccessors );\n\n    return GlyphsGeometry;\n  }(three.InstancedBufferGeometry));\n\n  // Compat for pre r109:\n  if (!GlyphsGeometry.prototype.setAttribute) {\n    GlyphsGeometry.prototype.setAttribute = function(name, attribute) {\n      this.attributes[ name ] = attribute;\n      return this\n    };\n  }\n\n\n  function updateBufferAttr(geom, attrName, newArray, itemSize) {\n    var attr = geom.getAttribute(attrName);\n    if (newArray) {\n      // If length isn\'t changing, just update the attribute\'s array data\n      if (attr && attr.array.length === newArray.length) {\n        attr.array.set(newArray);\n        attr.needsUpdate = true;\n      } else {\n        geom.setAttribute(attrName, new three.InstancedBufferAttribute(newArray, itemSize));\n        // If the new attribute has a different size, we also have to (as of r117) manually clear the\n        // internal cached max instance count. See https://github.com/mrdoob/three.js/issues/19706\n        // It\'s unclear if this is a threejs bug or a truly unsupported scenario; discussion in\n        // that ticket is ambiguous as to whether replacing a BufferAttribute with one of a\n        // different size is supported, but https://github.com/mrdoob/three.js/pull/17418 strongly\n        // implies it should be supported. It\'s possible we need to\n        delete geom._maxInstanceCount; //for r117+, could be fragile\n        geom.dispose(); //for r118+, more robust feeling, but more heavy-handed than I\'d like\n      }\n    } else if (attr) {\n      geom.deleteAttribute(attrName);\n    }\n  }\n\n  // Handle maxInstancedCount -> instanceCount rename that happened in three r117\n  function setInstanceCount(geom, count) {\n    geom[geom.hasOwnProperty(\'instanceCount\') ? \'instanceCount\' : \'maxInstancedCount\'] = count;\n  }\n\n  // language=GLSL\n  var VERTEX_DEFS = "\\nuniform vec2 uTroikaSDFTextureSize;\\nuniform float uTroikaSDFGlyphSize;\\nuniform vec4 uTroikaTotalBounds;\\nuniform vec4 uTroikaClipRect;\\nuniform mat3 uTroikaOrient;\\nuniform bool uTroikaUseGlyphColors;\\nattribute vec4 aTroikaGlyphBounds;\\nattribute float aTroikaGlyphIndex;\\nattribute vec3 aTroikaGlyphColor;\\nvarying vec2 vTroikaSDFTextureUV;\\nvarying vec2 vTroikaGlyphUV;\\nvarying vec3 vTroikaGlyphColor;\\n";\n\n  // language=GLSL prefix="void main() {" suffix="}"\n  var VERTEX_TRANSFORM = "\\nvec4 bounds = aTroikaGlyphBounds;\\nvec4 clippedBounds = vec4(\\n  clamp(bounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),\\n  clamp(bounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)\\n);\\nvec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);\\nvTroikaGlyphUV = clippedXY.xy;\\n\\nfloat cols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;\\nvTroikaSDFTextureUV = vec2(\\n  mod(aTroikaGlyphIndex, cols) + clippedXY.x,\\n  floor(aTroikaGlyphIndex / cols) + clippedXY.y\\n) * uTroikaSDFGlyphSize / uTroikaSDFTextureSize;\\n\\nposition.xy = mix(bounds.xy, bounds.zw, clippedXY);\\n\\nuv = vec2(\\n  (position.x - uTroikaTotalBounds.x) / (uTroikaTotalBounds.z - uTroikaTotalBounds.x),\\n  (position.y - uTroikaTotalBounds.y) / (uTroikaTotalBounds.w - uTroikaTotalBounds.y)\\n);\\n\\nposition = uTroikaOrient * position;\\nnormal = uTroikaOrient * normal;\\n";\n\n  // language=GLSL\n  var FRAGMENT_DEFS = "\\nuniform sampler2D uTroikaSDFTexture;\\nuniform float uTroikaSDFMinDistancePct;\\nuniform bool uTroikaSDFDebug;\\nvarying vec2 vTroikaSDFTextureUV;\\nvarying vec2 vTroikaGlyphUV;\\n\\nfloat troikaGetTextAlpha() {\\n  float troikaSDFValue = texture2D(uTroikaSDFTexture, vTroikaSDFTextureUV).r;\\n  \\n  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)\\n  float alpha = step(0.5, troikaSDFValue);\\n  #else\\n  " + (\'\') + "\\n  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300\\n  float aaDist = min(\\n    0.5,\\n    0.5 * min(\\n      fwidth(vTroikaGlyphUV.x),\\n      fwidth(vTroikaGlyphUV.y)\\n    )\\n  ) / uTroikaSDFMinDistancePct;\\n  #else\\n  float aaDist = 0.01;\\n  #endif\\n  \\n  float alpha = uTroikaSDFDebug ? troikaSDFValue : smoothstep(\\n    0.5 - aaDist,\\n    0.5 + aaDist,\\n    troikaSDFValue\\n  );\\n  #endif\\n  \\n  return alpha;\\n}\\n";\n\n  // language=GLSL prefix="void main() {" suffix="}"\n  var FRAGMENT_TRANSFORM = "\\nfloat troikaAlphaMult = troikaGetTextAlpha();\\nif (troikaAlphaMult == 0.0) {\\n  discard;\\n} else {\\n  gl_FragColor.a *= troikaAlphaMult;\\n}\\n";\n\n\n  /**\n   * Create a material for rendering text, derived from a baseMaterial\n   */\n  function createTextDerivedMaterial(baseMaterial) {\n    var textMaterial = troikaThreeUtils.createDerivedMaterial(baseMaterial, {\n      extensions: {derivatives: true},\n      uniforms: {\n        uTroikaSDFTexture: {value: null},\n        uTroikaSDFTextureSize: {value: new three.Vector2()},\n        uTroikaSDFGlyphSize: {value: 0},\n        uTroikaSDFMinDistancePct: {value: 0},\n        uTroikaTotalBounds: {value: new three.Vector4(0,0,0,0)},\n        uTroikaClipRect: {value: new three.Vector4(0,0,0,0)},\n        uTroikaOrient: {value: new three.Matrix3()},\n        uTroikaUseGlyphColors: {value: true},\n        uTroikaSDFDebug: {value: false}\n      },\n      vertexDefs: VERTEX_DEFS,\n      vertexTransform: VERTEX_TRANSFORM,\n      fragmentDefs: FRAGMENT_DEFS,\n      fragmentColorTransform: FRAGMENT_TRANSFORM,\n      customRewriter: function customRewriter(ref) {\n        var vertexShader = ref.vertexShader;\n        var fragmentShader = ref.fragmentShader;\n\n        var uDiffuseRE = /\\buniform\\s+vec3\\s+diffuse\\b/;\n        if (uDiffuseRE.test(fragmentShader)) {\n          // Replace all instances of `diffuse` with our varying\n          fragmentShader = fragmentShader\n            .replace(uDiffuseRE, \'varying vec3 vTroikaGlyphColor\')\n            .replace(/\\bdiffuse\\b/g, \'vTroikaGlyphColor\');\n          // Make sure the vertex shader declares the uniform so we can grab it as a fallback\n          if (!uDiffuseRE.test(vertexShader)) {\n            vertexShader = vertexShader.replace(\n              troikaThreeUtils.voidMainRegExp,\n              \'uniform vec3 diffuse;\\n$&\\nvTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;\\n\'\n            );\n          }\n        }\n        return { vertexShader: vertexShader, fragmentShader: fragmentShader }\n      }\n    });\n\n    // Force transparency - TODO is this reasonable?\n    textMaterial.transparent = true;\n\n    Object.defineProperties(textMaterial, {\n      isTroikaTextMaterial: {value: true},\n\n      // WebGLShadowMap reverses the side of the shadow material by default, which fails\n      // for planes, so here we force the `shadowSide` to always match the main side.\n      shadowSide: {\n        get: function get() {\n          return this.side\n        },\n        set: function set() {\n          //no-op\n        }\n      }\n    });\n\n    return textMaterial\n  }\n\n  var defaultMaterial = new three.MeshBasicMaterial({\n    color: 0xffffff,\n    side: three.DoubleSide,\n    transparent: true\n  });\n\n  var tempMat4 = new three.Matrix4();\n  var tempVec3a = new three.Vector3();\n  var tempVec3b = new three.Vector3();\n  var tempArray = [];\n  var origin = new three.Vector3();\n  var defaultOrient = \'+x+y\';\n\n  var raycastMesh = new three.Mesh(\n    new three.PlaneBufferGeometry(1, 1).translate(0.5, 0.5, 0),\n    defaultMaterial\n  );\n\n  var syncStartEvent = {type: \'syncstart\'};\n  var syncCompleteEvent = {type: \'synccomplete\'};\n\n  var SYNCABLE_PROPS = [\n    \'font\',\n    \'fontSize\',\n    \'letterSpacing\',\n    \'lineHeight\',\n    \'maxWidth\',\n    \'overflowWrap\',\n    \'text\',\n    \'textAlign\',\n    \'textIndent\',\n    \'whiteSpace\',\n    \'anchorX\',\n    \'anchorY\',\n    \'colorRanges\',\n    \'sdfGlyphSize\'\n  ];\n\n  var COPYABLE_PROPS = SYNCABLE_PROPS.concat(\n    \'material\',\n    \'color\',\n    \'depthOffset\',\n    \'clipRect\',\n    \'orientation\',\n    \'glyphGeometryDetail\'\n  );\n\n\n\n  /**\n   * @class Text\n   *\n   * A ThreeJS Mesh that renders a string of text on a plane in 3D space using signed distance\n   * fields (SDF).\n   */\n  var Text = /*@__PURE__*/(function (Mesh) {\n    function Text() {\n      var geometry = new GlyphsGeometry();\n      Mesh.call(this, geometry, null);\n\n      // === Text layout properties: === //\n\n      /**\n       * @member {string} text\n       * The string of text to be rendered.\n       */\n      this.text = \'\';\n\n      /**\n       * @deprecated Use `anchorX` and `anchorY` instead\n       * @member {Array<number>} anchor\n       * Defines where in the text block should correspond to the mesh\'s local position, as a set\n       * of horizontal and vertical percentages from 0 to 1. A value of `[0, 0]` (the default)\n       * anchors at the top-left, `[1, 1]` at the bottom-right, and `[0.5, 0.5]` centers the\n       * block at the mesh\'s position.\n       */\n      //this.anchor = null\n\n      /**\n       * @member {number|string} anchorX\n       * Defines the horizontal position in the text block that should line up with the local origin.\n       * Can be specified as a numeric x position in local units, a string percentage of the total\n       * text block width e.g. `\'25%\'`, or one of the following keyword strings: \'left\', \'center\',\n       * or \'right\'.\n       */\n      this.anchorX = 0;\n\n      /**\n       * @member {number|string} anchorX\n       * Defines the vertical position in the text block that should line up with the local origin.\n       * Can be specified as a numeric y position in local units (note: down is negative y), a string\n       * percentage of the total text block height e.g. `\'25%\'`, or one of the following keyword strings:\n       * \'top\', \'top-baseline\', \'middle\', \'bottom-baseline\', or \'bottom\'.\n       */\n      this.anchorY = 0;\n\n      /**\n       * @member {string} font\n       * URL of a custom font to be used. Font files can be any of the formats supported by\n       * OpenType (see https://github.com/opentypejs/opentype.js).\n       * Defaults to the Roboto font loaded from Google Fonts.\n       */\n      this.font = null; //will use default from TextBuilder\n\n      /**\n       * @member {number} fontSize\n       * The size at which to render the font in local units; corresponds to the em-box height\n       * of the chosen `font`.\n       */\n      this.fontSize = 0.1;\n\n      /**\n       * @member {number} letterSpacing\n       * Sets a uniform adjustment to spacing between letters after kerning is applied. Positive\n       * numbers increase spacing and negative numbers decrease it.\n       */\n      this.letterSpacing = 0;\n\n      /**\n       * @member {number|string} lineHeight\n       * Sets the height of each line of text, as a multiple of the `fontSize`. Defaults to \'normal\'\n       * which chooses a reasonable height based on the chosen font\'s ascender/descender metrics.\n       */\n      this.lineHeight = \'normal\';\n\n      /**\n       * @member {number} maxWidth\n       * The maximum width of the text block, above which text may start wrapping according to the\n       * `whiteSpace` and `overflowWrap` properties.\n       */\n      this.maxWidth = Infinity;\n\n      /**\n       * @member {string} overflowWrap\n       * Defines how text wraps if the `whiteSpace` property is `normal`. Can be either `\'normal\'`\n       * to break at whitespace characters, or `\'break-word\'` to allow breaking within words.\n       * Defaults to `\'normal\'`.\n       */\n      this.overflowWrap = \'normal\';\n\n      /**\n       * @member {string} textAlign\n       * The horizontal alignment of each line of text within the overall text bounding box.\n       */\n      this.textAlign = \'left\';\n\n      /**\n       * @member {number} textIndent\n       * Indentation for the first character of a line; see CSS `text-indent`.\n       */\n      this.textIndent = 0;\n\n      /**\n       * @member {string} whiteSpace\n       * Defines whether text should wrap when a line reaches the `maxWidth`. Can\n       * be either `\'normal\'` (the default), to allow wrapping according to the `overflowWrap` property,\n       * or `\'nowrap\'` to prevent wrapping. Note that `\'normal\'` here honors newline characters to\n       * manually break lines, making it behave more like `\'pre-wrap\'` does in CSS.\n       */\n      this.whiteSpace = \'normal\';\n\n\n      // === Presentation properties: === //\n\n      /**\n       * @member {THREE.Material} material\n       * Defines a _base_ material to be used when rendering the text. This material will be\n       * automatically replaced with a material derived from it, that adds shader code to\n       * decrease the alpha for each fragment (pixel) outside the text glyphs, with antialiasing.\n       * By default it will derive from a simple white MeshBasicMaterial, but you can use any\n       * of the other mesh materials to gain other features like lighting, texture maps, etc.\n       *\n       * Also see the `color` shortcut property.\n       */\n      this.material = null;\n\n      /**\n       * @member {string|number|THREE.Color} color\n       * This is a shortcut for setting the `color` of the text\'s material. You can use this\n       * if you don\'t want to specify a whole custom `material`.\n       */\n      this.color = null;\n\n      /**\n       * @member {object|null} colorRanges\n       * WARNING: This API is experimental and may change.\n       * This allows more fine-grained control of colors for individual or ranges of characters,\n       * taking precedence over the material\'s `color`. Its format is an Object whose keys each\n       * define a starting character index for a range, and whose values are the color for each\n       * range. The color value can be a numeric hex color value, a `THREE.Color` object, or\n       * any of the strings accepted by `THREE.Color`.\n       */\n      this.colorRanges = null;\n\n      /**\n       * @member {number} depthOffset\n       * This is a shortcut for setting the material\'s `polygonOffset` and related properties,\n       * which can be useful in preventing z-fighting when this text is laid on top of another\n       * plane in the scene. Positive numbers are further from the camera, negatives closer.\n       */\n      this.depthOffset = 0;\n\n      /**\n       * @member {Array<number>} clipRect\n       * If specified, defines a `[minX, minY, maxX, maxY]` of a rectangle outside of which all\n       * pixels will be discarded. This can be used for example to clip overflowing text when\n       * `whiteSpace=\'nowrap\'`.\n       */\n      this.clipRect = null;\n\n      /**\n       * @member {string} orientation\n       * Defines the axis plane on which the text should be laid out when the mesh has no extra\n       * rotation transform. It is specified as a string with two axes: the horizontal axis with\n       * positive pointing right, and the vertical axis with positive pointing up. By default this\n       * is \'+x+y\', meaning the text sits on the xy plane with the text\'s top toward positive y\n       * and facing positive z. A value of \'+x-z\' would place it on the xz plane with the text\'s\n       * top toward negative z and facing positive y.\n       */\n      this.orientation = defaultOrient;\n\n      /**\n       * @member {number} glyphGeometryDetail\n       * Controls number of vertical/horizontal segments that make up each glyph\'s rectangular\n       * plane. Defaults to 1. This can be increased to provide more geometrical detail for custom\n       * vertex shader effects, for example.\n       */\n      this.glyphGeometryDetail = 1;\n\n      /**\n       * @member {number|null} sdfGlyphSize\n       * The size of each glyph\'s SDF (signed distance field) used for rendering. This must be a\n       * power-of-two number. Defaults to 64 which is generally a good balance of size and quality\n       * for most fonts. Larger sizes can improve the quality of glyph rendering by increasing\n       * the sharpness of corners and preventing loss of very thin lines, at the expense of\n       * increased memory footprint and longer SDF generation time.\n       */\n      this.sdfGlyphSize = null;\n\n      this.debugSDF = false;\n    }\n\n    if ( Mesh ) Text.__proto__ = Mesh;\n    Text.prototype = Object.create( Mesh && Mesh.prototype );\n    Text.prototype.constructor = Text;\n\n    var prototypeAccessors = { textRenderInfo: { configurable: true },material: { configurable: true },glyphGeometryDetail: { configurable: true },customDepthMaterial: { configurable: true },customDistanceMaterial: { configurable: true } };\n\n    /**\n     * Updates the text rendering according to the current text-related configuration properties.\n     * This is an async process, so you can pass in a callback function to be executed when it\n     * finishes.\n     * @param {function} [callback]\n     */\n    Text.prototype.sync = function sync (callback) {\n      var this$1 = this;\n\n      if (this._needsSync) {\n        this._needsSync = false;\n\n        // If there\'s another sync still in progress, queue\n        if (this._isSyncing) {\n          (this._queuedSyncs || (this._queuedSyncs = [])).push(callback);\n        } else {\n          this._isSyncing = true;\n          this.dispatchEvent(syncStartEvent);\n\n          getTextRenderInfo({\n            text: this.text,\n            font: this.font,\n            fontSize: this.fontSize || 0.1,\n            letterSpacing: this.letterSpacing || 0,\n            lineHeight: this.lineHeight || \'normal\',\n            maxWidth: this.maxWidth,\n            textAlign: this.textAlign,\n            textIndent: this.textIndent,\n            whiteSpace: this.whiteSpace,\n            overflowWrap: this.overflowWrap,\n            anchorX: this.anchorX,\n            anchorY: this.anchorY,\n            colorRanges: this.colorRanges,\n            includeCaretPositions: true, //TODO parameterize\n            sdfGlyphSize: this.sdfGlyphSize\n          }, function (textRenderInfo) {\n            this$1._isSyncing = false;\n\n            // Save result for later use in onBeforeRender\n            this$1._textRenderInfo = textRenderInfo;\n\n            // Update the geometry attributes\n            this$1.geometry.updateGlyphs(\n              textRenderInfo.glyphBounds,\n              textRenderInfo.glyphAtlasIndices,\n              textRenderInfo.totalBounds,\n              textRenderInfo.chunkedBounds,\n              textRenderInfo.glyphColors\n            );\n\n            // If we had extra sync requests queued up, kick it off\n            var queued = this$1._queuedSyncs;\n            if (queued) {\n              this$1._queuedSyncs = null;\n              this$1._needsSync = true;\n              this$1.sync(function () {\n                queued.forEach(function (fn) { return fn && fn(); });\n              });\n            }\n\n            this$1.dispatchEvent(syncCompleteEvent);\n            if (callback) {\n              callback();\n            }\n          });\n        }\n      }\n    };\n\n    /**\n     * Initiate a sync if needed - note it won\'t complete until next frame at the\n     * earliest so if possible it\'s a good idea to call sync() manually as soon as\n     * all the properties have been set.\n     * @override\n     */\n    Text.prototype.onBeforeRender = function onBeforeRender () {\n      this.sync();\n      this._prepareForRender();\n    };\n\n    /**\n     * Shortcut to dispose the geometry specific to this instance.\n     * Note: we don\'t also dispose the derived material here because if anything else is\n     * sharing the same base material it will result in a pause next frame as the program\n     * is recompiled. Instead users can dispose the base material manually, like normal,\n     * and we\'ll also dispose the derived material at that time.\n     */\n    Text.prototype.dispose = function dispose () {\n      this.geometry.dispose();\n    };\n\n    /**\n     * @property {TroikaTextRenderInfo|null} textRenderInfo\n     * @readonly\n     * The current processed rendering data for this TextMesh, returned by the TextBuilder after\n     * a `sync()` call. This will be `null` initially, and may be stale for a short period until\n     * the asynchrous `sync()` process completes.\n     */\n    prototypeAccessors.textRenderInfo.get = function () {\n      return this._textRenderInfo || null\n    };\n\n    // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n    // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n    prototypeAccessors.material.get = function () {\n      var derivedMaterial = this._derivedMaterial;\n      var baseMaterial = this._baseMaterial || defaultMaterial;\n      if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\n        derivedMaterial = this._derivedMaterial = createTextDerivedMaterial(baseMaterial);\n        // dispose the derived material when its base material is disposed:\n        baseMaterial.addEventListener(\'dispose\', function onDispose() {\n          baseMaterial.removeEventListener(\'dispose\', onDispose);\n          derivedMaterial.dispose();\n        });\n      }\n      return derivedMaterial\n    };\n    prototypeAccessors.material.set = function (baseMaterial) {\n      if (baseMaterial && baseMaterial.isTroikaTextMaterial) { //prevent double-derivation\n        this._derivedMaterial = baseMaterial;\n        this._baseMaterial = baseMaterial.baseMaterial;\n      } else {\n        this._baseMaterial = baseMaterial;\n      }\n    };\n\n    prototypeAccessors.glyphGeometryDetail.get = function () {\n      return this.geometry.detail\n    };\n    prototypeAccessors.glyphGeometryDetail.set = function (detail) {\n      this.geometry.detail = detail;\n    };\n\n    // Create and update material for shadows upon request:\n    prototypeAccessors.customDepthMaterial.get = function () {\n      return this.material.getDepthMaterial()\n    };\n    prototypeAccessors.customDistanceMaterial.get = function () {\n      return this.material.getDistanceMaterial()\n    };\n\n    Text.prototype._prepareForRender = function _prepareForRender () {\n      var material = this._derivedMaterial;\n      var uniforms = material.uniforms;\n      var textInfo = this.textRenderInfo;\n      if (textInfo) {\n        var sdfTexture = textInfo.sdfTexture;\n        var totalBounds = textInfo.totalBounds;\n        uniforms.uTroikaSDFTexture.value = sdfTexture;\n        uniforms.uTroikaSDFTextureSize.value.set(sdfTexture.image.width, sdfTexture.image.height);\n        uniforms.uTroikaSDFGlyphSize.value = textInfo.sdfGlyphSize;\n        uniforms.uTroikaSDFMinDistancePct.value = textInfo.sdfMinDistancePercent;\n        uniforms.uTroikaTotalBounds.value.fromArray(totalBounds);\n        uniforms.uTroikaUseGlyphColors.value = !!textInfo.glyphColors;\n\n        var clipRect = this.clipRect;\n        if (!(clipRect && Array.isArray(clipRect) && clipRect.length === 4)) {\n          uniforms.uTroikaClipRect.value.fromArray(totalBounds);\n        } else {\n          uniforms.uTroikaClipRect.value.set(\n            Math.max(totalBounds[0], clipRect[0]),\n            Math.max(totalBounds[1], clipRect[1]),\n            Math.min(totalBounds[2], clipRect[2]),\n            Math.min(totalBounds[3], clipRect[3])\n          );\n        }\n        this.geometry.applyClipRect(uniforms.uTroikaClipRect.value);\n      }\n      uniforms.uTroikaSDFDebug.value = !!this.debugSDF;\n      material.polygonOffset = !!this.depthOffset;\n      material.polygonOffsetFactor = material.polygonOffsetUnits = this.depthOffset || 0;\n\n      // shortcut for setting material color via `color` prop on the mesh:\n      var color = this.color;\n      if (color != null && material.color && material.color.isColor && color !== material._troikaColor) {\n        material.color.set(material._troikaColor = color);\n      }\n\n      // base orientation\n      var orient = this.orientation || defaultOrient;\n      if (orient !== material._orientation) {\n        var rotMat = uniforms.uTroikaOrient.value;\n        orient = orient.replace(/[^-+xyz]/g, \'\');\n        var match = orient !== defaultOrient && orient.match(/^([-+])([xyz])([-+])([xyz])$/);\n        if (match) {\n          var hSign = match[1];\n          var hAxis = match[2];\n          var vSign = match[3];\n          var vAxis = match[4];\n          tempVec3a.set(0, 0, 0)[hAxis] = hSign === \'-\' ? 1 : -1;\n          tempVec3b.set(0, 0, 0)[vAxis] = vSign === \'-\' ? -1 : 1;\n          tempMat4.lookAt(origin, tempVec3a.cross(tempVec3b), tempVec3b);\n          rotMat.setFromMatrix4(tempMat4);\n        } else {\n          rotMat.identity();\n        }\n        material._orientation = orient;\n      }\n    };\n\n    /**\n     * @override Custom raycasting to test against the whole text block\'s max rectangular bounds\n     * TODO is there any reason to make this more granular, like within individual line or glyph rects?\n     */\n    Text.prototype.raycast = function raycast (raycaster, intersects) {\n      var textInfo = this.textRenderInfo;\n      if (textInfo) {\n        var bounds = textInfo.totalBounds;\n        raycastMesh.matrixWorld.multiplyMatrices(\n          this.matrixWorld,\n          tempMat4.set(\n            bounds[2] - bounds[0], 0, 0, bounds[0],\n            0, bounds[3] - bounds[1], 0, bounds[1],\n            0, 0, 1, 0,\n            0, 0, 0, 1\n          )\n        );\n        tempArray.length = 0;\n        raycastMesh.raycast(raycaster, tempArray);\n        for (var i = 0; i < tempArray.length; i++) {\n          tempArray[i].object = this;\n          intersects.push(tempArray[i]);\n        }\n      }\n    };\n\n    Text.prototype.copy = function copy (source) {\n      var this$1 = this;\n\n      Mesh.prototype.copy.call(this, source);\n      COPYABLE_PROPS.forEach(function (prop) {\n        this$1[prop] = source[prop];\n      });\n      return this\n    };\n\n    Text.prototype.clone = function clone () {\n      return new this.constructor().copy(this)\n    };\n\n    Object.defineProperties( Text.prototype, prototypeAccessors );\n\n    return Text;\n  }(three.Mesh));\n\n\n  // Create setters for properties that affect text layout:\n  SYNCABLE_PROPS.forEach(function (prop) {\n    var privateKey = \'_private_\' + prop;\n    Object.defineProperty(Text.prototype, prop, {\n      get: function get() {\n        return this[privateKey]\n      },\n      set: function set(value) {\n        if (value !== this[privateKey]) {\n          this[privateKey] = value;\n          this._needsSync = true;\n        }\n      }\n    });\n  });\n\n\n  // Deprecation handler for `anchor` array:\n  var deprMsgShown = false;\n  Object.defineProperty(Text.prototype, \'anchor\', {\n    get: function get() {\n      return this._deprecated_anchor\n    },\n    set: function set(val) {\n      this._deprecated_anchor = val;\n      if (!deprMsgShown) {\n        console.warn(\'TextMesh: `anchor` has been deprecated; use `anchorX` and `anchorY` instead.\');\n        deprMsgShown = true;\n      }\n      if (Array.isArray(val)) {\n        this.anchorX = ((+val[0] || 0) * 100) + "%";\n        this.anchorY = ((+val[1] || 0) * 100) + "%";\n      } else {\n        this.anchorX = this.anchorY = 0;\n      }\n    }\n  });\n\n  //=== Utility functions for dealing with carets and selection ranges ===//\n\n  /**\n   * @typedef {object} TextCaret\n   * @property {number} x - x position of the caret\n   * @property {number} y - y position of the caret\'s bottom\n   * @property {number} height - height of the caret\n   * @property {number} charIndex - the index in the original input string of this caret\'s target\n   *   character; the caret will be for the position _before_ that character.\n   */\n\n  /**\n   * Given a local x/y coordinate in the text block plane, find the nearest caret position.\n   * @param {TroikaTextRenderInfo} textRenderInfo - a result object from TextBuilder#getTextRenderInfo\n   * @param {number} x\n   * @param {number} y\n   * @return {TextCaret | null}\n   */\n  function getCaretAtPoint(textRenderInfo, x, y) {\n    var closestCaret = null;\n    var caretHeight = textRenderInfo.caretHeight;\n    var caretsByRow = groupCaretsByRow(textRenderInfo);\n\n    // Find nearest row by y first\n    var closestRowY = Infinity;\n    caretsByRow.forEach(function (carets, rowY) {\n      if (Math.abs(y - (rowY + caretHeight / 2)) < Math.abs(y - (closestRowY + caretHeight / 2))) {\n        closestRowY = rowY;\n      }\n    });\n\n    // Then find closest caret by x within that row\n    caretsByRow.get(closestRowY).forEach(function (caret) {\n      if (!closestCaret || Math.abs(x - caret.x) < Math.abs(x - closestCaret.x)) {\n        closestCaret = caret;\n      }\n    });\n    return closestCaret\n  }\n\n\n  var _rectsCache = new WeakMap();\n\n  /**\n   * Given start and end character indexes, return a list of rectangles covering all the\n   * characters within that selection.\n   * @param {TroikaTextRenderInfo} textRenderInfo\n   * @param {number} start - index of the first char in the selection\n   * @param {number} end - index of the first char after the selection\n   * @return {Array<{left, top, right, bottom}> | null}\n   */\n  function getSelectionRects(textRenderInfo, start, end) {\n    var rects;\n    if (textRenderInfo) {\n      // Check cache - textRenderInfo is frozen so it\'s safe to cache based on it\n      var prevResult = _rectsCache.get(textRenderInfo);\n      if (prevResult && prevResult.start === start && prevResult.end === end) {\n        return prevResult.rects\n      }\n\n      var caretPositions = textRenderInfo.caretPositions;\n      var caretHeight = textRenderInfo.caretHeight;\n      var totalBounds = textRenderInfo.totalBounds;\n\n      // Normalize\n      if (end < start) {\n        var s = start;\n        start = end;\n        end = s;\n      }\n      start = Math.max(start, 0);\n      end = Math.min(end, caretPositions.length + 1);\n\n      // Collect into one rect per row\n      var rows = new Map();\n      for (var i = start; i < end; i++) {\n        var x1 = caretPositions[i * 3];\n        var x2 = caretPositions[i * 3 + 1];\n        var y = caretPositions[i * 3 + 2];\n        var row = rows.get(y);\n        if (!row) {\n          row = {left: x1, right: x2, bottom: y, top: y + caretHeight};\n          rows.set(y, row);\n        } else {\n          row.left = Math.max(Math.min(row.left, x1), totalBounds[0]);\n          row.right = Math.min(Math.max(row.right, x2), totalBounds[2]);\n        }\n      }\n      rects = [];\n      rows.forEach(function (rect) {\n        rects.push(rect);\n      });\n\n      _rectsCache.set(textRenderInfo, {start: start, end: end, rects: rects});\n    }\n    return rects\n  }\n\n  var _caretsByRowCache = new WeakMap();\n\n  function groupCaretsByRow(textRenderInfo) {\n    // textRenderInfo is frozen so it\'s safe to cache based on it\n    var caretsByRow = _caretsByRowCache.get(textRenderInfo);\n    if (!caretsByRow) {\n      var caretPositions = textRenderInfo.caretPositions;\n      var caretHeight = textRenderInfo.caretHeight;\n      caretsByRow = new Map();\n      for (var i = 0; i < caretPositions.length; i += 3) {\n        var rowY = caretPositions[i + 2];\n        var rowCarets = caretsByRow.get(rowY);\n        if (!rowCarets) {\n          caretsByRow.set(rowY, rowCarets = []);\n        }\n        rowCarets.push({\n          x: caretPositions[i],\n          y: rowY,\n          height: caretHeight,\n          charIndex: i / 3\n        });\n        // Add one more caret after the final char\n        if (i + 3 >= caretPositions.length) {\n          rowCarets.push({\n            x: caretPositions[i + 1],\n            y: rowY,\n            height: caretHeight,\n            charIndex: i / 3 + 1\n          });\n        }\n      }\n    }\n    _caretsByRowCache.set(textRenderInfo, caretsByRow);\n    return caretsByRow\n  }\n\n  exports.GlyphsGeometry = GlyphsGeometry;\n  exports.Text = Text;\n  exports.configureTextBuilder = configureTextBuilder;\n  exports.createTextDerivedMaterial = createTextDerivedMaterial;\n  exports.fontProcessorWorkerModule = fontProcessorWorkerModule;\n  exports.getCaretAtPoint = getCaretAtPoint;\n  exports.getSelectionRects = getSelectionRects;\n  exports.preloadFont = preloadFont;\n\n  Object.defineProperty(exports, \'__esModule\', { value: true });\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHJvaWthLXRocmVlLXRleHQvZGlzdC90cm9pa2EtdGhyZWUtdGV4dC51bWQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxFQUFFLEtBQTRELG9CQUFvQixtQkFBTyxDQUFDLHdEQUFPLEdBQUcsbUJBQU8sQ0FBQyxxR0FBcUIsR0FBRyxtQkFBTyxDQUFDLGtHQUFvQjtBQUNoSyxFQUFFLENBQ3NJO0FBQ3hJLENBQUMseUVBQXlFOztBQUUxRTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLDhCQUE4QixrQkFBa0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxnQ0FBZ0Msb0JBQW9CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QStFO0FBQy9FLHFHQUFxRztBQUNyRyx1R0FBdUc7O0FBRXZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDO0FBQzdDLDZDQUE2QztBQUM3Qyw2Q0FBNkM7QUFDN0MsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1Qyw0Q0FBNEM7QUFDNUMsNENBQTRDO0FBQzVDLDRDQUE0Qzs7QUFFNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFLDJHQUEyRztBQUMzRztBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPLEdBQUcsa0JBQWtCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsMkJBQTJCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsT0FBTyx5QkFBeUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsU0FBUztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUCx1Q0FBdUMscUNBQXFDO0FBQzVFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWlELGFBQWE7O0FBRTlELENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vYS1wcm9qLWNhbm5vbi1sb2wvLi9ub2RlX21vZHVsZXMvdHJvaWthLXRocmVlLXRleHQvZGlzdC90cm9pa2EtdGhyZWUtdGV4dC51bWQuanM/ODRjZSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ3RocmVlJyksIHJlcXVpcmUoJ3Ryb2lrYS13b3JrZXItdXRpbHMnKSwgcmVxdWlyZSgndHJvaWthLXRocmVlLXV0aWxzJykpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICd0aHJlZScsICd0cm9pa2Etd29ya2VyLXV0aWxzJywgJ3Ryb2lrYS10aHJlZS11dGlscyddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwudHJvaWthX3RocmVlX3RleHQgPSB7fSwgZ2xvYmFsLlRIUkVFLCBnbG9iYWwudHJvaWthX3dvcmtlcl91dGlscywgZ2xvYmFsLnRyb2lrYV90aHJlZV91dGlscykpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsIHRocmVlLCB0cm9pa2FXb3JrZXJVdGlscywgdHJvaWthVGhyZWVVdGlscykgeyAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGFuZCByZXR1cm5zIGEgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgYW4gU0RGIHRleHR1cmUgZm9yIGEgZ2l2ZW4gZ2x5cGguXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNyZWF0ZUdseXBoU2VnbWVudHNRdWFkdHJlZSAtIGZhY3RvcnkgZm9yIGEgR2x5cGhTZWdtZW50c1F1YWR0cmVlIGltcGxlbWVudGF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gY29uZmlnLnNkZkRpc3RhbmNlUGVyY2VudCAtIHNlZSBkb2NzIGZvciBTREZfRElTVEFOQ0VfUEVSQ0VOVCBpbiBUZXh0QnVpbGRlci5qc1xuICAgKlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbihPYmplY3QpOiB7cmVuZGVyaW5nQm91bmRzOiBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV0sIHRleHR1cmVEYXRhOiBVaW50OEFycmF5fX1cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZVNERkdlbmVyYXRvcihjcmVhdGVHbHlwaFNlZ21lbnRzUXVhZHRyZWUsIGNvbmZpZykge1xuICAgIHZhciBzZGZEaXN0YW5jZVBlcmNlbnQgPSBjb25maWcuc2RmRGlzdGFuY2VQZXJjZW50O1xuXG4gICAgLyoqXG4gICAgICogSG93IG1hbnkgc3RyYWlnaHQgbGluZSBzZWdtZW50cyB0byB1c2Ugd2hlbiBhcHByb3hpbWF0aW5nIGEgZ2x5cGgncyBxdWFkcmF0aWMvY3ViaWMgYmV6aWVyIGN1cnZlcy5cbiAgICAgKi9cbiAgICB2YXIgQ1VSVkVfUE9JTlRTID0gMTY7XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBwb2ludCBvbiBhIHF1YWRyYXRpYyBiZXppZXIgY3VydmUgYXQgdCB3aGVyZSB0IGlzIGluIHRoZSByYW5nZSBbMCwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwb2ludE9uUXVhZHJhdGljQmV6aWVyKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHQpIHtcbiAgICAgIHZhciB0MiA9IDEgLSB0O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogdDIgKiB0MiAqIHgwICsgMiAqIHQyICogdCAqIHgxICsgdCAqIHQgKiB4MixcbiAgICAgICAgeTogdDIgKiB0MiAqIHkwICsgMiAqIHQyICogdCAqIHkxICsgdCAqIHQgKiB5MlxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIHBvaW50IG9uIGEgY3ViaWMgYmV6aWVyIGN1cnZlIGF0IHQgd2hlcmUgdCBpcyBpbiB0aGUgcmFuZ2UgWzAsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcG9pbnRPbkN1YmljQmV6aWVyKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdCkge1xuICAgICAgdmFyIHQyID0gMSAtIHQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB0MiAqIHQyICogdDIgKiB4MCArIDMgKiB0MiAqIHQyICogdCAqIHgxICsgMyAqIHQyICogdCAqIHQgKiB4MiArIHQgKiB0ICogdCAqIHgzLFxuICAgICAgICB5OiB0MiAqIHQyICogdDIgKiB5MCArIDMgKiB0MiAqIHQyICogdCAqIHkxICsgMyAqIHQyICogdCAqIHQgKiB5MiArIHQgKiB0ICogdCAqIHkzXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYW4gU0RGIHRleHR1cmUgc2VnbWVudCBmb3IgYSBzaW5nbGUgZ2x5cGguXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGdseXBoT2JqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNkZlNpemUgLSB0aGUgbGVuZ3RoIG9mIG9uZSBzaWRlIG9mIHRoZSBTREYgaW1hZ2UuXG4gICAgICogICAgICAgIExhcmdlciBpbWFnZXMgZW5jb2RlIG1vcmUgZGV0YWlscy4gTXVzdCBiZSBhIHBvd2VyIG9mIDIuXG4gICAgICogQHJldHVybiB7e3RleHR1cmVEYXRhOiBVaW50OEFycmF5LCByZW5kZXJpbmdCb3VuZHM6ICpbXX19XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVTREYoZ2x5cGhPYmosIHNkZlNpemUpIHtcbiAgICAgIC8vY29uc29sZS50aW1lKCdnbHlwaFNERicpXG5cbiAgICAgIHZhciB0ZXh0dXJlRGF0YSA9IG5ldyBVaW50OEFycmF5KHNkZlNpemUgKiBzZGZTaXplKTtcblxuICAgICAgLy8gRGV0ZXJtaW5lIG1hcHBpbmcgYmV0d2VlbiBnbHlwaCBncmlkIGNvb3JkcyBhbmQgc2RmIGdyaWQgY29vcmRzXG4gICAgICB2YXIgZ2x5cGhXID0gZ2x5cGhPYmoueE1heCAtIGdseXBoT2JqLnhNaW47XG4gICAgICB2YXIgZ2x5cGhIID0gZ2x5cGhPYmoueU1heCAtIGdseXBoT2JqLnlNaW47XG5cbiAgICAgIC8vIENob29zZSBhIG1heGltdW0gZGlzdGFuY2UgcmFkaXVzIGluIGZvbnQgdW5pdHMsIGJhc2VkIG9uIHRoZSBnbHlwaCdzIG1heCBkaW1lbnNpb25zXG4gICAgICB2YXIgZm9udFVuaXRzTWF4RGlzdCA9IE1hdGgubWF4KGdseXBoVywgZ2x5cGhIKSAqIHNkZkRpc3RhbmNlUGVyY2VudDtcblxuICAgICAgLy8gVXNlIHRoYXQsIGV4dGVuZGluZyB0byB0aGUgdGV4dHVyZSBlZGdlcywgdG8gZmluZCBjb252ZXJzaW9uIHJhdGlvcyBiZXR3ZWVuIHRleHR1cmUgdW5pdHMgYW5kIGZvbnQgdW5pdHNcbiAgICAgIHZhciBmb250VW5pdHNQZXJYVGV4ZWwgPSAoZ2x5cGhXICsgZm9udFVuaXRzTWF4RGlzdCAqIDIpIC8gc2RmU2l6ZTtcbiAgICAgIHZhciBmb250VW5pdHNQZXJZVGV4ZWwgPSAoZ2x5cGhIICsgZm9udFVuaXRzTWF4RGlzdCAqIDIpIC8gc2RmU2l6ZTtcblxuICAgICAgdmFyIHRleHR1cmVNaW5Gb250WCA9IGdseXBoT2JqLnhNaW4gLSBmb250VW5pdHNNYXhEaXN0IC0gZm9udFVuaXRzUGVyWFRleGVsO1xuICAgICAgdmFyIHRleHR1cmVNaW5Gb250WSA9IGdseXBoT2JqLnlNaW4gLSBmb250VW5pdHNNYXhEaXN0IC0gZm9udFVuaXRzUGVyWVRleGVsO1xuICAgICAgdmFyIHRleHR1cmVNYXhGb250WCA9IGdseXBoT2JqLnhNYXggKyBmb250VW5pdHNNYXhEaXN0ICsgZm9udFVuaXRzUGVyWFRleGVsO1xuICAgICAgdmFyIHRleHR1cmVNYXhGb250WSA9IGdseXBoT2JqLnlNYXggKyBmb250VW5pdHNNYXhEaXN0ICsgZm9udFVuaXRzUGVyWVRleGVsO1xuXG4gICAgICBmdW5jdGlvbiB0ZXh0dXJlWFRvRm9udFgoeCkge1xuICAgICAgICByZXR1cm4gdGV4dHVyZU1pbkZvbnRYICsgKHRleHR1cmVNYXhGb250WCAtIHRleHR1cmVNaW5Gb250WCkgKiB4IC8gc2RmU2l6ZVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0ZXh0dXJlWVRvRm9udFkoeSkge1xuICAgICAgICByZXR1cm4gdGV4dHVyZU1pbkZvbnRZICsgKHRleHR1cmVNYXhGb250WSAtIHRleHR1cmVNaW5Gb250WSkgKiB5IC8gc2RmU2l6ZVxuICAgICAgfVxuXG4gICAgICBpZiAoZ2x5cGhPYmoucGF0aENvbW1hbmRDb3VudCkgeyAvL3doaXRlc3BhY2UgY2hhcnMgd2lsbCBoYXZlIG5vIGNvbW1hbmRzLCBzbyB3ZSBjYW4gc2tpcCBhbGwgdGhpc1xuICAgICAgICAvLyBEZWNvbXBvc2UgYWxsIHBhdGhzIGludG8gc3RyYWlnaHQgbGluZSBzZWdtZW50cyBhbmQgYWRkIHRoZW0gdG8gYSBxdWFkdHJlZVxuICAgICAgICB2YXIgbGluZVNlZ21lbnRzSW5kZXggPSBjcmVhdGVHbHlwaFNlZ21lbnRzUXVhZHRyZWUoZ2x5cGhPYmopO1xuICAgICAgICB2YXIgZmlyc3RYLCBmaXJzdFksIHByZXZYLCBwcmV2WTtcbiAgICAgICAgZ2x5cGhPYmouZm9yRWFjaFBhdGhDb21tYW5kKGZ1bmN0aW9uICh0eXBlLCB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgICAgcHJldlggPSBmaXJzdFggPSB4MDtcbiAgICAgICAgICAgICAgcHJldlkgPSBmaXJzdFkgPSB5MDtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgICBpZiAoeDAgIT09IHByZXZYIHx8IHkwICE9PSBwcmV2WSkgeyAvL3l1cCwgc29tZSBmb250cyBoYXZlIHplcm8tbGVuZ3RoIGxpbmUgY29tbWFuZHNcbiAgICAgICAgICAgICAgICBsaW5lU2VnbWVudHNJbmRleC5hZGRMaW5lU2VnbWVudChwcmV2WCwgcHJldlksIChwcmV2WCA9IHgwKSwgKHByZXZZID0geTApKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSAnUSc6IHtcbiAgICAgICAgICAgICAgdmFyIHByZXZQb2ludCA9IHt4OiBwcmV2WCwgeTogcHJldll9O1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IENVUlZFX1BPSU5UUzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRQb2ludCA9IHBvaW50T25RdWFkcmF0aWNCZXppZXIoXG4gICAgICAgICAgICAgICAgICBwcmV2WCwgcHJldlksXG4gICAgICAgICAgICAgICAgICB4MCwgeTAsXG4gICAgICAgICAgICAgICAgICB4MSwgeTEsXG4gICAgICAgICAgICAgICAgICBpIC8gKENVUlZFX1BPSU5UUyAtIDEpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBsaW5lU2VnbWVudHNJbmRleC5hZGRMaW5lU2VnbWVudChwcmV2UG9pbnQueCwgcHJldlBvaW50LnksIG5leHRQb2ludC54LCBuZXh0UG9pbnQueSk7XG4gICAgICAgICAgICAgICAgcHJldlBvaW50ID0gbmV4dFBvaW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHByZXZYID0geDE7XG4gICAgICAgICAgICAgIHByZXZZID0geTE7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdDJzoge1xuICAgICAgICAgICAgICB2YXIgcHJldlBvaW50JDEgPSB7eDogcHJldlgsIHk6IHByZXZZfTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMTsgaSQxIDwgQ1VSVkVfUE9JTlRTOyBpJDErKykge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0UG9pbnQkMSA9IHBvaW50T25DdWJpY0JlemllcihcbiAgICAgICAgICAgICAgICAgIHByZXZYLCBwcmV2WSxcbiAgICAgICAgICAgICAgICAgIHgwLCB5MCxcbiAgICAgICAgICAgICAgICAgIHgxLCB5MSxcbiAgICAgICAgICAgICAgICAgIHgyLCB5MixcbiAgICAgICAgICAgICAgICAgIGkkMSAvIChDVVJWRV9QT0lOVFMgLSAxKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbGluZVNlZ21lbnRzSW5kZXguYWRkTGluZVNlZ21lbnQocHJldlBvaW50JDEueCwgcHJldlBvaW50JDEueSwgbmV4dFBvaW50JDEueCwgbmV4dFBvaW50JDEueSk7XG4gICAgICAgICAgICAgICAgcHJldlBvaW50JDEgPSBuZXh0UG9pbnQkMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwcmV2WCA9IHgyO1xuICAgICAgICAgICAgICBwcmV2WSA9IHkyO1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgICAgIGlmIChwcmV2WCAhPT0gZmlyc3RYIHx8IHByZXZZICE9PSBmaXJzdFkpIHtcbiAgICAgICAgICAgICAgICBsaW5lU2VnbWVudHNJbmRleC5hZGRMaW5lU2VnbWVudChwcmV2WCwgcHJldlksIGZpcnN0WCwgZmlyc3RZKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRm9yIGVhY2ggdGFyZ2V0IFNERiB0ZXhlbCwgZmluZCB0aGUgZGlzdGFuY2UgZnJvbSBpdHMgY2VudGVyIHRvIGl0cyBuZWFyZXN0IGxpbmUgc2VnbWVudCxcbiAgICAgICAgLy8gbWFwIHRoYXQgZGlzdGFuY2UgdG8gYW4gYWxwaGEgdmFsdWUsIGFuZCB3cml0ZSB0aGF0IGFscGhhIHRvIHRoZSB0ZXhlbFxuICAgICAgICBmb3IgKHZhciBzZGZYID0gMDsgc2RmWCA8IHNkZlNpemU7IHNkZlgrKykge1xuICAgICAgICAgIGZvciAodmFyIHNkZlkgPSAwOyBzZGZZIDwgc2RmU2l6ZTsgc2RmWSsrKSB7XG4gICAgICAgICAgICB2YXIgc2lnbmVkRGlzdCA9IGxpbmVTZWdtZW50c0luZGV4LmZpbmROZWFyZXN0U2lnbmVkRGlzdGFuY2UoXG4gICAgICAgICAgICAgIHRleHR1cmVYVG9Gb250WChzZGZYICsgMC41KSxcbiAgICAgICAgICAgICAgdGV4dHVyZVlUb0ZvbnRZKHNkZlkgKyAwLjUpLFxuICAgICAgICAgICAgICBmb250VW5pdHNNYXhEaXN0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgLy9pZiAoIWlzRmluaXRlKHNpZ25lZERpc3QpKSB0aHJvdyAnaW5maW5pdGUgZGlzdGFuY2UhJ1xuICAgICAgICAgICAgdmFyIGFscGhhID0gaXNGaW5pdGUoc2lnbmVkRGlzdCkgPyBNYXRoLnJvdW5kKDI1NSAqICgxICsgc2lnbmVkRGlzdCAvIGZvbnRVbml0c01heERpc3QpICogMC41KSA6IHNpZ25lZERpc3Q7XG4gICAgICAgICAgICBhbHBoYSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgYWxwaGEpKTsgLy9jbGFtcFxuICAgICAgICAgICAgdGV4dHVyZURhdGFbc2RmWSAqIHNkZlNpemUgKyBzZGZYXSA9IGFscGhhO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvL2NvbnNvbGUudGltZUVuZCgnZ2x5cGhTREYnKVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0dXJlRGF0YTogdGV4dHVyZURhdGEsXG5cbiAgICAgICAgcmVuZGVyaW5nQm91bmRzOiBbXG4gICAgICAgICAgdGV4dHVyZU1pbkZvbnRYLFxuICAgICAgICAgIHRleHR1cmVNaW5Gb250WSxcbiAgICAgICAgICB0ZXh0dXJlTWF4Rm9udFgsXG4gICAgICAgICAgdGV4dHVyZU1heEZvbnRZXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9XG5cblxuICAgIHJldHVybiBnZW5lcmF0ZVNERlxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzZWxmLWNvbnRhaW5lZCBlbnZpcm9ubWVudCBmb3IgcHJvY2Vzc2luZyB0ZXh0IHJlbmRlcmluZyByZXF1ZXN0cy5cbiAgICpcbiAgICogSXQgaXMgaW1wb3J0YW50IHRoYXQgdGhpcyBmdW5jdGlvbiBoYXMgbm8gY2xvc3VyZSBkZXBlbmRlbmNpZXMsIHNvIHRoYXQgaXQgY2FuIGJlIGVhc2lseSBpbmplY3RlZFxuICAgKiBpbnRvIHRoZSBzb3VyY2UgZm9yIGEgV29ya2VyIHdpdGhvdXQgcmVxdWlyaW5nIGEgYnVpbGQgc3RlcCBvciBjb21wbGV4IGRlcGVuZGVuY3kgbG9hZGluZy4gQWxsIGl0c1xuICAgKiBkZXBlbmRlbmNpZXMgbXVzdCBiZSBwYXNzZWQgaW4gYXQgaW5pdGlhbGl6YXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZvbnRQYXJzZXIgLSBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhbiBBcnJheUJ1ZmZlciBvZiB0aGUgZm9udCBkYXRhIGFuZCByZXR1cm5zXG4gICAqIGEgc3RhbmRhcmRpemVkIHN0cnVjdHVyZSBnaXZpbmcgYWNjZXNzIHRvIHRoZSBmb250IGFuZCBpdHMgZ2x5cGhzOlxuICAgKiAgIHtcbiAgICogICAgIHVuaXRzUGVyRW06IG51bWJlcixcbiAgICogICAgIGFzY2VuZGVyOiBudW1iZXIsXG4gICAqICAgICBkZXNjZW5kZXI6IG51bWJlcixcbiAgICogICAgIGZvckVhY2hHbHlwaChzdHJpbmcsIGZvbnRTaXplLCBsZXR0ZXJTcGFjaW5nLCBjYWxsYmFjaykge1xuICAgKiAgICAgICAvL2ludm9rZXMgY2FsbGJhY2sgZm9yIGVhY2ggZ2x5cGggdG8gcmVuZGVyLCBwYXNzaW5nIGl0IGFuIG9iamVjdDpcbiAgICogICAgICAgY2FsbGJhY2soe1xuICAgKiAgICAgICAgIGluZGV4OiBudW1iZXIsXG4gICAqICAgICAgICAgYWR2YW5jZVdpZHRoOiBudW1iZXIsXG4gICAqICAgICAgICAgeE1pbjogbnVtYmVyLFxuICAgKiAgICAgICAgIHlNaW46IG51bWJlcixcbiAgICogICAgICAgICB4TWF4OiBudW1iZXIsXG4gICAqICAgICAgICAgeU1heDogbnVtYmVyLFxuICAgKiAgICAgICAgIHBhdGhDb21tYW5kQ291bnQ6IG51bWJlcixcbiAgICogICAgICAgICBmb3JFYWNoUGF0aENvbW1hbmQoY2FsbGJhY2spIHtcbiAgICogICAgICAgICAgIC8vaW52b2tlcyBjYWxsYmFjayBmb3IgZWFjaCBwYXRoIGNvbW1hbmQsIHdpdGggYXJnczpcbiAgICogICAgICAgICAgIGNhbGxiYWNrKFxuICAgKiAgICAgICAgICAgICB0eXBlOiAnTXxMfEN8UXxaJyxcbiAgICogICAgICAgICAgICAgLi4uYXJncyAvLzAgdG8gNiBhcmdzIGRlcGVuZGluZyBvbiB0aGUgdHlwZVxuICAgKiAgICAgICAgICAgKVxuICAgKiAgICAgICAgIH1cbiAgICogICAgICAgfSlcbiAgICogICAgIH1cbiAgICogICB9XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHNkZkdlbmVyYXRvciAtIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGEgZ2x5cGggb2JqZWN0IGFuZCBnZW5lcmF0ZXMgYW4gU0RGIHRleHR1cmVcbiAgICogZnJvbSBpdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVGb250UHJvY2Vzc29yKGZvbnRQYXJzZXIsIHNkZkdlbmVyYXRvciwgY29uZmlnKSB7XG5cbiAgICB2YXIgZGVmYXVsdEZvbnRVcmwgPSBjb25maWcuZGVmYXVsdEZvbnRVcmw7XG5cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogSG9sZHMgZGF0YSBhYm91dCBmb250IGdseXBocyBhbmQgaG93IHRoZXkgcmVsYXRlIHRvIFNERiBhdGxhc2VzXG4gICAgICpcbiAgICAgKiB7XG4gICAgICogICAnZm9udFVybEBzZGZTaXplJzoge1xuICAgICAqICAgICBmb250T2JqOiB7fSwgLy9yZXN1bHQgb2YgdGhlIGZvbnRQYXJzZXJcbiAgICAgKiAgICAgZ2x5cGhzOiB7XG4gICAgICogICAgICAgW2dseXBoSW5kZXhdOiB7XG4gICAgICogICAgICAgICBhdGxhc0luZGV4OiAwLFxuICAgICAqICAgICAgICAgZ2x5cGhPYmo6IHt9LCAvL2dseXBoIG9iamVjdCBmcm9tIHRoZSBmb250UGFyc2VyXG4gICAgICogICAgICAgICByZW5kZXJpbmdCb3VuZHM6IFt4MCwgeTAsIHgxLCB5MV1cbiAgICAgKiAgICAgICB9LFxuICAgICAqICAgICAgIC4uLlxuICAgICAqICAgICB9LFxuICAgICAqICAgICBnbHlwaENvdW50OiAxMjNcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgdmFyIGZvbnRBdGxhc2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIC8qKlxuICAgICAqIEhvbGRzIHBhcnNlZCBmb250IG9iamVjdHMgYnkgdXJsXG4gICAgICovXG4gICAgdmFyIGZvbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIHZhciBJTkYgPSBJbmZpbml0eTtcblxuXG4gICAgLyoqXG4gICAgICogTG9hZCBhIGdpdmVuIGZvbnQgdXJsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZG9Mb2FkRm9udCh1cmwsIGNhbGxiYWNrKSB7XG4gICAgICBmdW5jdGlvbiB0cnlMb2FkKCkge1xuICAgICAgICB2YXIgb25FcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKChcIkZhaWx1cmUgbG9hZGluZyBmb250IFwiICsgdXJsICsgKHVybCA9PT0gZGVmYXVsdEZvbnRVcmwgPyAnJyA6ICc7IHRyeWluZyBmYWxsYmFjaycpKSwgZXJyKTtcbiAgICAgICAgICBpZiAodXJsICE9PSBkZWZhdWx0Rm9udFVybCkge1xuICAgICAgICAgICAgdXJsID0gZGVmYXVsdEZvbnRVcmw7XG4gICAgICAgICAgICB0cnlMb2FkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgcmVxdWVzdC5vcGVuKCdnZXQnLCB1cmwsIHRydWUpO1xuICAgICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA+PSA0MDApIHtcbiAgICAgICAgICAgICAgb25FcnJvcihuZXcgRXJyb3IocmVxdWVzdC5zdGF0dXNUZXh0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZXF1ZXN0LnN0YXR1cyA+IDApIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgZm9udE9iaiA9IGZvbnRQYXJzZXIocmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZm9udE9iaik7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBvbkVycm9yKGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBvbkVycm9yO1xuICAgICAgICAgIHJlcXVlc3Quc2VuZCgpO1xuICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHJ5TG9hZCgpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogTG9hZCBhIGdpdmVuIGZvbnQgdXJsIGlmIG5lZWRlZCwgaW52b2tpbmcgYSBjYWxsYmFjayB3aGVuIGl0J3MgbG9hZGVkLiBJZiBhbHJlYWR5XG4gICAgICogbG9hZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgc3luY2hyb25vdXNseS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2FkRm9udChmb250VXJsLCBjYWxsYmFjaykge1xuICAgICAgaWYgKCFmb250VXJsKSB7IGZvbnRVcmwgPSBkZWZhdWx0Rm9udFVybDsgfVxuICAgICAgdmFyIGZvbnQgPSBmb250c1tmb250VXJsXTtcbiAgICAgIGlmIChmb250KSB7XG4gICAgICAgIC8vIGlmIGN1cnJlbnRseSBsb2FkaW5nIGZvbnQsIGFkZCB0byBjYWxsYmFja3MsIG90aGVyd2lzZSBleGVjdXRlIGltbWVkaWF0ZWx5XG4gICAgICAgIGlmIChmb250LnBlbmRpbmcpIHtcbiAgICAgICAgICBmb250LnBlbmRpbmcucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2soZm9udCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvbnRzW2ZvbnRVcmxdID0ge3BlbmRpbmc6IFtjYWxsYmFja119O1xuICAgICAgICBkb0xvYWRGb250KGZvbnRVcmwsIGZ1bmN0aW9uIChmb250T2JqKSB7XG4gICAgICAgICAgdmFyIGNhbGxiYWNrcyA9IGZvbnRzW2ZvbnRVcmxdLnBlbmRpbmc7XG4gICAgICAgICAgZm9udHNbZm9udFVybF0gPSBmb250T2JqO1xuICAgICAgICAgIGNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYikgeyByZXR1cm4gY2IoZm9udE9iaik7IH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYXRsYXMgZGF0YSBmb3IgYSBnaXZlbiBmb250IHVybCwgbG9hZGluZyBpdCBmcm9tIHRoZSBuZXR3b3JrIGFuZCBpbml0aWFsaXppbmdcbiAgICAgKiBpdHMgYXRsYXMgZGF0YSBvYmplY3RzIGlmIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTZGZBdGxhcyhmb250VXJsLCBzZGZHbHlwaFNpemUsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoIWZvbnRVcmwpIHsgZm9udFVybCA9IGRlZmF1bHRGb250VXJsOyB9XG4gICAgICB2YXIgYXRsYXNLZXkgPSBmb250VXJsICsgXCJAXCIgKyBzZGZHbHlwaFNpemU7XG4gICAgICB2YXIgYXRsYXMgPSBmb250QXRsYXNlc1thdGxhc0tleV07XG4gICAgICBpZiAoYXRsYXMpIHtcbiAgICAgICAgY2FsbGJhY2soYXRsYXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9hZEZvbnQoZm9udFVybCwgZnVuY3Rpb24gKGZvbnRPYmopIHtcbiAgICAgICAgICBhdGxhcyA9IGZvbnRBdGxhc2VzW2F0bGFzS2V5XSB8fCAoZm9udEF0bGFzZXNbYXRsYXNLZXldID0ge1xuICAgICAgICAgICAgZm9udE9iajogZm9udE9iaixcbiAgICAgICAgICAgIGdseXBoczoge30sXG4gICAgICAgICAgICBnbHlwaENvdW50OiAwXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY2FsbGJhY2soYXRsYXMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIE1haW4gZW50cnkgcG9pbnQuXG4gICAgICogUHJvY2VzcyBhIHRleHQgc3RyaW5nIHdpdGggZ2l2ZW4gZm9udCBhbmQgZm9ybWF0dGluZyBwYXJhbWV0ZXJzLCBhbmQgcmV0dXJuIGFsbCBpbmZvXG4gICAgICogbmVjZXNzYXJ5IHRvIHJlbmRlciBhbGwgaXRzIGdseXBocy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9jZXNzKFxuICAgICAgcmVmLFxuICAgICAgY2FsbGJhY2ssXG4gICAgICBtZXRyaWNzT25seVxuICAgICkge1xuICAgICAgdmFyIHRleHQgPSByZWYudGV4dDsgaWYgKCB0ZXh0ID09PSB2b2lkIDAgKSB0ZXh0ID0gJyc7XG4gICAgICB2YXIgZm9udCA9IHJlZi5mb250OyBpZiAoIGZvbnQgPT09IHZvaWQgMCApIGZvbnQgPSBkZWZhdWx0Rm9udFVybDtcbiAgICAgIHZhciBzZGZHbHlwaFNpemUgPSByZWYuc2RmR2x5cGhTaXplOyBpZiAoIHNkZkdseXBoU2l6ZSA9PT0gdm9pZCAwICkgc2RmR2x5cGhTaXplID0gNjQ7XG4gICAgICB2YXIgZm9udFNpemUgPSByZWYuZm9udFNpemU7IGlmICggZm9udFNpemUgPT09IHZvaWQgMCApIGZvbnRTaXplID0gMTtcbiAgICAgIHZhciBsZXR0ZXJTcGFjaW5nID0gcmVmLmxldHRlclNwYWNpbmc7IGlmICggbGV0dGVyU3BhY2luZyA9PT0gdm9pZCAwICkgbGV0dGVyU3BhY2luZyA9IDA7XG4gICAgICB2YXIgbGluZUhlaWdodCA9IHJlZi5saW5lSGVpZ2h0OyBpZiAoIGxpbmVIZWlnaHQgPT09IHZvaWQgMCApIGxpbmVIZWlnaHQgPSAnbm9ybWFsJztcbiAgICAgIHZhciBtYXhXaWR0aCA9IHJlZi5tYXhXaWR0aDsgaWYgKCBtYXhXaWR0aCA9PT0gdm9pZCAwICkgbWF4V2lkdGggPSBJTkY7XG4gICAgICB2YXIgdGV4dEFsaWduID0gcmVmLnRleHRBbGlnbjsgaWYgKCB0ZXh0QWxpZ24gPT09IHZvaWQgMCApIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgIHZhciB0ZXh0SW5kZW50ID0gcmVmLnRleHRJbmRlbnQ7IGlmICggdGV4dEluZGVudCA9PT0gdm9pZCAwICkgdGV4dEluZGVudCA9IDA7XG4gICAgICB2YXIgd2hpdGVTcGFjZSA9IHJlZi53aGl0ZVNwYWNlOyBpZiAoIHdoaXRlU3BhY2UgPT09IHZvaWQgMCApIHdoaXRlU3BhY2UgPSAnbm9ybWFsJztcbiAgICAgIHZhciBvdmVyZmxvd1dyYXAgPSByZWYub3ZlcmZsb3dXcmFwOyBpZiAoIG92ZXJmbG93V3JhcCA9PT0gdm9pZCAwICkgb3ZlcmZsb3dXcmFwID0gJ25vcm1hbCc7XG4gICAgICB2YXIgYW5jaG9yWCA9IHJlZi5hbmNob3JYOyBpZiAoIGFuY2hvclggPT09IHZvaWQgMCApIGFuY2hvclggPSAwO1xuICAgICAgdmFyIGFuY2hvclkgPSByZWYuYW5jaG9yWTsgaWYgKCBhbmNob3JZID09PSB2b2lkIDAgKSBhbmNob3JZID0gMDtcbiAgICAgIHZhciBpbmNsdWRlQ2FyZXRQb3NpdGlvbnMgPSByZWYuaW5jbHVkZUNhcmV0UG9zaXRpb25zOyBpZiAoIGluY2x1ZGVDYXJldFBvc2l0aW9ucyA9PT0gdm9pZCAwICkgaW5jbHVkZUNhcmV0UG9zaXRpb25zID0gZmFsc2U7XG4gICAgICB2YXIgY2h1bmtlZEJvdW5kc1NpemUgPSByZWYuY2h1bmtlZEJvdW5kc1NpemU7IGlmICggY2h1bmtlZEJvdW5kc1NpemUgPT09IHZvaWQgMCApIGNodW5rZWRCb3VuZHNTaXplID0gODE5MjtcbiAgICAgIHZhciBjb2xvclJhbmdlcyA9IHJlZi5jb2xvclJhbmdlczsgaWYgKCBjb2xvclJhbmdlcyA9PT0gdm9pZCAwICkgY29sb3JSYW5nZXMgPSBudWxsO1xuICAgICAgaWYgKCBtZXRyaWNzT25seSA9PT0gdm9pZCAwICkgbWV0cmljc09ubHk9ZmFsc2U7XG5cbiAgICAgIHZhciBtYWluU3RhcnQgPSBub3coKTtcbiAgICAgIHZhciB0aW1pbmdzID0ge3RvdGFsOiAwLCBmb250TG9hZDogMCwgbGF5b3V0OiAwLCBzZGY6IHt9LCBzZGZUb3RhbDogMH07XG5cbiAgICAgIC8vIEVuc3VyZSBuZXdsaW5lcyBhcmUgbm9ybWFsaXplZFxuICAgICAgaWYgKHRleHQuaW5kZXhPZignXFxyJykgPiAtMSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0ZvbnRQcm9jZXNzb3IucHJvY2VzczogZ290IHRleHQgd2l0aCBcXFxcciBjaGFyczsgbm9ybWFsaXppbmcgdG8gXFxcXG4nKTtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxyXFxuL2csICdcXG4nKS5yZXBsYWNlKC9cXHIvZywgJ1xcbicpO1xuICAgICAgfVxuXG4gICAgICAvLyBFbnN1cmUgd2UndmUgZ290IG51bWJlcnMgbm90IHN0cmluZ3NcbiAgICAgIGZvbnRTaXplID0gK2ZvbnRTaXplO1xuICAgICAgbGV0dGVyU3BhY2luZyA9ICtsZXR0ZXJTcGFjaW5nO1xuICAgICAgbWF4V2lkdGggPSArbWF4V2lkdGg7XG4gICAgICBsaW5lSGVpZ2h0ID0gbGluZUhlaWdodCB8fCAnbm9ybWFsJztcbiAgICAgIHRleHRJbmRlbnQgPSArdGV4dEluZGVudDtcblxuICAgICAgZ2V0U2RmQXRsYXMoZm9udCwgc2RmR2x5cGhTaXplLCBmdW5jdGlvbiAoYXRsYXMpIHtcbiAgICAgICAgdmFyIGZvbnRPYmogPSBhdGxhcy5mb250T2JqO1xuICAgICAgICB2YXIgaGFzTWF4V2lkdGggPSBpc0Zpbml0ZShtYXhXaWR0aCk7XG4gICAgICAgIHZhciBuZXdHbHlwaHMgPSBudWxsO1xuICAgICAgICB2YXIgZ2x5cGhCb3VuZHMgPSBudWxsO1xuICAgICAgICB2YXIgZ2x5cGhBdGxhc0luZGljZXMgPSBudWxsO1xuICAgICAgICB2YXIgZ2x5cGhDb2xvcnMgPSBudWxsO1xuICAgICAgICB2YXIgY2FyZXRQb3NpdGlvbnMgPSBudWxsO1xuICAgICAgICB2YXIgdG90YWxCb3VuZHMgPSBudWxsO1xuICAgICAgICB2YXIgY2h1bmtlZEJvdW5kcyA9IG51bGw7XG4gICAgICAgIHZhciBtYXhMaW5lV2lkdGggPSAwO1xuICAgICAgICB2YXIgcmVuZGVyYWJsZUdseXBoQ291bnQgPSAwO1xuICAgICAgICB2YXIgY2FuV3JhcCA9IHdoaXRlU3BhY2UgIT09ICdub3dyYXAnO1xuICAgICAgICB2YXIgYXNjZW5kZXIgPSBmb250T2JqLmFzY2VuZGVyO1xuICAgICAgICB2YXIgZGVzY2VuZGVyID0gZm9udE9iai5kZXNjZW5kZXI7XG4gICAgICAgIHZhciB1bml0c1BlckVtID0gZm9udE9iai51bml0c1BlckVtO1xuICAgICAgICB0aW1pbmdzLmZvbnRMb2FkID0gbm93KCkgLSBtYWluU3RhcnQ7XG4gICAgICAgIHZhciBsYXlvdXRTdGFydCA9IG5vdygpO1xuXG4gICAgICAgIC8vIEZpbmQgY29udmVyc2lvbiBiZXR3ZWVuIG5hdGl2ZSBmb250IHVuaXRzIGFuZCBmb250U2l6ZSB1bml0czsgdGhpcyB3aWxsIGFscmVhZHkgYmUgZG9uZVxuICAgICAgICAvLyBmb3IgdGhlIGd4L2d5IHZhbHVlcyBiZWxvdyBidXQgZXZlcnl0aGluZyBlbHNlIHdlJ2xsIG5lZWQgdG8gY29udmVydFxuICAgICAgICB2YXIgZm9udFNpemVNdWx0ID0gZm9udFNpemUgLyB1bml0c1BlckVtO1xuXG4gICAgICAgIC8vIERldGVybWluZSBhcHByb3ByaWF0ZSB2YWx1ZSBmb3IgJ25vcm1hbCcgbGluZSBoZWlnaHQgYmFzZWQgb24gdGhlIGZvbnQncyBhY3R1YWwgbWV0cmljc1xuICAgICAgICAvLyBUT0RPIHRoaXMgZG9lcyBub3QgZ3VhcmFudGVlIGluZGl2aWR1YWwgZ2x5cGhzIHdvbid0IGV4Y2VlZCB0aGUgbGluZSBoZWlnaHQsIGUuZy4gUm9ib3RvOyBzaG91bGQgd2UgdXNlIHlNaW4vTWF4IGluc3RlYWQ/XG4gICAgICAgIGlmIChsaW5lSGVpZ2h0ID09PSAnbm9ybWFsJykge1xuICAgICAgICAgIGxpbmVIZWlnaHQgPSAoYXNjZW5kZXIgLSBkZXNjZW5kZXIpIC8gdW5pdHNQZXJFbTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZSBsaW5lIGhlaWdodCBhbmQgbGVhZGluZyBhZGp1c3RtZW50c1xuICAgICAgICBsaW5lSGVpZ2h0ID0gbGluZUhlaWdodCAqIGZvbnRTaXplO1xuICAgICAgICB2YXIgaGFsZkxlYWRpbmcgPSAobGluZUhlaWdodCAtIChhc2NlbmRlciAtIGRlc2NlbmRlcikgKiBmb250U2l6ZU11bHQpIC8gMjtcbiAgICAgICAgdmFyIHRvcEJhc2VsaW5lID0gLShmb250U2l6ZSArIGhhbGZMZWFkaW5nKTtcbiAgICAgICAgdmFyIGNhcmV0SGVpZ2h0ID0gTWF0aC5taW4obGluZUhlaWdodCwgKGFzY2VuZGVyIC0gZGVzY2VuZGVyKSAqIGZvbnRTaXplTXVsdCk7XG4gICAgICAgIHZhciBjYXJldEJvdHRvbU9mZnNldCA9IChhc2NlbmRlciArIGRlc2NlbmRlcikgLyAyICogZm9udFNpemVNdWx0IC0gY2FyZXRIZWlnaHQgLyAyO1xuXG4gICAgICAgIC8vIERpc3RyaWJ1dGUgZ2x5cGhzIGludG8gbGluZXMgYmFzZWQgb24gd3JhcHBpbmdcbiAgICAgICAgdmFyIGxpbmVYT2Zmc2V0ID0gdGV4dEluZGVudDtcbiAgICAgICAgdmFyIGN1cnJlbnRMaW5lID0gbmV3IFRleHRMaW5lKCk7XG4gICAgICAgIHZhciBsaW5lcyA9IFtjdXJyZW50TGluZV07XG4gICAgICAgIGZvbnRPYmouZm9yRWFjaEdseXBoKHRleHQsIGZvbnRTaXplLCBsZXR0ZXJTcGFjaW5nLCBmdW5jdGlvbiAoZ2x5cGhPYmosIGdseXBoWCwgY2hhckluZGV4KSB7XG4gICAgICAgICAgdmFyIGNoYXIgPSB0ZXh0LmNoYXJBdChjaGFySW5kZXgpO1xuICAgICAgICAgIHZhciBnbHlwaFdpZHRoID0gZ2x5cGhPYmouYWR2YW5jZVdpZHRoICogZm9udFNpemVNdWx0O1xuICAgICAgICAgIHZhciBjdXJMaW5lQ291bnQgPSBjdXJyZW50TGluZS5jb3VudDtcbiAgICAgICAgICB2YXIgbmV4dExpbmU7XG5cbiAgICAgICAgICAvLyBDYWxjIGlzV2hpdGVzcGFjZSBhbmQgaXNFbXB0eSBvbmNlIHBlciBnbHlwaE9ialxuICAgICAgICAgIGlmICghKCdpc0VtcHR5JyBpbiBnbHlwaE9iaikpIHtcbiAgICAgICAgICAgIGdseXBoT2JqLmlzV2hpdGVzcGFjZSA9ICEhY2hhciAmJiAvXFxzLy50ZXN0KGNoYXIpO1xuICAgICAgICAgICAgZ2x5cGhPYmouaXNFbXB0eSA9IGdseXBoT2JqLnhNaW4gPT09IGdseXBoT2JqLnhNYXggfHwgZ2x5cGhPYmoueU1pbiA9PT0gZ2x5cGhPYmoueU1heDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFnbHlwaE9iai5pc1doaXRlc3BhY2UgJiYgIWdseXBoT2JqLmlzRW1wdHkpIHtcbiAgICAgICAgICAgIHJlbmRlcmFibGVHbHlwaENvdW50Kys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgYSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXIgb3ZlcmZsb3dzIHRoZSBtYXggd2lkdGgsIHdlIG5lZWQgdG8gc29mdC13cmFwXG4gICAgICAgICAgaWYgKGNhbldyYXAgJiYgaGFzTWF4V2lkdGggJiYgIWdseXBoT2JqLmlzV2hpdGVzcGFjZSAmJiBnbHlwaFggKyBnbHlwaFdpZHRoICsgbGluZVhPZmZzZXQgPiBtYXhXaWR0aCAmJiBjdXJMaW5lQ291bnQpIHtcbiAgICAgICAgICAgIC8vIElmIGl0J3MgdGhlIGZpcnN0IGNoYXIgYWZ0ZXIgYSB3aGl0ZXNwYWNlLCBzdGFydCBhIG5ldyBsaW5lXG4gICAgICAgICAgICBpZiAoY3VycmVudExpbmUuZ2x5cGhBdChjdXJMaW5lQ291bnQgLSAxKS5nbHlwaE9iai5pc1doaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgbmV4dExpbmUgPSBuZXcgVGV4dExpbmUoKTtcbiAgICAgICAgICAgICAgbGluZVhPZmZzZXQgPSAtZ2x5cGhYO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gQmFjayB1cCBsb29raW5nIGZvciBhIHdoaXRlc3BhY2UgY2hhcmFjdGVyIHRvIHdyYXAgYXRcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGN1ckxpbmVDb3VudDsgaS0tOykge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGdvdCB0aGUgc3RhcnQgb2YgdGhlIGxpbmUgdGhlcmUncyBubyBzb2Z0IGJyZWFrIHBvaW50OyBtYWtlIGhhcmQgYnJlYWsgaWYgb3ZlcmZsb3dXcmFwPSdicmVhay13b3JkJ1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAwICYmIG92ZXJmbG93V3JhcCA9PT0gJ2JyZWFrLXdvcmQnKSB7XG4gICAgICAgICAgICAgICAgICBuZXh0TGluZSA9IG5ldyBUZXh0TGluZSgpO1xuICAgICAgICAgICAgICAgICAgbGluZVhPZmZzZXQgPSAtZ2x5cGhYO1xuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRm91bmQgYSBzb2Z0IGJyZWFrIHBvaW50OyBtb3ZlIGFsbCBjaGFycyBzaW5jZSBpdCB0byBhIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudExpbmUuZ2x5cGhBdChpKS5nbHlwaE9iai5pc1doaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgIG5leHRMaW5lID0gY3VycmVudExpbmUuc3BsaXRBdChpICsgMSk7XG4gICAgICAgICAgICAgICAgICB2YXIgYWRqdXN0WCA9IG5leHRMaW5lLmdseXBoQXQoMCkueDtcbiAgICAgICAgICAgICAgICAgIGxpbmVYT2Zmc2V0IC09IGFkanVzdFg7XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gbmV4dExpbmUuY291bnQ7IGotLTspIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dExpbmUuZ2x5cGhBdChqKS54IC09IGFkanVzdFg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHRMaW5lKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRMaW5lLmlzU29mdFdyYXBwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBjdXJyZW50TGluZSA9IG5leHRMaW5lO1xuICAgICAgICAgICAgICBsaW5lcy5wdXNoKGN1cnJlbnRMaW5lKTtcbiAgICAgICAgICAgICAgbWF4TGluZVdpZHRoID0gbWF4V2lkdGg7IC8vYWZ0ZXIgc29mdCB3cmFwcGluZyB1c2UgbWF4V2lkdGggYXMgY2FsY3VsYXRlZCB3aWR0aFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBmbHkgPSBjdXJyZW50TGluZS5nbHlwaEF0KGN1cnJlbnRMaW5lLmNvdW50KTtcbiAgICAgICAgICBmbHkuZ2x5cGhPYmogPSBnbHlwaE9iajtcbiAgICAgICAgICBmbHkueCA9IGdseXBoWCArIGxpbmVYT2Zmc2V0O1xuICAgICAgICAgIGZseS53aWR0aCA9IGdseXBoV2lkdGg7XG4gICAgICAgICAgZmx5LmNoYXJJbmRleCA9IGNoYXJJbmRleDtcblxuICAgICAgICAgIC8vIEhhbmRsZSBoYXJkIGxpbmUgYnJlYWtzXG4gICAgICAgICAgaWYgKGNoYXIgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICBjdXJyZW50TGluZSA9IG5ldyBUZXh0TGluZSgpO1xuICAgICAgICAgICAgbGluZXMucHVzaChjdXJyZW50TGluZSk7XG4gICAgICAgICAgICBsaW5lWE9mZnNldCA9IC0oZ2x5cGhYICsgZ2x5cGhXaWR0aCArIChsZXR0ZXJTcGFjaW5nICogZm9udFNpemUpKSArIHRleHRJbmRlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgd2lkdGggb2YgZWFjaCBsaW5lIChleGNsdWRpbmcgdHJhaWxpbmcgd2hpdGVzcGFjZSkgYW5kIG1heGltdW0gYmxvY2sgd2lkdGhcbiAgICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSBsaW5lLmNvdW50OyBpLS07KSB7XG4gICAgICAgICAgICB2YXIgcmVmID0gbGluZS5nbHlwaEF0KGkpO1xuICAgICAgICAgICAgdmFyIGdseXBoT2JqID0gcmVmLmdseXBoT2JqO1xuICAgICAgICAgICAgdmFyIHggPSByZWYueDtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHJlZi53aWR0aDtcbiAgICAgICAgICAgIGlmICghZ2x5cGhPYmouaXNXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgICAgIGxpbmUud2lkdGggPSB4ICsgd2lkdGg7XG4gICAgICAgICAgICAgIGlmIChsaW5lLndpZHRoID4gbWF4TGluZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgbWF4TGluZVdpZHRoID0gbGluZS53aWR0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghbWV0cmljc09ubHkpIHtcbiAgICAgICAgICAvLyBGaW5kIG92ZXJhbGwgcG9zaXRpb24gYWRqdXN0bWVudHMgZm9yIGFuY2hvcmluZ1xuICAgICAgICAgIHZhciBhbmNob3JYT2Zmc2V0ID0gMDtcbiAgICAgICAgICB2YXIgYW5jaG9yWU9mZnNldCA9IDA7XG4gICAgICAgICAgaWYgKGFuY2hvclgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYW5jaG9yWCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgYW5jaG9yWE9mZnNldCA9IC1hbmNob3JYO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFuY2hvclggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGFuY2hvclhPZmZzZXQgPSAtbWF4TGluZVdpZHRoICogKFxuICAgICAgICAgICAgICAgIGFuY2hvclggPT09ICdsZWZ0JyA/IDAgOlxuICAgICAgICAgICAgICAgIGFuY2hvclggPT09ICdjZW50ZXInID8gMC41IDpcbiAgICAgICAgICAgICAgICBhbmNob3JYID09PSAncmlnaHQnID8gMSA6XG4gICAgICAgICAgICAgICAgcGFyc2VQZXJjZW50KGFuY2hvclgpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhbmNob3JZKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFuY2hvclkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgIGFuY2hvcllPZmZzZXQgPSAtYW5jaG9yWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhbmNob3JZID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gbGluZXMubGVuZ3RoICogbGluZUhlaWdodDtcbiAgICAgICAgICAgICAgYW5jaG9yWU9mZnNldCA9IGFuY2hvclkgPT09ICd0b3AnID8gMCA6XG4gICAgICAgICAgICAgICAgYW5jaG9yWSA9PT0gJ3RvcC1iYXNlbGluZScgPyAtdG9wQmFzZWxpbmUgOlxuICAgICAgICAgICAgICAgIGFuY2hvclkgPT09ICdtaWRkbGUnID8gaGVpZ2h0IC8gMiA6XG4gICAgICAgICAgICAgICAgYW5jaG9yWSA9PT0gJ2JvdHRvbScgPyBoZWlnaHQgOlxuICAgICAgICAgICAgICAgIGFuY2hvclkgPT09ICdib3R0b20tYmFzZWxpbmUnID8gaGVpZ2h0IC0gaGFsZkxlYWRpbmcgKyBkZXNjZW5kZXIgKiBmb250U2l6ZU11bHQgOlxuICAgICAgICAgICAgICAgIHBhcnNlUGVyY2VudChhbmNob3JZKSAqIGhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBQcm9jZXNzIGVhY2ggbGluZSwgYXBwbHlpbmcgYWxpZ25tZW50IG9mZnNldHMsIGFkZGluZyBlYWNoIGdseXBoIHRvIHRoZSBhdGxhcywgYW5kXG4gICAgICAgICAgLy8gY29sbGVjdGluZyBhbGwgcmVuZGVyYWJsZSBnbHlwaHMgaW50byBhIHNpbmdsZSBjb2xsZWN0aW9uLlxuICAgICAgICAgIGdseXBoQm91bmRzID0gbmV3IEZsb2F0MzJBcnJheShyZW5kZXJhYmxlR2x5cGhDb3VudCAqIDQpO1xuICAgICAgICAgIGdseXBoQXRsYXNJbmRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShyZW5kZXJhYmxlR2x5cGhDb3VudCk7XG4gICAgICAgICAgdG90YWxCb3VuZHMgPSBbSU5GLCBJTkYsIC1JTkYsIC1JTkZdO1xuICAgICAgICAgIGNodW5rZWRCb3VuZHMgPSBbXTtcbiAgICAgICAgICB2YXIgbGluZVlPZmZzZXQgPSB0b3BCYXNlbGluZTtcbiAgICAgICAgICBpZiAoaW5jbHVkZUNhcmV0UG9zaXRpb25zKSB7XG4gICAgICAgICAgICBjYXJldFBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkodGV4dC5sZW5ndGggKiAzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbG9yUmFuZ2VzKSB7XG4gICAgICAgICAgICBnbHlwaENvbG9ycyA9IG5ldyBVaW50OEFycmF5KHJlbmRlcmFibGVHbHlwaENvdW50ICogMyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZW5kZXJhYmxlR2x5cGhJbmRleCA9IDA7XG4gICAgICAgICAgdmFyIHByZXZDaGFySW5kZXggPSAtMTtcbiAgICAgICAgICB2YXIgY29sb3JDaGFySW5kZXggPSAtMTtcbiAgICAgICAgICB2YXIgY2h1bms7XG4gICAgICAgICAgdmFyIGN1cnJlbnRDb2xvcjtcbiAgICAgICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICB2YXIgbGluZUdseXBoQ291bnQgPSBsaW5lLmNvdW50O1xuICAgICAgICAgICAgdmFyIGxpbmVXaWR0aCA9IGxpbmUud2lkdGg7XG5cbiAgICAgICAgICAgIC8vIElnbm9yZSBlbXB0eSBsaW5lc1xuICAgICAgICAgICAgaWYgKGxpbmVHbHlwaENvdW50ID4gMCkge1xuICAgICAgICAgICAgICAvLyBGaW5kIHggb2Zmc2V0IGZvciBob3Jpem9udGFsIGFsaWdubWVudFxuICAgICAgICAgICAgICB2YXIgbGluZVhPZmZzZXQgPSAwO1xuICAgICAgICAgICAgICB2YXIganVzdGlmeUFkanVzdCA9IDA7XG4gICAgICAgICAgICAgIGlmICh0ZXh0QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICAgICAgbGluZVhPZmZzZXQgPSAobWF4TGluZVdpZHRoIC0gbGluZVdpZHRoKSAvIDI7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGV4dEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAgICAgbGluZVhPZmZzZXQgPSBtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGg7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGV4dEFsaWduID09PSAnanVzdGlmeScgJiYgbGluZS5pc1NvZnRXcmFwcGVkKSB7XG4gICAgICAgICAgICAgICAgLy8ganVzdCBjb3VudCB0aGUgbm9uLXRyYWlsaW5nIHdoaXRlc3BhY2UgY2hhcmFjdGVycywgYW5kIHdlJ2xsIGFkanVzdCB0aGUgb2Zmc2V0cyBwZXJcbiAgICAgICAgICAgICAgICAvLyBjaGFyYWN0ZXIgaW4gdGhlIG5leHQgbG9vcFxuICAgICAgICAgICAgICAgIHZhciB3aGl0ZXNwYWNlQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBsaW5lR2x5cGhDb3VudDsgaS0tOykge1xuICAgICAgICAgICAgICAgICAgaWYgKCFsaW5lLmdseXBoQXQoaSkuZ2x5cGhPYmouaXNXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxpbmUuZ2x5cGhBdChpKS5nbHlwaE9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWdnZXJcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUuZ2x5cGhBdChpKS5nbHlwaE9iai5pc1doaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaXRlc3BhY2VDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBqdXN0aWZ5QWRqdXN0ID0gKG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aCkgLyB3aGl0ZXNwYWNlQ291bnQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBsaW5lR2x5cGhDb3VudDsgaSQxKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZ2x5cGhJbmZvID0gbGluZS5nbHlwaEF0KGkkMSk7XG4gICAgICAgICAgICAgICAgdmFyIGdseXBoT2JqID0gZ2x5cGhJbmZvLmdseXBoT2JqO1xuXG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgcG9zaXRpb24gYWRqdXN0bWVudHNcbiAgICAgICAgICAgICAgICBpZiAobGluZVhPZmZzZXQpIHsgZ2x5cGhJbmZvLnggKz0gbGluZVhPZmZzZXQ7IH1cblxuICAgICAgICAgICAgICAgIC8vIEV4cGFuZCB3aGl0ZXNwYWNlcyBmb3IganVzdGlmeSBhbGlnbm1lbnRcbiAgICAgICAgICAgICAgICBpZiAoanVzdGlmeUFkanVzdCAhPT0gMCAmJiBnbHlwaE9iai5pc1doaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgIGxpbmVYT2Zmc2V0ICs9IGp1c3RpZnlBZGp1c3Q7XG4gICAgICAgICAgICAgICAgICBnbHlwaEluZm8ud2lkdGggKz0ganVzdGlmeUFkanVzdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgY2FyZXQgcG9zaXRpb25zXG4gICAgICAgICAgICAgICAgaWYgKGluY2x1ZGVDYXJldFBvc2l0aW9ucykge1xuICAgICAgICAgICAgICAgICAgdmFyIGNoYXJJbmRleCA9IGdseXBoSW5mby5jaGFySW5kZXg7XG4gICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uc1tjaGFySW5kZXggKiAzXSA9IGdseXBoSW5mby54ICsgYW5jaG9yWE9mZnNldDsgLy9sZWZ0IGVkZ2UgeFxuICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbnNbY2hhckluZGV4ICogMyArIDFdID0gZ2x5cGhJbmZvLnggKyBnbHlwaEluZm8ud2lkdGggKyBhbmNob3JYT2Zmc2V0OyAvL3JpZ2h0IGVkZ2UgeFxuICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbnNbY2hhckluZGV4ICogMyArIDJdID0gbGluZVlPZmZzZXQgKyBjYXJldEJvdHRvbU9mZnNldCArIGFuY2hvcllPZmZzZXQ7IC8vY29tbW9uIGJvdHRvbSB5XG5cbiAgICAgICAgICAgICAgICAgIC8vIElmIHdlIHNraXBwZWQgYW55IGNoYXJzIGZyb20gdGhlIHByZXZpb3VzIGdseXBoIChkdWUgdG8gbGlnYXR1cmUgc3VicyksIGNvcHkgdGhlXG4gICAgICAgICAgICAgICAgICAvLyBwcmV2aW91cyBnbHlwaCdzIGluZm8gdG8gdGhvc2UgbWlzc2luZyBjaGFyIGluZGljZXMuIEluIHRoZSBmdXR1cmUgd2UgbWF5IHRyeSB0b1xuICAgICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBmb250J3MgTGlnYXR1cmVDYXJldExpc3QgdGFibGUgdG8gZ2V0IGludGVyaW9yIGNhcmV0IHBvc2l0aW9ucy5cbiAgICAgICAgICAgICAgICAgIHdoaWxlIChjaGFySW5kZXggLSBwcmV2Q2hhckluZGV4ID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uc1socHJldkNoYXJJbmRleCArIDEpICogM10gPSBjYXJldFBvc2l0aW9uc1twcmV2Q2hhckluZGV4ICogMyArIDFdO1xuICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uc1socHJldkNoYXJJbmRleCArIDEpICogMyArIDFdID0gY2FyZXRQb3NpdGlvbnNbcHJldkNoYXJJbmRleCAqIDMgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbnNbKHByZXZDaGFySW5kZXggKyAxKSAqIDMgKyAyXSA9IGNhcmV0UG9zaXRpb25zW3ByZXZDaGFySW5kZXggKiAzICsgMl07XG4gICAgICAgICAgICAgICAgICAgIHByZXZDaGFySW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHByZXZDaGFySW5kZXggPSBjaGFySW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVHJhY2sgY3VycmVudCBjb2xvciByYW5nZVxuICAgICAgICAgICAgICAgIGlmIChjb2xvclJhbmdlcykge1xuICAgICAgICAgICAgICAgICAgdmFyIGNoYXJJbmRleCQxID0gZ2x5cGhJbmZvLmNoYXJJbmRleDtcbiAgICAgICAgICAgICAgICAgIHdoaWxlKGNoYXJJbmRleCQxID4gY29sb3JDaGFySW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JDaGFySW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG9yUmFuZ2VzLmhhc093blByb3BlcnR5KGNvbG9yQ2hhckluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb2xvciA9IGNvbG9yUmFuZ2VzW2NvbG9yQ2hhckluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEdldCBhdGxhcyBkYXRhIGZvciByZW5kZXJhYmxlIGdseXBoc1xuICAgICAgICAgICAgICAgIGlmICghZ2x5cGhPYmouaXNXaGl0ZXNwYWNlICYmICFnbHlwaE9iai5pc0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gcmVuZGVyYWJsZUdseXBoSW5kZXgrKztcblxuICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZW4ndCBzZWVuIHRoaXMgZ2x5cGggeWV0LCBnZW5lcmF0ZSBpdHMgU0RGXG4gICAgICAgICAgICAgICAgICB2YXIgZ2x5cGhBdGxhc0luZm8gPSBhdGxhcy5nbHlwaHNbZ2x5cGhPYmouaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgaWYgKCFnbHlwaEF0bGFzSW5mbykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2RmU3RhcnQgPSBub3coKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdseXBoU0RGRGF0YSA9IHNkZkdlbmVyYXRvcihnbHlwaE9iaiwgc2RmR2x5cGhTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgdGltaW5ncy5zZGZbdGV4dC5jaGFyQXQoZ2x5cGhJbmZvLmNoYXJJbmRleCldID0gbm93KCkgLSBzZGZTdGFydDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBc3NpZ24gdGhpcyBnbHlwaCB0aGUgbmV4dCBhdmFpbGFibGUgYXRsYXMgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgZ2x5cGhTREZEYXRhLmF0bGFzSW5kZXggPSBhdGxhcy5nbHlwaENvdW50Kys7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUXVldWUgaXQgdXAgaW4gdGhlIHJlc3BvbnNlJ3MgbmV3R2x5cGhzIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdHbHlwaHMpIHsgbmV3R2x5cGhzID0gW107IH1cbiAgICAgICAgICAgICAgICAgICAgbmV3R2x5cGhzLnB1c2goZ2x5cGhTREZEYXRhKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTdG9yZSBpdHMgbWV0YWRhdGEgKG5vdCB0aGUgdGV4dHVyZSkgaW4gb3VyIGF0bGFzIGluZm9cbiAgICAgICAgICAgICAgICAgICAgZ2x5cGhBdGxhc0luZm8gPSBhdGxhcy5nbHlwaHNbZ2x5cGhPYmouaW5kZXhdID0ge1xuICAgICAgICAgICAgICAgICAgICAgIGF0bGFzSW5kZXg6IGdseXBoU0RGRGF0YS5hdGxhc0luZGV4LFxuICAgICAgICAgICAgICAgICAgICAgIGdseXBoT2JqOiBnbHlwaE9iaixcbiAgICAgICAgICAgICAgICAgICAgICByZW5kZXJpbmdCb3VuZHM6IGdseXBoU0RGRGF0YS5yZW5kZXJpbmdCb3VuZHNcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGZpbmFsIGdseXBoIGJvdW5kcyBhbmQgYWRkIHRoZW0gdG8gdGhlIGdseXBoQm91bmRzIGFycmF5XG4gICAgICAgICAgICAgICAgICB2YXIgYm91bmRzID0gZ2x5cGhBdGxhc0luZm8ucmVuZGVyaW5nQm91bmRzO1xuICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gaWR4ICogNDtcbiAgICAgICAgICAgICAgICAgIHZhciB4MCA9IGdseXBoQm91bmRzW3N0YXJ0XSA9IGdseXBoSW5mby54ICsgYm91bmRzWzBdICogZm9udFNpemVNdWx0ICsgYW5jaG9yWE9mZnNldDtcbiAgICAgICAgICAgICAgICAgIHZhciB5MCA9IGdseXBoQm91bmRzW3N0YXJ0ICsgMV0gPSBsaW5lWU9mZnNldCArIGJvdW5kc1sxXSAqIGZvbnRTaXplTXVsdCArIGFuY2hvcllPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICB2YXIgeDEgPSBnbHlwaEJvdW5kc1tzdGFydCArIDJdID0gZ2x5cGhJbmZvLnggKyBib3VuZHNbMl0gKiBmb250U2l6ZU11bHQgKyBhbmNob3JYT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgdmFyIHkxID0gZ2x5cGhCb3VuZHNbc3RhcnQgKyAzXSA9IGxpbmVZT2Zmc2V0ICsgYm91bmRzWzNdICogZm9udFNpemVNdWx0ICsgYW5jaG9yWU9mZnNldDtcblxuICAgICAgICAgICAgICAgICAgLy8gVHJhY2sgdG90YWwgYm91bmRzXG4gICAgICAgICAgICAgICAgICBpZiAoeDAgPCB0b3RhbEJvdW5kc1swXSkgeyB0b3RhbEJvdW5kc1swXSA9IHgwOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoeTAgPCB0b3RhbEJvdW5kc1sxXSkgeyB0b3RhbEJvdW5kc1sxXSA9IHkwOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoeDEgPiB0b3RhbEJvdW5kc1syXSkgeyB0b3RhbEJvdW5kc1syXSA9IHgxOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoeTEgPiB0b3RhbEJvdW5kc1szXSkgeyB0b3RhbEJvdW5kc1szXSA9IHkxOyB9XG5cbiAgICAgICAgICAgICAgICAgIC8vIFRyYWNrIGJvdW5kaW5nIHJlY3RzIGZvciBlYWNoIGNodW5rIG9mIE4gZ2x5cGhzXG4gICAgICAgICAgICAgICAgICBpZiAoaWR4ICUgY2h1bmtlZEJvdW5kc1NpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsgPSB7c3RhcnQ6IGlkeCwgZW5kOiBpZHgsIHJlY3Q6IFtJTkYsIElORiwgLUlORiwgLUlORl19O1xuICAgICAgICAgICAgICAgICAgICBjaHVua2VkQm91bmRzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY2h1bmsuZW5kKys7XG4gICAgICAgICAgICAgICAgICBpZiAoeDAgPCBjaHVuay5yZWN0WzBdKSB7IGNodW5rLnJlY3RbMF0gPSB4MDsgfVxuICAgICAgICAgICAgICAgICAgaWYgKHkwIDwgY2h1bmsucmVjdFsxXSkgeyBjaHVuay5yZWN0WzFdID0geTA7IH1cbiAgICAgICAgICAgICAgICAgIGlmICh4MSA+IGNodW5rLnJlY3RbMl0pIHsgY2h1bmsucmVjdFsyXSA9IHgxOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoeTEgPiBjaHVuay5yZWN0WzNdKSB7IGNodW5rLnJlY3RbM10gPSB5MTsgfVxuXG4gICAgICAgICAgICAgICAgICAvLyBBZGQgdG8gYXRsYXMgaW5kaWNlcyBhcnJheVxuICAgICAgICAgICAgICAgICAgZ2x5cGhBdGxhc0luZGljZXNbaWR4XSA9IGdseXBoQXRsYXNJbmZvLmF0bGFzSW5kZXg7XG5cbiAgICAgICAgICAgICAgICAgIC8vIEFkZCBjb2xvcnNcbiAgICAgICAgICAgICAgICAgIGlmIChjb2xvclJhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQkMSA9IGlkeCAqIDM7XG4gICAgICAgICAgICAgICAgICAgIGdseXBoQ29sb3JzW3N0YXJ0JDFdID0gY3VycmVudENvbG9yID4+IDE2ICYgMjU1O1xuICAgICAgICAgICAgICAgICAgICBnbHlwaENvbG9yc1tzdGFydCQxICsgMV0gPSBjdXJyZW50Q29sb3IgPj4gOCAmIDI1NTtcbiAgICAgICAgICAgICAgICAgICAgZ2x5cGhDb2xvcnNbc3RhcnQkMSArIDJdID0gY3VycmVudENvbG9yICYgMjU1O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJbmNyZW1lbnQgeSBvZmZzZXQgZm9yIG5leHQgbGluZVxuICAgICAgICAgICAgbGluZVlPZmZzZXQgLT0gbGluZUhlaWdodDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRpbWluZyBzdGF0c1xuICAgICAgICBmb3IgKHZhciBjaCBpbiB0aW1pbmdzLnNkZikge1xuICAgICAgICAgIHRpbWluZ3Muc2RmVG90YWwgKz0gdGltaW5ncy5zZGZbY2hdO1xuICAgICAgICB9XG4gICAgICAgIHRpbWluZ3MubGF5b3V0ID0gbm93KCkgLSBsYXlvdXRTdGFydCAtIHRpbWluZ3Muc2RmVG90YWw7XG4gICAgICAgIHRpbWluZ3MudG90YWwgPSBub3coKSAtIG1haW5TdGFydDtcblxuICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgZ2x5cGhCb3VuZHM6IGdseXBoQm91bmRzLCAvL3JlbmRlcmluZyBxdWFkIGJvdW5kcyBmb3IgZWFjaCBnbHlwaCBbeDEsIHkxLCB4MiwgeTJdXG4gICAgICAgICAgZ2x5cGhBdGxhc0luZGljZXM6IGdseXBoQXRsYXNJbmRpY2VzLCAvL2F0bGFzIGluZGljZXMgZm9yIGVhY2ggZ2x5cGhcbiAgICAgICAgICBjYXJldFBvc2l0aW9uczogY2FyZXRQb3NpdGlvbnMsIC8veCx5IG9mIGJvdHRvbSBvZiBjdXJzb3IgcG9zaXRpb24gYmVmb3JlIGVhY2ggY2hhciwgcGx1cyBvbmUgYWZ0ZXIgbGFzdCBjaGFyXG4gICAgICAgICAgY2FyZXRIZWlnaHQ6IGNhcmV0SGVpZ2h0LCAvL2hlaWdodCBvZiBjdXJzb3IgZnJvbSBib3R0b20gdG8gdG9wXG4gICAgICAgICAgZ2x5cGhDb2xvcnM6IGdseXBoQ29sb3JzLCAvL2NvbG9yIGZvciBlYWNoIGdseXBoLCBpZiBjb2xvciByYW5nZXMgc3VwcGxpZWRcbiAgICAgICAgICBjaHVua2VkQm91bmRzOiBjaHVua2VkQm91bmRzLCAvL3RvdGFsIHJlY3RzIHBlciAobj1jaHVua2VkQm91bmRzU2l6ZSkgY29uc2VjdXRpdmUgZ2x5cGhzXG4gICAgICAgICAgYXNjZW5kZXI6IGFzY2VuZGVyICogZm9udFNpemVNdWx0LCAvL2ZvbnQgYXNjZW5kZXJcbiAgICAgICAgICBkZXNjZW5kZXI6IGRlc2NlbmRlciAqIGZvbnRTaXplTXVsdCwgLy9mb250IGRlc2NlbmRlclxuICAgICAgICAgIGxpbmVIZWlnaHQ6IGxpbmVIZWlnaHQsIC8vY29tcHV0ZWQgbGluZSBoZWlnaHRcbiAgICAgICAgICB0b3BCYXNlbGluZTogdG9wQmFzZWxpbmUsIC8veSBjb29yZGluYXRlIG9mIHRoZSB0b3AgbGluZSdzIGJhc2VsaW5lXG4gICAgICAgICAgdG90YWxCb3VuZHM6IHRvdGFsQm91bmRzLCAvL3RvdGFsIHJlY3QgaW5jbHVkaW5nIGFsbCBnbHlwaEJvdW5kczsgd2lsbCBiZSBzbGlnaHRseSBsYXJnZXIgdGhhbiBnbHlwaCBlZGdlcyBkdWUgdG8gU0RGIHBhZGRpbmdcbiAgICAgICAgICB0b3RhbEJsb2NrU2l6ZTogW21heExpbmVXaWR0aCwgbGluZXMubGVuZ3RoICogbGluZUhlaWdodF0sIC8vd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgdGV4dCBibG9jazsgYWNjdXJhdGUgZm9yIGxheW91dCBtZWFzdXJlbWVudFxuICAgICAgICAgIG5ld0dseXBoU0RGczogbmV3R2x5cGhzLCAvL2lmIHRoaXMgcmVxdWVzdCBpbmNsdWRlZCBhbnkgbmV3IFNERnMgZm9yIHRoZSBhdGxhcywgdGhleSdsbCBiZSBpbmNsdWRlZCBoZXJlXG4gICAgICAgICAgdGltaW5nczogdGltaW5nc1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogRm9yIGEgZ2l2ZW4gdGV4dCBzdHJpbmcgYW5kIGZvbnQgcGFyYW1ldGVycywgZGV0ZXJtaW5lIHRoZSByZXN1bHRpbmcgYmxvY2sgZGltZW5zaW9uc1xuICAgICAqIGFmdGVyIHdyYXBwaW5nIGZvciB0aGUgZ2l2ZW4gbWF4V2lkdGguXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZWFzdXJlKGFyZ3MsIGNhbGxiYWNrKSB7XG4gICAgICBwcm9jZXNzKGFyZ3MsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgIHdpZHRoOiByZXN1bHQudG90YWxCbG9ja1NpemVbMF0sXG4gICAgICAgICAgaGVpZ2h0OiByZXN1bHQudG90YWxCbG9ja1NpemVbMV1cbiAgICAgICAgfSk7XG4gICAgICB9LCB7bWV0cmljc09ubHk6IHRydWV9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVBlcmNlbnQoc3RyKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2goL14oW1xcZC5dKyklJC8pO1xuICAgICAgdmFyIHBjdCA9IG1hdGNoID8gcGFyc2VGbG9hdChtYXRjaFsxXSkgOiBOYU47XG4gICAgICByZXR1cm4gaXNOYU4ocGN0KSA/IDAgOiBwY3QgLyAxMDBcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3coKSB7XG4gICAgICByZXR1cm4gKHNlbGYucGVyZm9ybWFuY2UgfHwgRGF0ZSkubm93KClcbiAgICB9XG5cbiAgICAvLyBBcnJheS1iYWNrZWQgc3RydWN0dXJlIGZvciBhIHNpbmdsZSBsaW5lJ3MgZ2x5cGhzIGRhdGFcbiAgICBmdW5jdGlvbiBUZXh0TGluZSgpIHtcbiAgICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgIH1cbiAgICBUZXh0TGluZS5wcm90b3R5cGUgPSB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGlzU29mdFdyYXBwZWQ6IGZhbHNlLFxuICAgICAgZ2V0IGNvdW50KCkge1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuZGF0YS5sZW5ndGggLyA0KVxuICAgICAgfSxcbiAgICAgIGdseXBoQXQ6IGZ1bmN0aW9uIGdseXBoQXQoaSkge1xuICAgICAgICB2YXIgZmx5ID0gVGV4dExpbmUuZmx5d2VpZ2h0O1xuICAgICAgICBmbHkuZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgZmx5LmluZGV4ID0gaTtcbiAgICAgICAgcmV0dXJuIGZseVxuICAgICAgfSxcbiAgICAgIHNwbGl0QXQ6IGZ1bmN0aW9uIHNwbGl0QXQoaSkge1xuICAgICAgICB2YXIgbmV3TGluZSA9IG5ldyBUZXh0TGluZSgpO1xuICAgICAgICBuZXdMaW5lLmRhdGEgPSB0aGlzLmRhdGEuc3BsaWNlKGkgKiA0KTtcbiAgICAgICAgcmV0dXJuIG5ld0xpbmVcbiAgICAgIH1cbiAgICB9O1xuICAgIFRleHRMaW5lLmZseXdlaWdodCA9IFsnZ2x5cGhPYmonLCAneCcsICd3aWR0aCcsICdjaGFySW5kZXgnXS5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwgcHJvcCwgaSwgYWxsKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFbdGhpcy5pbmRleCAqIDQgKyBpXVxuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWwpIHtcbiAgICAgICAgICB0aGlzLmRhdGFbdGhpcy5pbmRleCAqIDQgKyBpXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gb2JqXG4gICAgfSwge2RhdGE6IG51bGwsIGluZGV4OiAwfSk7XG5cblxuICAgIHJldHVybiB7XG4gICAgICBwcm9jZXNzOiBwcm9jZXNzLFxuICAgICAgbWVhc3VyZTogbWVhc3VyZSxcbiAgICAgIGxvYWRGb250OiBsb2FkRm9udFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBCYXNpYyBxdWFkdHJlZSBpbXBsIGZvciBwZXJmb3JtaW5nIGZhc3Qgc3BhdGlhbCBzZWFyY2hlcyBvZiBhIGdseXBoJ3MgbGluZSBzZWdtZW50cy5cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUdseXBoU2VnbWVudHNRdWFkdHJlZShnbHlwaE9iaikge1xuICAgIC8vIFBpY2sgYSBnb29kIGluaXRpYWwgcG93ZXItb2YtdHdvIGJvdW5kaW5nIGJveCB0aGF0IHdpbGwgaG9sZCBhbGwgcG9zc2libGUgc2VnbWVudHNcbiAgICB2YXIgeE1pbiA9IGdseXBoT2JqLnhNaW47XG4gICAgdmFyIHlNaW4gPSBnbHlwaE9iai55TWluO1xuICAgIHZhciB4TWF4ID0gZ2x5cGhPYmoueE1heDtcbiAgICB2YXIgeU1heCA9IGdseXBoT2JqLnlNYXg7XG4gICAgdmFyIGR4ID0geE1heCAtIHhNaW47XG4gICAgdmFyIGR5ID0geU1heCAtIHlNaW47XG4gICAgdmFyIGN4ID0gTWF0aC5yb3VuZCh4TWluICsgZHggLyAyKTtcbiAgICB2YXIgY3kgPSBNYXRoLnJvdW5kKHlNaW4gKyBkeSAvIDIpO1xuICAgIHZhciByID0gTWF0aC5wb3coMiwgTWF0aC5mbG9vcihNYXRoLmxvZyhNYXRoLm1heChkeCwgZHkpKSAqIE1hdGguTE9HMkUpKTtcbiAgICB2YXIgSU5GID0gSW5maW5pdHk7XG5cbiAgICB2YXIgcm9vdCA9IHtcbiAgICAgIDA6IG51bGwsXG4gICAgICAxOiBudWxsLFxuICAgICAgMjogbnVsbCxcbiAgICAgIDM6IG51bGwsXG4gICAgICBkYXRhOiBudWxsLFxuICAgICAgY3g6IGN4LFxuICAgICAgY3k6IGN5LFxuICAgICAgcjogcixcbiAgICAgIG1pblg6IElORixcbiAgICAgIG1pblk6IElORixcbiAgICAgIG1heFg6IC1JTkYsXG4gICAgICBtYXhZOiAtSU5GXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIGxpbmUgc2VnbWVudCB0byB0aGUgcXVhZHRyZWUuXG4gICAgICogQHBhcmFtIHgwXG4gICAgICogQHBhcmFtIHkwXG4gICAgICogQHBhcmFtIHgxXG4gICAgICogQHBhcmFtIHkxXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkTGluZVNlZ21lbnQoeDAsIHkwLCB4MSwgeTEpIHtcbiAgICAgIHZhciBjeCA9ICh4MCArIHgxKSAvIDI7XG4gICAgICB2YXIgY3kgPSAoeTAgKyB5MSkgLyAyO1xuICAgICAgdmFyIHNlZ21lbnQgPSB7XG4gICAgICAgIHgwOiB4MCwgeTA6IHkwLCB4MTogeDEsIHkxOiB5MSwgY3g6IGN4LCBjeTogY3ksXG4gICAgICAgIG1pblg6IE1hdGgubWluKHgwLCB4MSksXG4gICAgICAgIG1pblk6IE1hdGgubWluKHkwLCB5MSksXG4gICAgICAgIG1heFg6IE1hdGgubWF4KHgwLCB4MSksXG4gICAgICAgIG1heFk6IE1hdGgubWF4KHkwLCB5MSksXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpbnNlcnRTZWdtZW50KHNlZ21lbnQsIHJvb3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc2VydFNlZ21lbnQoc2VnbWVudCwgbm9kZSkge1xuICAgICAgLy8gdXBkYXRlIG5vZGUgbWluL21heCBzdGF0c1xuICAgICAgdmFyIG1pblggPSBzZWdtZW50Lm1pblg7XG4gICAgICB2YXIgbWluWSA9IHNlZ21lbnQubWluWTtcbiAgICAgIHZhciBtYXhYID0gc2VnbWVudC5tYXhYO1xuICAgICAgdmFyIG1heFkgPSBzZWdtZW50Lm1heFk7XG4gICAgICB2YXIgY3ggPSBzZWdtZW50LmN4O1xuICAgICAgdmFyIGN5ID0gc2VnbWVudC5jeTtcbiAgICAgIGlmIChtaW5YIDwgbm9kZS5taW5YKSB7IG5vZGUubWluWCA9IG1pblg7IH1cbiAgICAgIGlmIChtaW5ZIDwgbm9kZS5taW5ZKSB7IG5vZGUubWluWSA9IG1pblk7IH1cbiAgICAgIGlmIChtYXhYID4gbm9kZS5tYXhYKSB7IG5vZGUubWF4WCA9IG1heFg7IH1cbiAgICAgIGlmIChtYXhZID4gbm9kZS5tYXhZKSB7IG5vZGUubWF4WSA9IG1heFk7IH1cblxuICAgICAgLy8gbGVhZlxuICAgICAgdmFyIGxlYWZTZWdtZW50ID0gbm9kZS5kYXRhO1xuICAgICAgaWYgKGxlYWZTZWdtZW50KSB7XG4gICAgICAgIC8vIGNvaW5jaWRlbnQ7IHB1c2ggYXMgbGlua2VkIGxpc3RcbiAgICAgICAgaWYgKGxlYWZTZWdtZW50LmN4ID09PSBjeCAmJiBsZWFmU2VnbWVudC5jeSA9PT0gY3kpIHtcbiAgICAgICAgICB3aGlsZSAobGVhZlNlZ21lbnQubmV4dCkgeyBsZWFmU2VnbWVudCA9IGxlYWZTZWdtZW50Lm5leHQ7IH1cbiAgICAgICAgICBsZWFmU2VnbWVudC5uZXh0ID0gc2VnbWVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyBub24tY29pbmNpZGVudDsgc3BsaXQgbGVhZiB0byBicmFuY2hcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbm9kZS5kYXRhID0gbnVsbDtcbiAgICAgICAgICBpbnNlcnRTZWdtZW50KGxlYWZTZWdtZW50LCBub2RlKTtcbiAgICAgICAgICBpbnNlcnRTZWdtZW50KHNlZ21lbnQsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBicmFuY2hcbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBmaW5kIHRhcmdldCBzdWItaW5kZXggZm9yIHRoZSBzZWdtZW50J3MgY2VudGVycG9pbnRcbiAgICAgICAgdmFyIHN1YkluZGV4ID0gKGN5IDwgbm9kZS5jeSA/IDAgOiAyKSArIChjeCA8IG5vZGUuY3ggPyAwIDogMSk7XG5cbiAgICAgICAgLy8gc3Vibm9kZSBhbHJlYWR5IGF0IGluZGV4OiByZWN1cnNlXG4gICAgICAgIGlmIChub2RlW3N1YkluZGV4XSkge1xuICAgICAgICAgIGluc2VydFNlZ21lbnQoc2VnbWVudCwgbm9kZVtzdWJJbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgbGVhZlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBub2RlW3N1YkluZGV4XSA9IHtcbiAgICAgICAgICAgIDA6IG51bGwsXG4gICAgICAgICAgICAxOiBudWxsLFxuICAgICAgICAgICAgMjogbnVsbCxcbiAgICAgICAgICAgIDM6IG51bGwsXG4gICAgICAgICAgICBkYXRhOiBzZWdtZW50LFxuICAgICAgICAgICAgY3g6IG5vZGUuY3ggKyBub2RlLnIgLyAyICogKHN1YkluZGV4ICUgMiA/IDEgOiAtMSksXG4gICAgICAgICAgICBjeTogbm9kZS5jeSArIG5vZGUuciAvIDIgKiAoc3ViSW5kZXggPCAyID8gLTEgOiAxKSxcbiAgICAgICAgICAgIHI6IG5vZGUuciAvIDIsXG4gICAgICAgICAgICBtaW5YOiBtaW5YLFxuICAgICAgICAgICAgbWluWTogbWluWSxcbiAgICAgICAgICAgIG1heFg6IG1heFgsXG4gICAgICAgICAgICBtYXhZOiBtYXhZXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdhbGtUcmVlKGNhbGxiYWNrKSB7XG4gICAgICB3YWxrQnJhbmNoKHJvb3QsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3YWxrQnJhbmNoKHJvb3QsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoY2FsbGJhY2socm9vdCkgIT09IGZhbHNlICYmICFyb290LmRhdGEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICBpZiAocm9vdFtpXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgd2Fsa0JyYW5jaChyb290W2ldLCBjYWxsYmFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yIGEgZ2l2ZW4geC95LCBzZWFyY2ggdGhlIHF1YWR0cmVlIGZvciB0aGUgY2xvc2VzdCBsaW5lIHNlZ21lbnQgYW5kIHJldHVyblxuICAgICAqIGl0cyBzaWduZWQgZGlzdGFuY2UuXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEBwYXJhbSBtYXhTZWFyY2hSYWRpdXNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmROZWFyZXN0U2lnbmVkRGlzdGFuY2UoeCwgeSwgbWF4U2VhcmNoUmFkaXVzKSB7XG4gICAgICB2YXIgY2xvc2VzdERpc3QgPSBtYXhTZWFyY2hSYWRpdXM7XG4gICAgICB2YXIgY2xvc2VzdERpc3RTcSA9IGNsb3Nlc3REaXN0ICogY2xvc2VzdERpc3Q7XG5cbiAgICAgIHdhbGtUcmVlKGZ1bmN0aW9uIHZpc2l0KG5vZGUpIHtcbiAgICAgICAgLy8gSWdub3JlIG5vZGVzIHRoYXQgY2FuJ3QgcG9zc2libHkgaGF2ZSBzZWdtZW50cyBjbG9zZXIgdGhhbiB3aGF0IHdlJ3ZlIGFscmVhZHkgZm91bmQuIFdlIGJhc2VcbiAgICAgICAgLy8gdGhpcyBvbiBhIHNpbXBsZSByZWN0IGJvdW5kcyBjaGVjazsgcmFkaWFsIHdvdWxkIGJlIG1vcmUgYWNjdXJhdGUgYnV0IG11Y2ggc2xvd2VyLlxuICAgICAgICBpZiAoXG4gICAgICAgICAgeCAtIGNsb3Nlc3REaXN0ID4gbm9kZS5tYXhYIHx8IHggKyBjbG9zZXN0RGlzdCA8IG5vZGUubWluWCB8fFxuICAgICAgICAgIHkgLSBjbG9zZXN0RGlzdCA+IG5vZGUubWF4WSB8fCB5ICsgY2xvc2VzdERpc3QgPCBub2RlLm1pbllcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBMZWFmIC0gY2hlY2sgZWFjaCBzZWdtZW50J3MgYWN0dWFsIGRpc3RhbmNlXG4gICAgICAgIGZvciAodmFyIHNlZ21lbnQgPSBub2RlLmRhdGE7IHNlZ21lbnQ7IHNlZ21lbnQgPSBzZWdtZW50Lm5leHQpIHtcbiAgICAgICAgICB2YXIgZGlzdFNxID0gYWJzU3F1YXJlRGlzdGFuY2VUb0xpbmVTZWdtZW50KHgsIHksIHNlZ21lbnQueDAsIHNlZ21lbnQueTAsIHNlZ21lbnQueDEsIHNlZ21lbnQueTEpO1xuICAgICAgICAgIGlmIChkaXN0U3EgPCBjbG9zZXN0RGlzdFNxKSB7XG4gICAgICAgICAgICBjbG9zZXN0RGlzdFNxID0gZGlzdFNxO1xuICAgICAgICAgICAgY2xvc2VzdERpc3QgPSBNYXRoLnNxcnQoZGlzdFNxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBGbGlwIHRvIG5lZ2F0aXZlIGRpc3RhbmNlIGlmIG91dHNpZGUgdGhlIHBvbHlcbiAgICAgIGlmICghaXNQb2ludEluUG9seSh4LCB5KSkge1xuICAgICAgICBjbG9zZXN0RGlzdCA9IC1jbG9zZXN0RGlzdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbG9zZXN0RGlzdFxuICAgIH1cblxuICAgIC8vIERldGVybWluZSB3aGV0aGVyIHRoZSBnaXZlbiBwb2ludCBsaWVzIGluc2lkZSBvciBvdXRzaWRlIHRoZSBnbHlwaC4gVXNlcyBhIHNpbXBsZVxuICAgIC8vIHJheSBjYXN0aW5nIGFsZ29yaXRobSB1c2luZyBhIHJheSBwb2ludGluZyBlYXN0IGZyb20gdGhlIHBvaW50LCBvcHRpbWl6ZWQgYnkgdXNpbmdcbiAgICAvLyB0aGUgcXVhZHRyZWUgc2VhcmNoIHRvIHRlc3QgYXMgZmV3IGxpbmVzIGFzIHBvc3NpYmxlLlxuICAgIGZ1bmN0aW9uIGlzUG9pbnRJblBvbHkoeCwgeSkge1xuICAgICAgdmFyIGluc2lkZSA9IGZhbHNlO1xuICAgICAgd2Fsa1RyZWUoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgLy8gSWdub3JlIG5vZGVzIHdob3NlIGJvdW5kcyBjYW4ndCBwb3NzaWJseSBjcm9zcyBvdXIgZWFzdC1wb2ludGluZyByYXlcbiAgICAgICAgaWYgKG5vZGUubWF4WCA8IHggfHwgbm9kZS5taW5ZID4geSB8fCBub2RlLm1heFkgPCB5KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBMZWFmIC0gdGVzdCBlYWNoIHNlZ21lbnQgZm9yIHdoZXRoZXIgaXQgY3Jvc3NlcyBvdXIgZWFzdC1wb2ludGluZyByYXlcbiAgICAgICAgZm9yICh2YXIgc2VnbWVudCA9IG5vZGUuZGF0YTsgc2VnbWVudDsgc2VnbWVudCA9IHNlZ21lbnQubmV4dCkge1xuICAgICAgICAgIHZhciB4MCA9IHNlZ21lbnQueDA7XG4gICAgICAgICAgdmFyIHkwID0gc2VnbWVudC55MDtcbiAgICAgICAgICB2YXIgeDEgPSBzZWdtZW50LngxO1xuICAgICAgICAgIHZhciB5MSA9IHNlZ21lbnQueTE7XG4gICAgICAgICAgdmFyIGludGVyc2VjdHMgPSAoKHkwID4geSkgIT09ICh5MSA+IHkpKSAmJiAoeCA8ICh4MSAtIHgwKSAqICh5IC0geTApIC8gKHkxIC0geTApICsgeDApO1xuICAgICAgICAgIGlmIChpbnRlcnNlY3RzKSB7XG4gICAgICAgICAgICBpbnNpZGUgPSAhaW5zaWRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gaW5zaWRlXG4gICAgfVxuXG4gICAgLy8gRmluZCB0aGUgYWJzb2x1dGUgZGlzdGFuY2UgZnJvbSBhIHBvaW50IHRvIGEgbGluZSBzZWdtZW50IGF0IGNsb3Nlc3QgYXBwcm9hY2hcbiAgICBmdW5jdGlvbiBhYnNTcXVhcmVEaXN0YW5jZVRvTGluZVNlZ21lbnQoeCwgeSwgbGluZVgwLCBsaW5lWTAsIGxpbmVYMSwgbGluZVkxKSB7XG4gICAgICB2YXIgbGR4ID0gbGluZVgxIC0gbGluZVgwO1xuICAgICAgdmFyIGxkeSA9IGxpbmVZMSAtIGxpbmVZMDtcbiAgICAgIHZhciBsZW5ndGhTcSA9IGxkeCAqIGxkeCArIGxkeSAqIGxkeTtcbiAgICAgIHZhciB0ID0gbGVuZ3RoU3EgPyBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAoKHggLSBsaW5lWDApICogbGR4ICsgKHkgLSBsaW5lWTApICogbGR5KSAvIGxlbmd0aFNxKSkgOiAwO1xuICAgICAgdmFyIGR4ID0geCAtIChsaW5lWDAgKyB0ICogbGR4KTtcbiAgICAgIHZhciBkeSA9IHkgLSAobGluZVkwICsgdCAqIGxkeSk7XG4gICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHlcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYWRkTGluZVNlZ21lbnQ6IGFkZExpbmVTZWdtZW50LFxuICAgICAgZmluZE5lYXJlc3RTaWduZWREaXN0YW5jZTogZmluZE5lYXJlc3RTaWduZWREaXN0YW5jZVxuICAgIH1cbiAgfVxuXG4gIC8vIEN1c3RvbSBidW5kbGUgb2YgVHlwci5qcyAoaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvcGVhL1R5cHIuanMpIGZvciB1c2UgaW4gdHJvaWthLTNkLXRleHQuIFxuICAvLyBPcmlnaW5hbCBNSVQgbGljZW5zZSBhcHBsaWVzOiBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9wZWEvVHlwci5qcy9ibG9iL2doLXBhZ2VzL0xJQ0VOU0VcblxuICBmdW5jdGlvbiB0eXByRmFjdG9yeSgpIHtcblxuICB2YXIgd2luZG93ID0gc2VsZjtcblxuICAvLyBCZWdpbiBUeXByLmpzXG5cblxuICB2YXIgVHlwciA9IHt9O1xuXG4gIFR5cHIucGFyc2UgPSBmdW5jdGlvbihidWZmKVxuICB7XG4gIFx0dmFyIGJpbiA9IFR5cHIuX2JpbjtcbiAgXHR2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KGJ1ZmYpO1xuICBcdFxuICBcdHZhciB0YWcgPSBiaW4ucmVhZEFTQ0lJKGRhdGEsIDAsIDQpOyAgXG4gIFx0aWYodGFnPT1cInR0Y2ZcIikge1xuICBcdFx0dmFyIG9mZnNldCA9IDQ7XG4gIFx0XHR2YXIgbWFqViA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0XHR2YXIgbWluViA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0XHR2YXIgbnVtRiA9IGJpbi5yZWFkVWludCAgKGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTQ7XG4gIFx0XHR2YXIgZm50cyA9IFtdO1xuICBcdFx0Zm9yKHZhciBpPTA7IGk8bnVtRjsgaSsrKSB7XG4gIFx0XHRcdHZhciBmb2ZmID0gYmluLnJlYWRVaW50ICAoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9NDtcbiAgXHRcdFx0Zm50cy5wdXNoKFR5cHIuX3JlYWRGb250KGRhdGEsIGZvZmYpKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiBmbnRzO1xuICBcdH1cbiAgXHRlbHNlIHsgcmV0dXJuIFtUeXByLl9yZWFkRm9udChkYXRhLCAwKV07IH1cbiAgfTtcblxuICBUeXByLl9yZWFkRm9udCA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCkge1xuICBcdHZhciBiaW4gPSBUeXByLl9iaW47XG4gIFx0dmFyIG9vZmYgPSBvZmZzZXQ7XG4gIFx0XG4gIFx0dmFyIHNmbnRfdmVyc2lvbiA9IGJpbi5yZWFkRml4ZWQoZGF0YSwgb2Zmc2V0KTtcbiAgXHRvZmZzZXQgKz0gNDtcbiAgXHR2YXIgbnVtVGFibGVzID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTtcbiAgXHRvZmZzZXQgKz0gMjtcbiAgXHR2YXIgc2VhcmNoUmFuZ2UgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpO1xuICBcdG9mZnNldCArPSAyO1xuICBcdHZhciBlbnRyeVNlbGVjdG9yID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTtcbiAgXHRvZmZzZXQgKz0gMjtcbiAgXHR2YXIgcmFuZ2VTaGlmdCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7XG4gIFx0b2Zmc2V0ICs9IDI7XG4gIFx0XG4gIFx0dmFyIHRhZ3MgPSBbXG4gIFx0XHRcImNtYXBcIixcbiAgXHRcdFwiaGVhZFwiLFxuICBcdFx0XCJoaGVhXCIsXG4gIFx0XHRcIm1heHBcIixcbiAgXHRcdFwiaG10eFwiLFxuICBcdFx0XCJuYW1lXCIsXG4gIFx0XHRcIk9TLzJcIixcbiAgXHRcdFwicG9zdFwiLFxuICBcdFx0XG4gIFx0XHQvL1wiY3Z0XCIsXG4gIFx0XHQvL1wiZnBnbVwiLFxuICBcdFx0XCJsb2NhXCIsXG4gIFx0XHRcImdseWZcIixcbiAgXHRcdFwia2VyblwiLFxuICBcdFx0XG4gIFx0XHQvL1wicHJlcFwiXG4gIFx0XHQvL1wiZ2FzcFwiXG4gIFx0XHRcbiAgXHRcdFwiQ0ZGIFwiLFxuICBcdFx0XG4gIFx0XHRcbiAgXHRcdFwiR1BPU1wiLFxuICBcdFx0XCJHU1VCXCIsXG4gIFx0XHRcbiAgXHRcdFwiU1ZHIFwiIF07XG4gIFx0XG4gIFx0dmFyIG9iaiA9IHtfZGF0YTpkYXRhLCBfb2Zmc2V0Om9vZmZ9O1xuICBcdC8vY29uc29sZS5sb2coc2ZudF92ZXJzaW9uLCBudW1UYWJsZXMsIHNlYXJjaFJhbmdlLCBlbnRyeVNlbGVjdG9yLCByYW5nZVNoaWZ0KTtcbiAgXHRcbiAgXHR2YXIgdGFicyA9IHt9O1xuICBcdFxuICBcdGZvcih2YXIgaT0wOyBpPG51bVRhYmxlczsgaSsrKVxuICBcdHtcbiAgXHRcdHZhciB0YWcgPSBiaW4ucmVhZEFTQ0lJKGRhdGEsIG9mZnNldCwgNCk7ICAgb2Zmc2V0ICs9IDQ7XG4gIFx0XHR2YXIgY2hlY2tTdW0gPSBiaW4ucmVhZFVpbnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSA0O1xuICBcdFx0dmFyIHRvZmZzZXQgPSBiaW4ucmVhZFVpbnQoZGF0YSwgb2Zmc2V0KTsgICBvZmZzZXQgKz0gNDtcbiAgXHRcdHZhciBsZW5ndGggPSBiaW4ucmVhZFVpbnQoZGF0YSwgb2Zmc2V0KTsgICAgb2Zmc2V0ICs9IDQ7XG4gIFx0XHR0YWJzW3RhZ10gPSB7b2Zmc2V0OnRvZmZzZXQsIGxlbmd0aDpsZW5ndGh9O1xuICBcdFx0XG4gIFx0XHQvL2lmKHRhZ3MuaW5kZXhPZih0YWcpPT0tMSkgY29uc29sZS5sb2coXCJ1bmtub3duIHRhZ1wiLCB0YWcsIGxlbmd0aCk7XG4gIFx0fVxuICBcdFxuICBcdGZvcih2YXIgaT0wOyBpPCB0YWdzLmxlbmd0aDsgaSsrKVxuICBcdHtcbiAgXHRcdHZhciB0ID0gdGFnc1tpXTtcbiAgXHRcdC8vY29uc29sZS5sb2codCk7XG4gIFx0XHQvL2lmKHRhYnNbdF0pIGNvbnNvbGUubG9nKHQsIHRhYnNbdF0ub2Zmc2V0LCB0YWJzW3RdLmxlbmd0aCk7XG4gIFx0XHRpZih0YWJzW3RdKSB7IG9ialt0LnRyaW0oKV0gPSBUeXByW3QudHJpbSgpXS5wYXJzZShkYXRhLCB0YWJzW3RdLm9mZnNldCwgdGFic1t0XS5sZW5ndGgsIG9iaik7IH1cbiAgXHR9XG4gIFx0XG4gIFx0cmV0dXJuIG9iajtcbiAgfTtcblxuICBUeXByLl90YWJPZmZzZXQgPSBmdW5jdGlvbihkYXRhLCB0YWIsIGZvZmYpXG4gIHtcbiAgXHR2YXIgYmluID0gVHlwci5fYmluO1xuICBcdHZhciBudW1UYWJsZXMgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBmb2ZmKzQpO1xuICBcdHZhciBvZmZzZXQgPSBmb2ZmKzEyO1xuICBcdGZvcih2YXIgaT0wOyBpPG51bVRhYmxlczsgaSsrKVxuICBcdHtcbiAgXHRcdHZhciB0YWcgPSBiaW4ucmVhZEFTQ0lJKGRhdGEsIG9mZnNldCwgNCk7ICAgb2Zmc2V0ICs9IDQ7XG4gIFx0XHR2YXIgY2hlY2tTdW0gPSBiaW4ucmVhZFVpbnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSA0O1xuICBcdFx0dmFyIHRvZmZzZXQgPSBiaW4ucmVhZFVpbnQoZGF0YSwgb2Zmc2V0KTsgICBvZmZzZXQgKz0gNDtcbiAgXHRcdHZhciBsZW5ndGggPSBiaW4ucmVhZFVpbnQoZGF0YSwgb2Zmc2V0KTsgICAgb2Zmc2V0ICs9IDQ7XG4gIFx0XHRpZih0YWc9PXRhYikgeyByZXR1cm4gdG9mZnNldDsgfVxuICBcdH1cbiAgXHRyZXR1cm4gMDtcbiAgfTtcblxuXG5cblxuXG4gIFR5cHIuX2JpbiA9IHtcbiAgXHRyZWFkRml4ZWQgOiBmdW5jdGlvbihkYXRhLCBvKVxuICBcdHtcbiAgXHRcdHJldHVybiAoKGRhdGFbb108PDgpIHwgZGF0YVtvKzFdKSArICAoKChkYXRhW28rMl08PDgpfGRhdGFbbyszXSkvKDI1NioyNTYrNCkpO1xuICBcdH0sXG4gIFx0cmVhZEYyZG90MTQgOiBmdW5jdGlvbihkYXRhLCBvKVxuICBcdHtcbiAgXHRcdHZhciBudW0gPSBUeXByLl9iaW4ucmVhZFNob3J0KGRhdGEsIG8pO1xuICBcdFx0cmV0dXJuIG51bSAvIDE2Mzg0O1xuICBcdH0sXG4gIFx0cmVhZEludCA6IGZ1bmN0aW9uKGJ1ZmYsIHApXG4gIFx0e1xuICBcdFx0Ly9pZihwPj1idWZmLmxlbmd0aCkgdGhyb3cgXCJlcnJvclwiO1xuICBcdFx0dmFyIGEgPSBUeXByLl9iaW4udC51aW50ODtcbiAgXHRcdGFbMF0gPSBidWZmW3ArM107XG4gIFx0XHRhWzFdID0gYnVmZltwKzJdO1xuICBcdFx0YVsyXSA9IGJ1ZmZbcCsxXTtcbiAgXHRcdGFbM10gPSBidWZmW3BdO1xuICBcdFx0cmV0dXJuIFR5cHIuX2Jpbi50LmludDMyWzBdO1xuICBcdH0sXG4gIFx0XG4gIFx0cmVhZEludDggOiBmdW5jdGlvbihidWZmLCBwKVxuICBcdHtcbiAgXHRcdC8vaWYocD49YnVmZi5sZW5ndGgpIHRocm93IFwiZXJyb3JcIjtcbiAgXHRcdHZhciBhID0gVHlwci5fYmluLnQudWludDg7XG4gIFx0XHRhWzBdID0gYnVmZltwXTtcbiAgXHRcdHJldHVybiBUeXByLl9iaW4udC5pbnQ4WzBdO1xuICBcdH0sXG4gIFx0cmVhZFNob3J0IDogZnVuY3Rpb24oYnVmZiwgcClcbiAgXHR7XG4gIFx0XHQvL2lmKHA+PWJ1ZmYubGVuZ3RoKSB0aHJvdyBcImVycm9yXCI7XG4gIFx0XHR2YXIgYSA9IFR5cHIuX2Jpbi50LnVpbnQ4O1xuICBcdFx0YVsxXSA9IGJ1ZmZbcF07IGFbMF0gPSBidWZmW3ArMV07XG4gIFx0XHRyZXR1cm4gVHlwci5fYmluLnQuaW50MTZbMF07XG4gIFx0fSxcbiAgXHRyZWFkVXNob3J0IDogZnVuY3Rpb24oYnVmZiwgcClcbiAgXHR7XG4gIFx0XHQvL2lmKHA+PWJ1ZmYubGVuZ3RoKSB0aHJvdyBcImVycm9yXCI7XG4gIFx0XHRyZXR1cm4gKGJ1ZmZbcF08PDgpIHwgYnVmZltwKzFdO1xuICBcdH0sXG4gIFx0cmVhZFVzaG9ydHMgOiBmdW5jdGlvbihidWZmLCBwLCBsZW4pXG4gIFx0e1xuICBcdFx0dmFyIGFyciA9IFtdO1xuICBcdFx0Zm9yKHZhciBpPTA7IGk8bGVuOyBpKyspIHsgYXJyLnB1c2goVHlwci5fYmluLnJlYWRVc2hvcnQoYnVmZiwgcCtpKjIpKTsgfVxuICBcdFx0cmV0dXJuIGFycjtcbiAgXHR9LFxuICBcdHJlYWRVaW50IDogZnVuY3Rpb24oYnVmZiwgcClcbiAgXHR7XG4gIFx0XHQvL2lmKHA+PWJ1ZmYubGVuZ3RoKSB0aHJvdyBcImVycm9yXCI7XG4gIFx0XHR2YXIgYSA9IFR5cHIuX2Jpbi50LnVpbnQ4O1xuICBcdFx0YVszXSA9IGJ1ZmZbcF07ICBhWzJdID0gYnVmZltwKzFdOyAgYVsxXSA9IGJ1ZmZbcCsyXTsgIGFbMF0gPSBidWZmW3ArM107XG4gIFx0XHRyZXR1cm4gVHlwci5fYmluLnQudWludDMyWzBdO1xuICBcdH0sXG4gIFx0cmVhZFVpbnQ2NCA6IGZ1bmN0aW9uKGJ1ZmYsIHApXG4gIFx0e1xuICBcdFx0Ly9pZihwPj1idWZmLmxlbmd0aCkgdGhyb3cgXCJlcnJvclwiO1xuICBcdFx0cmV0dXJuIChUeXByLl9iaW4ucmVhZFVpbnQoYnVmZiwgcCkqKDB4ZmZmZmZmZmYrMSkpICsgVHlwci5fYmluLnJlYWRVaW50KGJ1ZmYsIHArNCk7XG4gIFx0fSxcbiAgXHRyZWFkQVNDSUkgOiBmdW5jdGlvbihidWZmLCBwLCBsKVx0Ly8gbCA6IGxlbmd0aCBpbiBDaGFyYWN0ZXJzIChub3QgQnl0ZXMpXG4gIFx0e1xuICBcdFx0Ly9pZihwPj1idWZmLmxlbmd0aCkgdGhyb3cgXCJlcnJvclwiO1xuICBcdFx0dmFyIHMgPSBcIlwiO1xuICBcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKykgeyBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmZltwK2ldKTsgfVxuICBcdFx0cmV0dXJuIHM7XG4gIFx0fSxcbiAgXHRyZWFkVW5pY29kZSA6IGZ1bmN0aW9uKGJ1ZmYsIHAsIGwpXG4gIFx0e1xuICBcdFx0Ly9pZihwPj1idWZmLmxlbmd0aCkgdGhyb3cgXCJlcnJvclwiO1xuICBcdFx0dmFyIHMgPSBcIlwiO1xuICBcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKylcdFxuICBcdFx0e1xuICBcdFx0XHR2YXIgYyA9IChidWZmW3ArK108PDgpIHwgYnVmZltwKytdO1xuICBcdFx0XHRzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gcztcbiAgXHR9LFxuICBcdF90ZGVjIDogd2luZG93W1wiVGV4dERlY29kZXJcIl0gPyBuZXcgd2luZG93W1wiVGV4dERlY29kZXJcIl0oKSA6IG51bGwsXG4gIFx0cmVhZFVURjggOiBmdW5jdGlvbihidWZmLCBwLCBsKSB7XG4gIFx0XHR2YXIgdGRlYyA9IFR5cHIuX2Jpbi5fdGRlYztcbiAgXHRcdGlmKHRkZWMgJiYgcD09MCAmJiBsPT1idWZmLmxlbmd0aCkgeyByZXR1cm4gdGRlY1tcImRlY29kZVwiXShidWZmKTsgfVxuICBcdFx0cmV0dXJuIFR5cHIuX2Jpbi5yZWFkQVNDSUkoYnVmZixwLGwpO1xuICBcdH0sXG4gIFx0cmVhZEJ5dGVzIDogZnVuY3Rpb24oYnVmZiwgcCwgbClcbiAgXHR7XG4gIFx0XHQvL2lmKHA+PWJ1ZmYubGVuZ3RoKSB0aHJvdyBcImVycm9yXCI7XG4gIFx0XHR2YXIgYXJyID0gW107XG4gIFx0XHRmb3IodmFyIGk9MDsgaTxsOyBpKyspIHsgYXJyLnB1c2goYnVmZltwK2ldKTsgfVxuICBcdFx0cmV0dXJuIGFycjtcbiAgXHR9LFxuICBcdHJlYWRBU0NJSUFycmF5IDogZnVuY3Rpb24oYnVmZiwgcCwgbClcdC8vIGwgOiBsZW5ndGggaW4gQ2hhcmFjdGVycyAobm90IEJ5dGVzKVxuICBcdHtcbiAgXHRcdC8vaWYocD49YnVmZi5sZW5ndGgpIHRocm93IFwiZXJyb3JcIjtcbiAgXHRcdHZhciBzID0gW107XG4gIFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrKVx0XG4gIFx0XHRcdHsgcy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmZltwK2ldKSk7IH1cbiAgXHRcdHJldHVybiBzO1xuICBcdH1cbiAgfTtcblxuICBUeXByLl9iaW4udCA9IHtcbiAgXHRidWZmOiBuZXcgQXJyYXlCdWZmZXIoOCksXG4gIH07XG4gIFR5cHIuX2Jpbi50LmludDggICA9IG5ldyBJbnQ4QXJyYXkgIChUeXByLl9iaW4udC5idWZmKTtcbiAgVHlwci5fYmluLnQudWludDggID0gbmV3IFVpbnQ4QXJyYXkgKFR5cHIuX2Jpbi50LmJ1ZmYpO1xuICBUeXByLl9iaW4udC5pbnQxNiAgPSBuZXcgSW50MTZBcnJheSAoVHlwci5fYmluLnQuYnVmZik7XG4gIFR5cHIuX2Jpbi50LnVpbnQxNiA9IG5ldyBVaW50MTZBcnJheShUeXByLl9iaW4udC5idWZmKTtcbiAgVHlwci5fYmluLnQuaW50MzIgID0gbmV3IEludDMyQXJyYXkgKFR5cHIuX2Jpbi50LmJ1ZmYpO1xuICBUeXByLl9iaW4udC51aW50MzIgPSBuZXcgVWludDMyQXJyYXkoVHlwci5fYmluLnQuYnVmZik7XG5cblxuXG5cblxuICAvLyBPcGVuVHlwZSBMYXlvdXQgQ29tbW9uIFRhYmxlIEZvcm1hdHNcblxuICBUeXByLl9sY3RmID0ge307XG5cbiAgVHlwci5fbGN0Zi5wYXJzZSA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgbGVuZ3RoLCBmb250LCBzdWJ0KVxuICB7XG4gIFx0dmFyIGJpbiA9IFR5cHIuX2JpbjtcbiAgXHR2YXIgb2JqID0ge307XG4gIFx0dmFyIG9mZnNldDAgPSBvZmZzZXQ7XG4gIFx0dmFyIHRhYmxlVmVyc2lvbiA9IGJpbi5yZWFkRml4ZWQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSA0O1xuICBcdFxuICBcdHZhciBvZmZTY3JpcHRMaXN0ICA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcbiAgXHR2YXIgb2ZmRmVhdHVyZUxpc3QgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG4gIFx0dmFyIG9mZkxvb2t1cExpc3QgID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuICBcdFxuICBcdFxuICBcdG9iai5zY3JpcHRMaXN0ICA9IFR5cHIuX2xjdGYucmVhZFNjcmlwdExpc3QgKGRhdGEsIG9mZnNldDAgKyBvZmZTY3JpcHRMaXN0KTtcbiAgXHRvYmouZmVhdHVyZUxpc3QgPSBUeXByLl9sY3RmLnJlYWRGZWF0dXJlTGlzdChkYXRhLCBvZmZzZXQwICsgb2ZmRmVhdHVyZUxpc3QpO1xuICBcdG9iai5sb29rdXBMaXN0ICA9IFR5cHIuX2xjdGYucmVhZExvb2t1cExpc3QgKGRhdGEsIG9mZnNldDAgKyBvZmZMb29rdXBMaXN0LCBzdWJ0KTtcbiAgXHRcbiAgXHRyZXR1cm4gb2JqO1xuICB9O1xuXG4gIFR5cHIuX2xjdGYucmVhZExvb2t1cExpc3QgPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQsIHN1YnQpXG4gIHtcbiAgXHR2YXIgYmluID0gVHlwci5fYmluO1xuICBcdHZhciBvZmZzZXQwID0gb2Zmc2V0O1xuICBcdHZhciBvYmogPSBbXTtcbiAgXHR2YXIgY291bnQgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuICBcdGZvcih2YXIgaT0wOyBpPGNvdW50OyBpKyspIFxuICBcdHtcbiAgXHRcdHZhciBub2ZmID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9MjtcbiAgXHRcdHZhciBsdXQgPSBUeXByLl9sY3RmLnJlYWRMb29rdXBUYWJsZShkYXRhLCBvZmZzZXQwICsgbm9mZiwgc3VidCk7XG4gIFx0XHRvYmoucHVzaChsdXQpO1xuICBcdH1cbiAgXHRyZXR1cm4gb2JqO1xuICB9O1xuXG4gIFR5cHIuX2xjdGYucmVhZExvb2t1cFRhYmxlID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0LCBzdWJ0KVxuICB7XG4gIFx0Ly9jb25zb2xlLmxvZyhcIlBhcnNpbmcgbG9va3VwIHRhYmxlXCIsIG9mZnNldCk7XG4gIFx0dmFyIGJpbiA9IFR5cHIuX2JpbjtcbiAgXHR2YXIgb2Zmc2V0MCA9IG9mZnNldDtcbiAgXHR2YXIgb2JqID0ge3RhYnM6W119O1xuICBcdFxuICBcdG9iai5sdHlwZSA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0b2JqLmZsYWcgID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9MjtcbiAgXHR2YXIgY250ICAgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuICBcdFxuICBcdGZvcih2YXIgaT0wOyBpPGNudDsgaSsrKVxuICBcdHtcbiAgXHRcdHZhciBub2ZmID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9MjtcbiAgXHRcdHZhciB0YWIgPSBzdWJ0KGRhdGEsIG9iai5sdHlwZSwgb2Zmc2V0MCArIG5vZmYpO1xuICBcdFx0Ly9jb25zb2xlLmxvZyhvYmoudHlwZSwgdGFiKTtcbiAgXHRcdG9iai50YWJzLnB1c2godGFiKTtcbiAgXHR9XG4gIFx0cmV0dXJuIG9iajtcbiAgfTtcblxuICBUeXByLl9sY3RmLm51bU9mT25lcyA9IGZ1bmN0aW9uKG4pXG4gIHtcbiAgXHR2YXIgbnVtID0gMDtcbiAgXHRmb3IodmFyIGk9MDsgaTwzMjsgaSsrKSB7IGlmKCgobj4+PmkpJjEpICE9IDApIHsgbnVtKys7IH0gfVxuICBcdHJldHVybiBudW07XG4gIH07XG5cbiAgVHlwci5fbGN0Zi5yZWFkQ2xhc3NEZWYgPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQpXG4gIHtcbiAgXHR2YXIgYmluID0gVHlwci5fYmluO1xuICBcdHZhciBvYmogPSBbXTtcbiAgXHR2YXIgZm9ybWF0ID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9MjtcbiAgXHRpZihmb3JtYXQ9PTEpIFxuICBcdHtcbiAgXHRcdHZhciBzdGFydEdseXBoICA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0XHR2YXIgZ2x5cGhDb3VudCAgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuICBcdFx0Zm9yKHZhciBpPTA7IGk8Z2x5cGhDb3VudDsgaSsrKVxuICBcdFx0e1xuICBcdFx0XHRvYmoucHVzaChzdGFydEdseXBoK2kpO1xuICBcdFx0XHRvYmoucHVzaChzdGFydEdseXBoK2kpO1xuICBcdFx0XHRvYmoucHVzaChiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpKTsgIG9mZnNldCs9MjtcbiAgXHRcdH1cbiAgXHR9XG4gIFx0aWYoZm9ybWF0PT0yKVxuICBcdHtcbiAgXHRcdHZhciBjb3VudCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0XHRmb3IodmFyIGk9MDsgaTxjb3VudDsgaSsrKVxuICBcdFx0e1xuICBcdFx0XHRvYmoucHVzaChiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpKTsgIG9mZnNldCs9MjtcbiAgXHRcdFx0b2JqLnB1c2goYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KSk7ICBvZmZzZXQrPTI7XG4gIFx0XHRcdG9iai5wdXNoKGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCkpOyAgb2Zmc2V0Kz0yO1xuICBcdFx0fVxuICBcdH1cbiAgXHRyZXR1cm4gb2JqO1xuICB9O1xuICBUeXByLl9sY3RmLmdldEludGVydmFsID0gZnVuY3Rpb24odGFiLCB2YWwpXG4gIHtcbiAgXHRmb3IodmFyIGk9MDsgaTx0YWIubGVuZ3RoOyBpKz0zKVxuICBcdHtcbiAgXHRcdHZhciBzdGFydCA9IHRhYltpXSwgZW5kID0gdGFiW2krMV0sIGluZGV4ID0gdGFiW2krMl07XG4gIFx0XHRpZihzdGFydDw9dmFsICYmIHZhbDw9ZW5kKSB7IHJldHVybiBpOyB9XG4gIFx0fVxuICBcdHJldHVybiAtMTtcbiAgfTtcblxuXG4gIFR5cHIuX2xjdGYucmVhZENvdmVyYWdlID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0KVxuICB7XG4gIFx0dmFyIGJpbiA9IFR5cHIuX2JpbjtcbiAgXHR2YXIgY3ZnID0ge307XG4gIFx0Y3ZnLmZtdCAgID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9MjtcbiAgXHR2YXIgY291bnQgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuICBcdC8vY29uc29sZS5sb2coXCJwYXJzaW5nIGNvdmVyYWdlXCIsIG9mZnNldC00LCBmb3JtYXQsIGNvdW50KTtcbiAgXHRpZihjdmcuZm10PT0xKSB7IGN2Zy50YWIgPSBiaW4ucmVhZFVzaG9ydHMoZGF0YSwgb2Zmc2V0LCBjb3VudCk7IH0gXG4gIFx0aWYoY3ZnLmZtdD09MikgeyBjdmcudGFiID0gYmluLnJlYWRVc2hvcnRzKGRhdGEsIG9mZnNldCwgY291bnQqMyk7IH1cbiAgXHRyZXR1cm4gY3ZnO1xuICB9O1xuXG4gIFR5cHIuX2xjdGYuY292ZXJhZ2VJbmRleCA9IGZ1bmN0aW9uKGN2ZywgdmFsKVxuICB7XG4gIFx0dmFyIHRhYiA9IGN2Zy50YWI7XG4gIFx0aWYoY3ZnLmZtdD09MSkgeyByZXR1cm4gdGFiLmluZGV4T2YodmFsKTsgfVxuICBcdGlmKGN2Zy5mbXQ9PTIpIHtcbiAgXHRcdHZhciBpbmQgPSBUeXByLl9sY3RmLmdldEludGVydmFsKHRhYiwgdmFsKTtcbiAgXHRcdGlmKGluZCE9LTEpIHsgcmV0dXJuIHRhYltpbmQrMl0gKyAodmFsIC0gdGFiW2luZF0pOyB9XG4gIFx0fVxuICBcdHJldHVybiAtMTtcbiAgfTtcblxuICBUeXByLl9sY3RmLnJlYWRGZWF0dXJlTGlzdCA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldClcbiAge1xuICBcdHZhciBiaW4gPSBUeXByLl9iaW47XG4gIFx0dmFyIG9mZnNldDAgPSBvZmZzZXQ7XG4gIFx0dmFyIG9iaiA9IFtdO1xuICBcdFxuICBcdHZhciBjb3VudCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0XG4gIFx0Zm9yKHZhciBpPTA7IGk8Y291bnQ7IGkrKylcbiAgXHR7XG4gIFx0XHR2YXIgdGFnID0gYmluLnJlYWRBU0NJSShkYXRhLCBvZmZzZXQsIDQpOyAgb2Zmc2V0Kz00O1xuICBcdFx0dmFyIG5vZmYgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuICBcdFx0b2JqLnB1c2goe3RhZzogdGFnLnRyaW0oKSwgdGFiOlR5cHIuX2xjdGYucmVhZEZlYXR1cmVUYWJsZShkYXRhLCBvZmZzZXQwICsgbm9mZil9KTtcbiAgXHR9XG4gIFx0cmV0dXJuIG9iajtcbiAgfTtcblxuICBUeXByLl9sY3RmLnJlYWRGZWF0dXJlVGFibGUgPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQpXG4gIHtcbiAgXHR2YXIgYmluID0gVHlwci5fYmluO1xuICBcdFxuICBcdHZhciBmZWF0dXJlUGFyYW1zID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9MjtcdC8vID0gMFxuICBcdHZhciBsb29rdXBDb3VudCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0XG4gIFx0dmFyIGluZGljZXMgPSBbXTtcbiAgXHRmb3IodmFyIGk9MDsgaTxsb29rdXBDb3VudDsgaSsrKSB7IGluZGljZXMucHVzaChiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQrMippKSk7IH1cbiAgXHRyZXR1cm4gaW5kaWNlcztcbiAgfTtcblxuXG4gIFR5cHIuX2xjdGYucmVhZFNjcmlwdExpc3QgPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQpXG4gIHtcbiAgXHR2YXIgYmluID0gVHlwci5fYmluO1xuICBcdHZhciBvZmZzZXQwID0gb2Zmc2V0O1xuICBcdHZhciBvYmogPSB7fTtcbiAgXHRcbiAgXHR2YXIgY291bnQgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuICBcdFxuICBcdGZvcih2YXIgaT0wOyBpPGNvdW50OyBpKyspXG4gIFx0e1xuICBcdFx0dmFyIHRhZyA9IGJpbi5yZWFkQVNDSUkoZGF0YSwgb2Zmc2V0LCA0KTsgIG9mZnNldCs9NDtcbiAgXHRcdHZhciBub2ZmID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9MjtcbiAgXHRcdG9ialt0YWcudHJpbSgpXSA9IFR5cHIuX2xjdGYucmVhZFNjcmlwdFRhYmxlKGRhdGEsIG9mZnNldDAgKyBub2ZmKTtcbiAgXHR9XG4gIFx0cmV0dXJuIG9iajtcbiAgfTtcblxuICBUeXByLl9sY3RmLnJlYWRTY3JpcHRUYWJsZSA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldClcbiAge1xuICBcdHZhciBiaW4gPSBUeXByLl9iaW47XG4gIFx0dmFyIG9mZnNldDAgPSBvZmZzZXQ7XG4gIFx0dmFyIG9iaiA9IHt9O1xuICBcdFxuICBcdHZhciBkZWZMYW5nU3lzT2ZmID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9MjtcbiAgXHRvYmouZGVmYXVsdCA9IFR5cHIuX2xjdGYucmVhZExhbmdTeXNUYWJsZShkYXRhLCBvZmZzZXQwICsgZGVmTGFuZ1N5c09mZik7XG4gIFx0XG4gIFx0dmFyIGxhbmdTeXNDb3VudCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0XG4gIFx0Zm9yKHZhciBpPTA7IGk8bGFuZ1N5c0NvdW50OyBpKyspXG4gIFx0e1xuICBcdFx0dmFyIHRhZyA9IGJpbi5yZWFkQVNDSUkoZGF0YSwgb2Zmc2V0LCA0KTsgIG9mZnNldCs9NDtcbiAgXHRcdHZhciBsYW5nU3lzT2ZmID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9MjtcbiAgXHRcdG9ialt0YWcudHJpbSgpXSA9IFR5cHIuX2xjdGYucmVhZExhbmdTeXNUYWJsZShkYXRhLCBvZmZzZXQwICsgbGFuZ1N5c09mZik7XG4gIFx0fVxuICBcdHJldHVybiBvYmo7XG4gIH07XG5cbiAgVHlwci5fbGN0Zi5yZWFkTGFuZ1N5c1RhYmxlID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0KVxuICB7XG4gIFx0dmFyIGJpbiA9IFR5cHIuX2JpbjtcbiAgXHR2YXIgb2JqID0ge307XG4gIFx0XG4gIFx0dmFyIGxvb2t1cE9yZGVyID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9MjtcbiAgXHQvL2lmKGxvb2t1cE9yZGVyIT0wKSAgdGhyb3cgXCJsb29rdXBPcmRlciBub3QgMFwiO1xuICBcdG9iai5yZXFGZWF0dXJlID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9MjtcbiAgXHQvL2lmKG9iai5yZXFGZWF0dXJlICE9IDB4ZmZmZikgdGhyb3cgXCJyZXFGZWF0dXJlSW5kZXggIT0gMHhmZmZmXCI7XG4gIFx0XG4gIFx0Ly9jb25zb2xlLmxvZyhsb29rdXBPcmRlciwgb2JqLnJlcUZlYXR1cmUpO1xuICBcdFxuICBcdHZhciBmZWF0dXJlQ291bnQgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuICBcdG9iai5mZWF0dXJlcyA9IGJpbi5yZWFkVXNob3J0cyhkYXRhLCBvZmZzZXQsIGZlYXR1cmVDb3VudCk7XG4gIFx0cmV0dXJuIG9iajtcbiAgfTtcblxuICBcdFR5cHIuQ0ZGID0ge307XG4gIFx0VHlwci5DRkYucGFyc2UgPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQsIGxlbmd0aClcbiAgXHR7XG4gIFx0XHR2YXIgYmluID0gVHlwci5fYmluO1xuICBcdFx0XG4gIFx0XHRkYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIG9mZnNldCwgbGVuZ3RoKTtcbiAgXHRcdG9mZnNldCA9IDA7XG4gIFx0XHRcbiAgXHRcdC8vIEhlYWRlclxuICBcdFx0dmFyIG1ham9yID0gZGF0YVtvZmZzZXRdOyAgb2Zmc2V0Kys7XG4gIFx0XHR2YXIgbWlub3IgPSBkYXRhW29mZnNldF07ICBvZmZzZXQrKztcbiAgXHRcdHZhciBoZHJTaXplID0gZGF0YVtvZmZzZXRdOyAgb2Zmc2V0Kys7XG4gIFx0XHR2YXIgb2Zmc2l6ZSA9IGRhdGFbb2Zmc2V0XTsgIG9mZnNldCsrO1xuICBcdFx0Ly9jb25zb2xlLmxvZyhtYWpvciwgbWlub3IsIGhkclNpemUsIG9mZnNpemUpO1xuICBcdFx0XG4gIFx0XHQvLyBOYW1lIElOREVYXG4gIFx0XHR2YXIgbmluZHMgPSBbXTtcbiAgXHRcdG9mZnNldCA9IFR5cHIuQ0ZGLnJlYWRJbmRleChkYXRhLCBvZmZzZXQsIG5pbmRzKTtcbiAgXHRcdHZhciBuYW1lcyA9IFtdO1xuICBcdFx0XG4gIFx0XHRmb3IodmFyIGk9MDsgaTxuaW5kcy5sZW5ndGgtMTsgaSsrKSB7IG5hbWVzLnB1c2goYmluLnJlYWRBU0NJSShkYXRhLCBvZmZzZXQrbmluZHNbaV0sIG5pbmRzW2krMV0tbmluZHNbaV0pKTsgfVxuICBcdFx0b2Zmc2V0ICs9IG5pbmRzW25pbmRzLmxlbmd0aC0xXTtcbiAgXHRcdFxuICBcdFx0XG4gIFx0XHQvLyBUb3AgRElDVCBJTkRFWFxuICBcdFx0dmFyIHRkaW5kcyA9IFtdO1xuICBcdFx0b2Zmc2V0ID0gVHlwci5DRkYucmVhZEluZGV4KGRhdGEsIG9mZnNldCwgdGRpbmRzKTsgIC8vY29uc29sZS5sb2codGRpbmRzKTtcbiAgXHRcdC8vIFRvcCBESUNUIERhdGFcbiAgXHRcdHZhciB0b3BEaWN0cyA9IFtdO1xuICBcdFx0Zm9yKHZhciBpPTA7IGk8dGRpbmRzLmxlbmd0aC0xOyBpKyspIHsgdG9wRGljdHMucHVzaCggVHlwci5DRkYucmVhZERpY3QoZGF0YSwgb2Zmc2V0K3RkaW5kc1tpXSwgb2Zmc2V0K3RkaW5kc1tpKzFdKSApOyB9XG4gIFx0XHRvZmZzZXQgKz0gdGRpbmRzW3RkaW5kcy5sZW5ndGgtMV07XG4gIFx0XHR2YXIgdG9wZGljdCA9IHRvcERpY3RzWzBdO1xuICBcdFx0Ly9jb25zb2xlLmxvZyh0b3BkaWN0KTtcbiAgXHRcdFxuICBcdFx0Ly8gU3RyaW5nIElOREVYXG4gIFx0XHR2YXIgc2luZHMgPSBbXTtcbiAgXHRcdG9mZnNldCA9IFR5cHIuQ0ZGLnJlYWRJbmRleChkYXRhLCBvZmZzZXQsIHNpbmRzKTtcbiAgXHRcdC8vIFN0cmluZyBEYXRhXG4gIFx0XHR2YXIgc3RyaW5ncyA9IFtdO1xuICBcdFx0Zm9yKHZhciBpPTA7IGk8c2luZHMubGVuZ3RoLTE7IGkrKykgeyBzdHJpbmdzLnB1c2goYmluLnJlYWRBU0NJSShkYXRhLCBvZmZzZXQrc2luZHNbaV0sIHNpbmRzW2krMV0tc2luZHNbaV0pKTsgfVxuICBcdFx0b2Zmc2V0ICs9IHNpbmRzW3NpbmRzLmxlbmd0aC0xXTtcbiAgXHRcdFxuICBcdFx0Ly8gR2xvYmFsIFN1YnIgSU5ERVggIChzdWJyb3V0aW5lcylcdFx0XG4gIFx0XHRUeXByLkNGRi5yZWFkU3VicnMoZGF0YSwgb2Zmc2V0LCB0b3BkaWN0KTtcbiAgXHRcdFxuICBcdFx0Ly8gY2hhcnN0cmluZ3NcbiAgXHRcdGlmKHRvcGRpY3QuQ2hhclN0cmluZ3MpXG4gIFx0XHR7XG4gIFx0XHRcdG9mZnNldCA9IHRvcGRpY3QuQ2hhclN0cmluZ3M7XG4gIFx0XHRcdHZhciBzaW5kcyA9IFtdO1xuICBcdFx0XHRvZmZzZXQgPSBUeXByLkNGRi5yZWFkSW5kZXgoZGF0YSwgb2Zmc2V0LCBzaW5kcyk7XG4gIFx0XHRcdFxuICBcdFx0XHR2YXIgY3N0ciA9IFtdO1xuICBcdFx0XHRmb3IodmFyIGk9MDsgaTxzaW5kcy5sZW5ndGgtMTsgaSsrKSB7IGNzdHIucHVzaChiaW4ucmVhZEJ5dGVzKGRhdGEsIG9mZnNldCtzaW5kc1tpXSwgc2luZHNbaSsxXS1zaW5kc1tpXSkpOyB9XG4gIFx0XHRcdC8vb2Zmc2V0ICs9IHNpbmRzW3NpbmRzLmxlbmd0aC0xXTtcbiAgXHRcdFx0dG9wZGljdC5DaGFyU3RyaW5ncyA9IGNzdHI7XG4gIFx0XHRcdC8vY29uc29sZS5sb2codG9wZGljdC5DaGFyU3RyaW5ncyk7XG4gIFx0XHR9XG4gIFx0XHRcbiAgXHRcdC8vIENJRCBmb250XG4gIFx0XHRpZih0b3BkaWN0LlJPUykge1xuICBcdFx0XHRvZmZzZXQgPSB0b3BkaWN0LkZEQXJyYXk7XG4gIFx0XHRcdHZhciBmZGluZCA9IFtdO1xuICBcdFx0XHRvZmZzZXQgPSBUeXByLkNGRi5yZWFkSW5kZXgoZGF0YSwgb2Zmc2V0LCBmZGluZCk7XG4gIFx0XHRcdFxuICBcdFx0XHR0b3BkaWN0LkZEQXJyYXkgPSBbXTtcbiAgXHRcdFx0Zm9yKHZhciBpPTA7IGk8ZmRpbmQubGVuZ3RoLTE7IGkrKykge1xuICBcdFx0XHRcdHZhciBkaWN0ID0gVHlwci5DRkYucmVhZERpY3QoZGF0YSwgb2Zmc2V0K2ZkaW5kW2ldLCBvZmZzZXQrZmRpbmRbaSsxXSk7XG4gIFx0XHRcdFx0VHlwci5DRkYuX3JlYWRGRGljdChkYXRhLCBkaWN0LCBzdHJpbmdzKTtcbiAgXHRcdFx0XHR0b3BkaWN0LkZEQXJyYXkucHVzaCggZGljdCApO1xuICBcdFx0XHR9XG4gIFx0XHRcdG9mZnNldCArPSBmZGluZFtmZGluZC5sZW5ndGgtMV07XG4gIFx0XHRcdFxuICBcdFx0XHRvZmZzZXQgPSB0b3BkaWN0LkZEU2VsZWN0O1xuICBcdFx0XHR0b3BkaWN0LkZEU2VsZWN0ID0gW107XG4gIFx0XHRcdHZhciBmbXQgPSBkYXRhW29mZnNldF07ICBvZmZzZXQrKztcbiAgXHRcdFx0aWYoZm10PT0zKSB7XG4gIFx0XHRcdFx0dmFyIHJucyA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0XHRcdFx0Zm9yKHZhciBpPTA7IGk8cm5zKzE7IGkrKykge1xuICBcdFx0XHRcdFx0dG9wZGljdC5GRFNlbGVjdC5wdXNoKGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCksIGRhdGFbb2Zmc2V0KzJdKTsgIG9mZnNldCs9MztcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdFx0ZWxzZSB7IHRocm93IGZtdDsgfVxuICBcdFx0fVxuICBcdFx0XG4gIFx0XHQvLyBFbmNvZGluZ1xuICBcdFx0aWYodG9wZGljdC5FbmNvZGluZykgeyB0b3BkaWN0LkVuY29kaW5nID0gVHlwci5DRkYucmVhZEVuY29kaW5nKGRhdGEsIHRvcGRpY3QuRW5jb2RpbmcsIHRvcGRpY3QuQ2hhclN0cmluZ3MubGVuZ3RoKTsgfVxuICBcdFx0XG4gIFx0XHQvLyBjaGFyc2V0XG4gIFx0XHRpZih0b3BkaWN0LmNoYXJzZXQgKSB7IHRvcGRpY3QuY2hhcnNldCAgPSBUeXByLkNGRi5yZWFkQ2hhcnNldCAoZGF0YSwgdG9wZGljdC5jaGFyc2V0ICwgdG9wZGljdC5DaGFyU3RyaW5ncy5sZW5ndGgpOyB9XG4gIFx0XHRcbiAgXHRcdFR5cHIuQ0ZGLl9yZWFkRkRpY3QoZGF0YSwgdG9wZGljdCwgc3RyaW5ncyk7XG4gIFx0XHRyZXR1cm4gdG9wZGljdDtcbiAgXHR9O1xuICBcdFR5cHIuQ0ZGLl9yZWFkRkRpY3QgPSBmdW5jdGlvbihkYXRhLCBkaWN0LCBzcykge1xuICBcdFx0dmFyIG9mZnNldDtcbiAgXHRcdGlmKGRpY3QuUHJpdmF0ZSkge1xuICBcdFx0XHRvZmZzZXQgPSBkaWN0LlByaXZhdGVbMV07XG4gIFx0XHRcdGRpY3QuUHJpdmF0ZSA9IFR5cHIuQ0ZGLnJlYWREaWN0KGRhdGEsIG9mZnNldCwgb2Zmc2V0K2RpY3QuUHJpdmF0ZVswXSk7XG4gIFx0XHRcdGlmKGRpY3QuUHJpdmF0ZS5TdWJycykgIHsgVHlwci5DRkYucmVhZFN1YnJzKGRhdGEsIG9mZnNldCtkaWN0LlByaXZhdGUuU3VicnMsIGRpY3QuUHJpdmF0ZSk7IH1cbiAgXHRcdH1cbiAgXHRcdGZvcih2YXIgcCBpbiBkaWN0KSB7IGlmKFtcIkZhbWlseU5hbWVcIixcIkZvbnROYW1lXCIsXCJGdWxsTmFtZVwiLFwiTm90aWNlXCIsXCJ2ZXJzaW9uXCIsXCJDb3B5cmlnaHRcIl0uaW5kZXhPZihwKSE9LTEpICB7IGRpY3RbcF09c3NbZGljdFtwXSAtNDI2ICsgMzVdOyB9IH1cbiAgXHR9O1xuICBcdFxuICBcdFR5cHIuQ0ZGLnJlYWRTdWJycyA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgb2JqKVxuICBcdHtcbiAgXHRcdHZhciBiaW4gPSBUeXByLl9iaW47XG4gIFx0XHR2YXIgZ3N1YmluZHMgPSBbXTtcbiAgXHRcdG9mZnNldCA9IFR5cHIuQ0ZGLnJlYWRJbmRleChkYXRhLCBvZmZzZXQsIGdzdWJpbmRzKTtcbiAgXHRcdFxuICBcdFx0dmFyIGJpYXMsIG5TdWJycyA9IGdzdWJpbmRzLmxlbmd0aDtcbiAgXHRcdGlmIChuU3VicnMgPCAgMTI0MCkgeyBiaWFzID0gMTA3OyB9XG4gIFx0XHRlbHNlIGlmIChuU3VicnMgPCAzMzkwMCkgeyBiaWFzID0gMTEzMTsgfVxuICBcdFx0ZWxzZSB7IGJpYXMgPSAzMjc2ODsgfVxuICBcdFx0b2JqLkJpYXMgPSBiaWFzO1xuICBcdFx0XG4gIFx0XHRvYmouU3VicnMgPSBbXTtcbiAgXHRcdGZvcih2YXIgaT0wOyBpPGdzdWJpbmRzLmxlbmd0aC0xOyBpKyspIHsgb2JqLlN1YnJzLnB1c2goYmluLnJlYWRCeXRlcyhkYXRhLCBvZmZzZXQrZ3N1YmluZHNbaV0sIGdzdWJpbmRzW2krMV0tZ3N1YmluZHNbaV0pKTsgfVxuICBcdFx0Ly9vZmZzZXQgKz0gZ3N1YmluZHNbZ3N1YmluZHMubGVuZ3RoLTFdO1xuICBcdH07XG4gIFx0XG4gIFx0VHlwci5DRkYudGFibGVTRSA9IFtcbiAgICAgICAgMCwgICAwLCAgIDAsICAgMCwgICAwLCAgIDAsICAgMCwgICAwLFxuICAgICAgICAwLCAgIDAsICAgMCwgICAwLCAgIDAsICAgMCwgICAwLCAgIDAsXG4gICAgICAgIDAsICAgMCwgICAwLCAgIDAsICAgMCwgICAwLCAgIDAsICAgMCxcbiAgICAgICAgMCwgICAwLCAgIDAsICAgMCwgICAwLCAgIDAsICAgMCwgICAwLFxuICAgICAgICAxLCAgIDIsICAgMywgICA0LCAgIDUsICAgNiwgICA3LCAgIDgsXG4gICAgICAgIDksICAxMCwgIDExLCAgMTIsICAxMywgIDE0LCAgMTUsICAxNixcbiAgICAgICAxNywgIDE4LCAgMTksICAyMCwgIDIxLCAgMjIsICAyMywgIDI0LFxuICAgICAgIDI1LCAgMjYsICAyNywgIDI4LCAgMjksICAzMCwgIDMxLCAgMzIsXG4gICAgICAgMzMsICAzNCwgIDM1LCAgMzYsICAzNywgIDM4LCAgMzksICA0MCxcbiAgICAgICA0MSwgIDQyLCAgNDMsICA0NCwgIDQ1LCAgNDYsICA0NywgIDQ4LFxuICAgICAgIDQ5LCAgNTAsICA1MSwgIDUyLCAgNTMsICA1NCwgIDU1LCAgNTYsXG4gICAgICAgNTcsICA1OCwgIDU5LCAgNjAsICA2MSwgIDYyLCAgNjMsICA2NCxcbiAgICAgICA2NSwgIDY2LCAgNjcsICA2OCwgIDY5LCAgNzAsICA3MSwgIDcyLFxuICAgICAgIDczLCAgNzQsICA3NSwgIDc2LCAgNzcsICA3OCwgIDc5LCAgODAsXG4gICAgICAgODEsICA4MiwgIDgzLCAgODQsICA4NSwgIDg2LCAgODcsICA4OCxcbiAgICAgICA4OSwgIDkwLCAgOTEsICA5MiwgIDkzLCAgOTQsICA5NSwgICAwLFxuICAgICAgICAwLCAgIDAsICAgMCwgICAwLCAgIDAsICAgMCwgICAwLCAgIDAsXG4gICAgICAgIDAsICAgMCwgICAwLCAgIDAsICAgMCwgICAwLCAgIDAsICAgMCxcbiAgICAgICAgMCwgICAwLCAgIDAsICAgMCwgICAwLCAgIDAsICAgMCwgICAwLFxuICAgICAgICAwLCAgIDAsICAgMCwgICAwLCAgIDAsICAgMCwgICAwLCAgIDAsXG4gICAgICAgIDAsICA5NiwgIDk3LCAgOTgsICA5OSwgMTAwLCAxMDEsIDEwMixcbiAgICAgIDEwMywgMTA0LCAxMDUsIDEwNiwgMTA3LCAxMDgsIDEwOSwgMTEwLFxuICAgICAgICAwLCAxMTEsIDExMiwgMTEzLCAxMTQsICAgMCwgMTE1LCAxMTYsXG4gICAgICAxMTcsIDExOCwgMTE5LCAxMjAsIDEyMSwgMTIyLCAgIDAsIDEyMyxcbiAgICAgICAgMCwgMTI0LCAxMjUsIDEyNiwgMTI3LCAxMjgsIDEyOSwgMTMwLFxuICAgICAgMTMxLCAgIDAsIDEzMiwgMTMzLCAgIDAsIDEzNCwgMTM1LCAxMzYsXG4gICAgICAxMzcsICAgMCwgICAwLCAgIDAsICAgMCwgICAwLCAgIDAsICAgMCxcbiAgICAgICAgMCwgICAwLCAgIDAsICAgMCwgICAwLCAgIDAsICAgMCwgICAwLFxuICAgICAgICAwLCAxMzgsICAgMCwgMTM5LCAgIDAsICAgMCwgICAwLCAgIDAsXG4gICAgICAxNDAsIDE0MSwgMTQyLCAxNDMsICAgMCwgICAwLCAgIDAsICAgMCxcbiAgICAgICAgMCwgMTQ0LCAgIDAsICAgMCwgICAwLCAxNDUsICAgMCwgICAwLFxuICAgICAgMTQ2LCAxNDcsIDE0OCwgMTQ5LCAgIDAsICAgMCwgICAwLCAgIDBcbiAgICBdO1xuICAgIFxuICBcdFR5cHIuQ0ZGLmdseXBoQnlVbmljb2RlID0gZnVuY3Rpb24oY2ZmLCBjb2RlKVxuICBcdHtcbiAgXHRcdGZvcih2YXIgaT0wOyBpPGNmZi5jaGFyc2V0Lmxlbmd0aDsgaSsrKSB7IGlmKGNmZi5jaGFyc2V0W2ldPT1jb2RlKSB7IHJldHVybiBpOyB9IH1cbiAgXHRcdHJldHVybiAtMTtcbiAgXHR9O1xuICBcdFxuICBcdFR5cHIuQ0ZGLmdseXBoQnlTRSA9IGZ1bmN0aW9uKGNmZiwgY2hhcmNvZGUpXHQvLyBnbHlwaCBieSBzdGFuZGFyZCBlbmNvZGluZ1xuICBcdHtcbiAgXHRcdGlmICggY2hhcmNvZGUgPCAwIHx8IGNoYXJjb2RlID4gMjU1ICkgeyByZXR1cm4gLTE7IH1cbiAgXHRcdHJldHVybiBUeXByLkNGRi5nbHlwaEJ5VW5pY29kZShjZmYsIFR5cHIuQ0ZGLnRhYmxlU0VbY2hhcmNvZGVdKTtcdFx0XG4gIFx0fTtcbiAgXHRcbiAgXHRUeXByLkNGRi5yZWFkRW5jb2RpbmcgPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQsIG51bSlcbiAgXHR7XG4gIFx0XHR2YXIgYmluID0gVHlwci5fYmluO1xuICBcdFx0XG4gIFx0XHR2YXIgYXJyYXkgPSBbJy5ub3RkZWYnXTtcbiAgXHRcdHZhciBmb3JtYXQgPSBkYXRhW29mZnNldF07ICBvZmZzZXQrKztcbiAgXHRcdC8vY29uc29sZS5sb2coXCJFbmNvZGluZ1wiKTtcbiAgXHRcdC8vY29uc29sZS5sb2coZm9ybWF0KTtcbiAgXHRcdFxuICBcdFx0aWYoZm9ybWF0PT0wKVxuICBcdFx0e1xuICBcdFx0XHR2YXIgbkNvZGVzID0gZGF0YVtvZmZzZXRdOyAgb2Zmc2V0Kys7XG4gIFx0XHRcdGZvcih2YXIgaT0wOyBpPG5Db2RlczsgaSsrKSAgeyBhcnJheS5wdXNoKGRhdGFbb2Zmc2V0K2ldKTsgfVxuICBcdFx0fVxuICBcdFx0LypcbiAgXHRcdGVsc2UgaWYoZm9ybWF0PT0xIHx8IGZvcm1hdD09MilcbiAgXHRcdHtcbiAgXHRcdFx0d2hpbGUoY2hhcnNldC5sZW5ndGg8bnVtKVxuICBcdFx0XHR7XG4gIFx0XHRcdFx0dmFyIGZpcnN0ID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9MjtcbiAgXHRcdFx0XHR2YXIgbkxlZnQ9MDtcbiAgXHRcdFx0XHRpZihmb3JtYXQ9PTEpIHsgIG5MZWZ0ID0gZGF0YVtvZmZzZXRdOyAgb2Zmc2V0Kys7ICB9XG4gIFx0XHRcdFx0ZWxzZSAgICAgICAgICB7ICBuTGVmdCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7ICB9XG4gIFx0XHRcdFx0Zm9yKHZhciBpPTA7IGk8PW5MZWZ0OyBpKyspICB7ICBjaGFyc2V0LnB1c2goZmlyc3QpOyAgZmlyc3QrKzsgIH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdFx0Ki9cbiAgXHRcdGVsc2UgeyB0aHJvdyBcImVycm9yOiB1bmtub3duIGVuY29kaW5nIGZvcm1hdDogXCIgKyBmb3JtYXQ7IH1cbiAgXHRcdFxuICBcdFx0cmV0dXJuIGFycmF5O1xuICBcdH07XG5cbiAgXHRUeXByLkNGRi5yZWFkQ2hhcnNldCA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgbnVtKVxuICBcdHtcbiAgXHRcdHZhciBiaW4gPSBUeXByLl9iaW47XG4gIFx0XHRcbiAgXHRcdHZhciBjaGFyc2V0ID0gWycubm90ZGVmJ107XG4gIFx0XHR2YXIgZm9ybWF0ID0gZGF0YVtvZmZzZXRdOyAgb2Zmc2V0Kys7XG4gIFx0XHRcbiAgXHRcdGlmKGZvcm1hdD09MClcbiAgXHRcdHtcbiAgXHRcdFx0Zm9yKHZhciBpPTA7IGk8bnVtOyBpKyspIFxuICBcdFx0XHR7XG4gIFx0XHRcdFx0dmFyIGZpcnN0ID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9MjtcbiAgXHRcdFx0XHRjaGFyc2V0LnB1c2goZmlyc3QpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0XHRlbHNlIGlmKGZvcm1hdD09MSB8fCBmb3JtYXQ9PTIpXG4gIFx0XHR7XG4gIFx0XHRcdHdoaWxlKGNoYXJzZXQubGVuZ3RoPG51bSlcbiAgXHRcdFx0e1xuICBcdFx0XHRcdHZhciBmaXJzdCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0XHRcdFx0dmFyIG5MZWZ0PTA7XG4gIFx0XHRcdFx0aWYoZm9ybWF0PT0xKSB7ICBuTGVmdCA9IGRhdGFbb2Zmc2V0XTsgIG9mZnNldCsrOyAgfVxuICBcdFx0XHRcdGVsc2UgICAgICAgICAgeyAgbkxlZnQgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yOyAgfVxuICBcdFx0XHRcdGZvcih2YXIgaT0wOyBpPD1uTGVmdDsgaSsrKSAgeyAgY2hhcnNldC5wdXNoKGZpcnN0KTsgIGZpcnN0Kys7ICB9XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHRcdGVsc2UgeyB0aHJvdyBcImVycm9yOiBmb3JtYXQ6IFwiICsgZm9ybWF0OyB9XG4gIFx0XHRcbiAgXHRcdHJldHVybiBjaGFyc2V0O1xuICBcdH07XG5cbiAgXHRUeXByLkNGRi5yZWFkSW5kZXggPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQsIGluZHMpXG4gIFx0e1xuICBcdFx0dmFyIGJpbiA9IFR5cHIuX2JpbjtcbiAgXHRcdFxuICBcdFx0dmFyIGNvdW50ID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KSsxOyAgb2Zmc2V0Kz0yO1xuICBcdFx0dmFyIG9mZnNpemUgPSBkYXRhW29mZnNldF07ICBvZmZzZXQrKztcbiAgXHRcdFxuICBcdFx0aWYgICAgIChvZmZzaXplPT0xKSB7IGZvcih2YXIgaT0wOyBpPGNvdW50OyBpKyspIHsgaW5kcy5wdXNoKCBkYXRhW29mZnNldCtpXSApOyB9IH1cbiAgXHRcdGVsc2UgaWYob2Zmc2l6ZT09MikgeyBmb3IodmFyIGk9MDsgaTxjb3VudDsgaSsrKSB7IGluZHMucHVzaCggYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0K2kqMikgKTsgfSB9XG4gIFx0XHRlbHNlIGlmKG9mZnNpemU9PTMpIHsgZm9yKHZhciBpPTA7IGk8Y291bnQ7IGkrKykgeyBpbmRzLnB1c2goIGJpbi5yZWFkVWludCAgKGRhdGEsIG9mZnNldCtpKjMgLSAxKSAmIDB4MDBmZmZmZmYgKTsgfSB9XG4gIFx0XHRlbHNlIGlmKGNvdW50IT0xKSB7IHRocm93IFwidW5zdXBwb3J0ZWQgb2Zmc2V0IHNpemU6IFwiICsgb2Zmc2l6ZSArIFwiLCBjb3VudDogXCIgKyBjb3VudDsgfVxuICBcdFx0XG4gIFx0XHRvZmZzZXQgKz0gY291bnQqb2Zmc2l6ZTtcbiAgXHRcdHJldHVybiBvZmZzZXQtMTtcbiAgXHR9O1xuICBcdFxuICBcdFR5cHIuQ0ZGLmdldENoYXJTdHJpbmcgPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQsIG8pXG4gIFx0e1xuICBcdFx0dmFyIGJpbiA9IFR5cHIuX2JpbjtcbiAgXHRcdFxuICBcdFx0dmFyIGIwID0gZGF0YVtvZmZzZXRdLCBiMSA9IGRhdGFbb2Zmc2V0KzFdLCBiMiA9IGRhdGFbb2Zmc2V0KzJdLCBiMyA9IGRhdGFbb2Zmc2V0KzNdLCBiND1kYXRhW29mZnNldCs0XTtcbiAgXHRcdHZhciB2cyA9IDE7XG4gIFx0XHR2YXIgb3A9bnVsbCwgdmFsPW51bGw7XG4gIFx0XHQvLyBvcGVyYW5kXG4gIFx0XHRpZihiMDw9MjApIHsgb3AgPSBiMDsgIHZzPTE7ICB9XG4gIFx0XHRpZihiMD09MTIpIHsgb3AgPSBiMCoxMDArYjE7ICB2cz0yOyAgfVxuICBcdFx0Ly9pZihiMD09MTkgfHwgYjA9PTIwKSB7IG9wID0gYjAvKitcIiBcIitiMSovOyAgdnM9MjsgfVxuICBcdFx0aWYoMjEgPD1iMCAmJiBiMDw9IDI3KSB7IG9wID0gYjA7ICB2cz0xOyB9XG4gIFx0XHRpZihiMD09MjgpIHsgdmFsID0gYmluLnJlYWRTaG9ydChkYXRhLG9mZnNldCsxKTsgIHZzPTM7IH1cbiAgXHRcdGlmKDI5IDw9YjAgJiYgYjA8PSAzMSkgeyBvcCA9IGIwOyAgdnM9MTsgfVxuICBcdFx0aWYoMzIgPD1iMCAmJiBiMDw9MjQ2KSB7IHZhbCA9IGIwLTEzOTsgIHZzPTE7IH1cbiAgXHRcdGlmKDI0Nzw9YjAgJiYgYjA8PTI1MCkgeyB2YWwgPSAoYjAtMjQ3KSoyNTYrYjErMTA4OyAgdnM9MjsgfVxuICBcdFx0aWYoMjUxPD1iMCAmJiBiMDw9MjU0KSB7IHZhbCA9LShiMC0yNTEpKjI1Ni1iMS0xMDg7ICB2cz0yOyB9XG4gIFx0XHRpZihiMD09MjU1KSB7ICB2YWwgPSBiaW4ucmVhZEludChkYXRhLCBvZmZzZXQrMSkvMHhmZmZmOyAgdnM9NTsgICB9XG4gIFx0XHRcbiAgXHRcdG8udmFsID0gdmFsIT1udWxsID8gdmFsIDogXCJvXCIrb3A7XG4gIFx0XHRvLnNpemUgPSB2cztcbiAgXHR9O1xuICBcdFxuICBcdFR5cHIuQ0ZGLnJlYWRDaGFyU3RyaW5nID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0LCBsZW5ndGgpXG4gIFx0e1xuICBcdFx0dmFyIGVuZCA9IG9mZnNldCArIGxlbmd0aDtcbiAgXHRcdHZhciBiaW4gPSBUeXByLl9iaW47XG4gIFx0XHR2YXIgYXJyID0gW107XG4gIFx0XHRcbiAgXHRcdHdoaWxlKG9mZnNldDxlbmQpXG4gIFx0XHR7XG4gIFx0XHRcdHZhciBiMCA9IGRhdGFbb2Zmc2V0XSwgYjEgPSBkYXRhW29mZnNldCsxXSwgYjIgPSBkYXRhW29mZnNldCsyXSwgYjMgPSBkYXRhW29mZnNldCszXSwgYjQ9ZGF0YVtvZmZzZXQrNF07XG4gIFx0XHRcdHZhciB2cyA9IDE7XG4gIFx0XHRcdHZhciBvcD1udWxsLCB2YWw9bnVsbDtcbiAgXHRcdFx0Ly8gb3BlcmFuZFxuICBcdFx0XHRpZihiMDw9MjApIHsgb3AgPSBiMDsgIHZzPTE7ICB9XG4gIFx0XHRcdGlmKGIwPT0xMikgeyBvcCA9IGIwKjEwMCtiMTsgIHZzPTI7ICB9XG4gIFx0XHRcdGlmKGIwPT0xOSB8fCBiMD09MjApIHsgb3AgPSBiMC8qK1wiIFwiK2IxKi87ICB2cz0yOyB9XG4gIFx0XHRcdGlmKDIxIDw9YjAgJiYgYjA8PSAyNykgeyBvcCA9IGIwOyAgdnM9MTsgfVxuICBcdFx0XHRpZihiMD09MjgpIHsgdmFsID0gYmluLnJlYWRTaG9ydChkYXRhLG9mZnNldCsxKTsgIHZzPTM7IH1cbiAgXHRcdFx0aWYoMjkgPD1iMCAmJiBiMDw9IDMxKSB7IG9wID0gYjA7ICB2cz0xOyB9XG4gIFx0XHRcdGlmKDMyIDw9YjAgJiYgYjA8PTI0NikgeyB2YWwgPSBiMC0xMzk7ICB2cz0xOyB9XG4gIFx0XHRcdGlmKDI0Nzw9YjAgJiYgYjA8PTI1MCkgeyB2YWwgPSAoYjAtMjQ3KSoyNTYrYjErMTA4OyAgdnM9MjsgfVxuICBcdFx0XHRpZigyNTE8PWIwICYmIGIwPD0yNTQpIHsgdmFsID0tKGIwLTI1MSkqMjU2LWIxLTEwODsgIHZzPTI7IH1cbiAgXHRcdFx0aWYoYjA9PTI1NSkgeyAgdmFsID0gYmluLnJlYWRJbnQoZGF0YSwgb2Zmc2V0KzEpLzB4ZmZmZjsgIHZzPTU7ICAgfVxuICBcdFx0XHRcbiAgXHRcdFx0YXJyLnB1c2godmFsIT1udWxsID8gdmFsIDogXCJvXCIrb3ApO1xuICBcdFx0XHRvZmZzZXQgKz0gdnM7XHRcblxuICBcdFx0XHQvL3ZhciBjdiA9IGFyclthcnIubGVuZ3RoLTFdO1xuICBcdFx0XHQvL2lmKGN2PT11bmRlZmluZWQpIHRocm93IFwiZXJyb3JcIjtcbiAgXHRcdFx0Ly9jb25zb2xlLmxvZygpXG4gIFx0XHR9XHRcbiAgXHRcdHJldHVybiBhcnI7XG4gIFx0fTtcblxuICBcdFR5cHIuQ0ZGLnJlYWREaWN0ID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0LCBlbmQpXG4gIFx0e1xuICBcdFx0dmFyIGJpbiA9IFR5cHIuX2JpbjtcbiAgXHRcdC8vdmFyIGRpY3QgPSBbXTtcbiAgXHRcdHZhciBkaWN0ID0ge307XG4gIFx0XHR2YXIgY2FyciA9IFtdO1xuICBcdFx0XG4gIFx0XHR3aGlsZShvZmZzZXQ8ZW5kKVxuICBcdFx0e1xuICBcdFx0XHR2YXIgYjAgPSBkYXRhW29mZnNldF0sIGIxID0gZGF0YVtvZmZzZXQrMV0sIGIyID0gZGF0YVtvZmZzZXQrMl0sIGIzID0gZGF0YVtvZmZzZXQrM10sIGI0PWRhdGFbb2Zmc2V0KzRdO1xuICBcdFx0XHR2YXIgdnMgPSAxO1xuICBcdFx0XHR2YXIga2V5PW51bGwsIHZhbD1udWxsO1xuICBcdFx0XHQvLyBvcGVyYW5kXG4gIFx0XHRcdGlmKGIwPT0yOCkgeyB2YWwgPSBiaW4ucmVhZFNob3J0KGRhdGEsb2Zmc2V0KzEpOyAgdnM9MzsgfVxuICBcdFx0XHRpZihiMD09MjkpIHsgdmFsID0gYmluLnJlYWRJbnQgIChkYXRhLG9mZnNldCsxKTsgIHZzPTU7IH1cbiAgXHRcdFx0aWYoMzIgPD1iMCAmJiBiMDw9MjQ2KSB7IHZhbCA9IGIwLTEzOTsgIHZzPTE7IH1cbiAgXHRcdFx0aWYoMjQ3PD1iMCAmJiBiMDw9MjUwKSB7IHZhbCA9IChiMC0yNDcpKjI1NitiMSsxMDg7ICB2cz0yOyB9XG4gIFx0XHRcdGlmKDI1MTw9YjAgJiYgYjA8PTI1NCkgeyB2YWwgPS0oYjAtMjUxKSoyNTYtYjEtMTA4OyAgdnM9MjsgfVxuICBcdFx0XHRpZihiMD09MjU1KSB7ICB2YWwgPSBiaW4ucmVhZEludChkYXRhLCBvZmZzZXQrMSkvMHhmZmZmOyAgdnM9NTsgIHRocm93IFwidW5rbm93biBudW1iZXJcIjsgIH1cbiAgXHRcdFx0XG4gIFx0XHRcdGlmKGIwPT0zMCkgXG4gIFx0XHRcdHsgIFxuICBcdFx0XHRcdHZhciBuaWJzID0gW107XG4gIFx0XHRcdFx0dnMgPSAxO1xuICBcdFx0XHRcdHdoaWxlKHRydWUpXG4gIFx0XHRcdFx0e1xuICBcdFx0XHRcdFx0dmFyIGIgPSBkYXRhW29mZnNldCt2c107ICB2cysrO1xuICBcdFx0XHRcdFx0dmFyIG5pYjAgPSBiPj40LCBuaWIxID0gYiYweGY7XG4gIFx0XHRcdFx0XHRpZihuaWIwICE9IDB4ZikgeyBuaWJzLnB1c2gobmliMCk7IH0gIGlmKG5pYjEhPTB4ZikgeyBuaWJzLnB1c2gobmliMSk7IH1cbiAgXHRcdFx0XHRcdGlmKG5pYjE9PTB4ZikgeyBicmVhazsgfVxuICBcdFx0XHRcdH1cbiAgXHRcdFx0XHR2YXIgcyA9IFwiXCI7XG4gIFx0XHRcdFx0dmFyIGNoYXJzID0gWzAsMSwyLDMsNCw1LDYsNyw4LDksXCIuXCIsXCJlXCIsXCJlLVwiLFwicmVzZXJ2ZWRcIixcIi1cIixcImVuZE9mTnVtYmVyXCJdO1xuICBcdFx0XHRcdGZvcih2YXIgaT0wOyBpPG5pYnMubGVuZ3RoOyBpKyspIHsgcyArPSBjaGFyc1tuaWJzW2ldXTsgfVxuICBcdFx0XHRcdC8vY29uc29sZS5sb2cobmlicyk7XG4gIFx0XHRcdFx0dmFsID0gcGFyc2VGbG9hdChzKTtcbiAgXHRcdFx0fVxuICBcdFx0XHRcbiAgXHRcdFx0aWYoYjA8PTIxKVx0Ly8gb3BlcmF0b3JcbiAgXHRcdFx0e1xuICBcdFx0XHRcdHZhciBrZXlzID0gW1widmVyc2lvblwiLCBcIk5vdGljZVwiLCBcIkZ1bGxOYW1lXCIsIFwiRmFtaWx5TmFtZVwiLCBcIldlaWdodFwiLCBcIkZvbnRCQm94XCIsIFwiQmx1ZVZhbHVlc1wiLCBcIk90aGVyQmx1ZXNcIiwgXCJGYW1pbHlCbHVlc1wiLFwiRmFtaWx5T3RoZXJCbHVlc1wiLFxuICBcdFx0XHRcdFx0XCJTdGRIV1wiLCBcIlN0ZFZXXCIsIFwiZXNjYXBlXCIsIFwiVW5pcXVlSURcIiwgXCJYVUlEXCIsIFwiY2hhcnNldFwiLCBcIkVuY29kaW5nXCIsIFwiQ2hhclN0cmluZ3NcIiwgXCJQcml2YXRlXCIsIFwiU3VicnNcIiwgXG4gIFx0XHRcdFx0XHRcImRlZmF1bHRXaWR0aFhcIiwgXCJub21pbmFsV2lkdGhYXCJdO1xuICBcdFx0XHRcdFx0XG4gIFx0XHRcdFx0a2V5ID0ga2V5c1tiMF07ICB2cz0xO1xuICBcdFx0XHRcdGlmKGIwPT0xMikgeyBcbiAgXHRcdFx0XHRcdHZhciBrZXlzID0gWyBcIkNvcHlyaWdodFwiLCBcImlzRml4ZWRQaXRjaFwiLCBcIkl0YWxpY0FuZ2xlXCIsIFwiVW5kZXJsaW5lUG9zaXRpb25cIiwgXCJVbmRlcmxpbmVUaGlja25lc3NcIiwgXCJQYWludFR5cGVcIiwgXCJDaGFyc3RyaW5nVHlwZVwiLCBcIkZvbnRNYXRyaXhcIiwgXCJTdHJva2VXaWR0aFwiLCBcIkJsdWVTY2FsZVwiLFxuICBcdFx0XHRcdFx0XCJCbHVlU2hpZnRcIiwgXCJCbHVlRnV6elwiLCBcIlN0ZW1TbmFwSFwiLCBcIlN0ZW1TbmFwVlwiLCBcIkZvcmNlQm9sZFwiLCAwLDAsIFwiTGFuZ3VhZ2VHcm91cFwiLCBcIkV4cGFuc2lvbkZhY3RvclwiLCBcImluaXRpYWxSYW5kb21TZWVkXCIsXG4gIFx0XHRcdFx0XHRcIlN5bnRoZXRpY0Jhc2VcIiwgXCJQb3N0U2NyaXB0XCIsIFwiQmFzZUZvbnROYW1lXCIsIFwiQmFzZUZvbnRCbGVuZFwiLCAwLDAsMCwwLDAsMCwgXG4gIFx0XHRcdFx0XHRcIlJPU1wiLCBcIkNJREZvbnRWZXJzaW9uXCIsIFwiQ0lERm9udFJldmlzaW9uXCIsIFwiQ0lERm9udFR5cGVcIiwgXCJDSURDb3VudFwiLCBcIlVJREJhc2VcIiwgXCJGREFycmF5XCIsIFwiRkRTZWxlY3RcIiwgXCJGb250TmFtZVwiXTtcbiAgXHRcdFx0XHRcdGtleSA9IGtleXNbYjFdOyAgdnM9MjsgXG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHRcdFxuICBcdFx0XHRpZihrZXkhPW51bGwpIHsgIGRpY3Rba2V5XSA9IGNhcnIubGVuZ3RoPT0xID8gY2FyclswXSA6IGNhcnI7ICBjYXJyPVtdOyB9XG4gIFx0XHRcdGVsc2UgIHsgY2Fyci5wdXNoKHZhbCk7IH0gIFxuICBcdFx0XHRcbiAgXHRcdFx0b2Zmc2V0ICs9IHZzO1x0XHRcbiAgXHRcdH1cdFxuICBcdFx0cmV0dXJuIGRpY3Q7XG4gIFx0fTtcblxuXG4gIFR5cHIuY21hcCA9IHt9O1xuICBUeXByLmNtYXAucGFyc2UgPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQsIGxlbmd0aClcbiAge1xuICBcdGRhdGEgPSBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgpO1xuICBcdG9mZnNldCA9IDA7XG4gIFx0dmFyIGJpbiA9IFR5cHIuX2JpbjtcbiAgXHR2YXIgb2JqID0ge307XG4gIFx0dmFyIHZlcnNpb24gICA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcbiAgXHR2YXIgbnVtVGFibGVzID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuICBcdFxuICBcdC8vY29uc29sZS5sb2codmVyc2lvbiwgbnVtVGFibGVzKTtcbiAgXHRcbiAgXHR2YXIgb2ZmcyA9IFtdO1xuICBcdG9iai50YWJsZXMgPSBbXTtcbiAgXHRcbiAgXHRcbiAgXHRmb3IodmFyIGk9MDsgaTxudW1UYWJsZXM7IGkrKylcbiAgXHR7XG4gIFx0XHR2YXIgcGxhdGZvcm1JRCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcbiAgXHRcdHZhciBlbmNvZGluZ0lEID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuICBcdFx0dmFyIG5vZmZzZXQgPSBiaW4ucmVhZFVpbnQoZGF0YSwgb2Zmc2V0KTsgICAgICAgb2Zmc2V0ICs9IDQ7XG4gIFx0XHRcbiAgXHRcdHZhciBpZCA9IFwicFwiK3BsYXRmb3JtSUQrXCJlXCIrZW5jb2RpbmdJRDtcbiAgXHRcdFxuICBcdFx0Ly9jb25zb2xlLmxvZyhcImNtYXAgc3VidGFibGVcIiwgcGxhdGZvcm1JRCwgZW5jb2RpbmdJRCwgbm9mZnNldCk7XG4gIFx0XHRcbiAgXHRcdFxuICBcdFx0dmFyIHRpbmQgPSBvZmZzLmluZGV4T2Yobm9mZnNldCk7XG4gIFx0XHRcbiAgXHRcdGlmKHRpbmQ9PS0xKVxuICBcdFx0e1xuICBcdFx0XHR0aW5kID0gb2JqLnRhYmxlcy5sZW5ndGg7XG4gIFx0XHRcdHZhciBzdWJ0O1xuICBcdFx0XHRvZmZzLnB1c2gobm9mZnNldCk7XG4gIFx0XHRcdHZhciBmb3JtYXQgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBub2Zmc2V0KTtcbiAgXHRcdFx0aWYgICAgIChmb3JtYXQ9PSAwKSB7IHN1YnQgPSBUeXByLmNtYXAucGFyc2UwKGRhdGEsIG5vZmZzZXQpOyB9XG4gIFx0XHRcdGVsc2UgaWYoZm9ybWF0PT0gNCkgeyBzdWJ0ID0gVHlwci5jbWFwLnBhcnNlNChkYXRhLCBub2Zmc2V0KTsgfVxuICBcdFx0XHRlbHNlIGlmKGZvcm1hdD09IDYpIHsgc3VidCA9IFR5cHIuY21hcC5wYXJzZTYoZGF0YSwgbm9mZnNldCk7IH1cbiAgXHRcdFx0ZWxzZSBpZihmb3JtYXQ9PTEyKSB7IHN1YnQgPSBUeXByLmNtYXAucGFyc2UxMihkYXRhLG5vZmZzZXQpOyB9XG4gIFx0XHRcdGVsc2UgeyBjb25zb2xlLmxvZyhcInVua25vd24gZm9ybWF0OiBcIitmb3JtYXQsIHBsYXRmb3JtSUQsIGVuY29kaW5nSUQsIG5vZmZzZXQpOyB9XG4gIFx0XHRcdG9iai50YWJsZXMucHVzaChzdWJ0KTtcbiAgXHRcdH1cbiAgXHRcdFxuICBcdFx0aWYob2JqW2lkXSE9bnVsbCkgeyB0aHJvdyBcIm11bHRpcGxlIHRhYmxlcyBmb3Igb25lIHBsYXRmb3JtK2VuY29kaW5nXCI7IH1cbiAgXHRcdG9ialtpZF0gPSB0aW5kO1xuICBcdH1cbiAgXHRyZXR1cm4gb2JqO1xuICB9O1xuXG4gIFR5cHIuY21hcC5wYXJzZTAgPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQpXG4gIHtcbiAgXHR2YXIgYmluID0gVHlwci5fYmluO1xuICBcdHZhciBvYmogPSB7fTtcbiAgXHRvYmouZm9ybWF0ID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuICBcdHZhciBsZW4gICAgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG4gIFx0dmFyIGxhbmcgICA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcbiAgXHRvYmoubWFwID0gW107XG4gIFx0Zm9yKHZhciBpPTA7IGk8bGVuLTY7IGkrKykgeyBvYmoubWFwLnB1c2goZGF0YVtvZmZzZXQraV0pOyB9XG4gIFx0cmV0dXJuIG9iajtcbiAgfTtcblxuICBUeXByLmNtYXAucGFyc2U0ID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0KVxuICB7XG4gIFx0dmFyIGJpbiA9IFR5cHIuX2JpbjtcbiAgXHR2YXIgb2Zmc2V0MCA9IG9mZnNldDtcbiAgXHR2YXIgb2JqID0ge307XG4gIFx0XG4gIFx0b2JqLmZvcm1hdCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0dmFyIGxlbmd0aCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0dmFyIGxhbmd1YWdlID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9MjtcbiAgXHR2YXIgc2VnQ291bnRYMiA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0dmFyIHNlZ0NvdW50ID0gc2VnQ291bnRYMi8yO1xuICBcdG9iai5zZWFyY2hSYW5nZSA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0b2JqLmVudHJ5U2VsZWN0b3IgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuICBcdG9iai5yYW5nZVNoaWZ0ID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9MjtcbiAgXHRvYmouZW5kQ291bnQgICA9IGJpbi5yZWFkVXNob3J0cyhkYXRhLCBvZmZzZXQsIHNlZ0NvdW50KTsgIG9mZnNldCArPSBzZWdDb3VudCoyO1xuICBcdG9mZnNldCs9MjtcbiAgXHRvYmouc3RhcnRDb3VudCA9IGJpbi5yZWFkVXNob3J0cyhkYXRhLCBvZmZzZXQsIHNlZ0NvdW50KTsgIG9mZnNldCArPSBzZWdDb3VudCoyO1xuICBcdG9iai5pZERlbHRhID0gW107XG4gIFx0Zm9yKHZhciBpPTA7IGk8c2VnQ291bnQ7IGkrKykge29iai5pZERlbHRhLnB1c2goYmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpKTsgIG9mZnNldCs9Mjt9XG4gIFx0b2JqLmlkUmFuZ2VPZmZzZXQgPSBiaW4ucmVhZFVzaG9ydHMoZGF0YSwgb2Zmc2V0LCBzZWdDb3VudCk7ICBvZmZzZXQgKz0gc2VnQ291bnQqMjtcbiAgXHRvYmouZ2x5cGhJZEFycmF5ID0gW107XG4gIFx0d2hpbGUob2Zmc2V0PCBvZmZzZXQwK2xlbmd0aCkge29iai5nbHlwaElkQXJyYXkucHVzaChiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpKTsgIG9mZnNldCs9Mjt9XG4gIFx0cmV0dXJuIG9iajtcbiAgfTtcblxuICBUeXByLmNtYXAucGFyc2U2ID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0KVxuICB7XG4gIFx0dmFyIGJpbiA9IFR5cHIuX2JpbjtcbiAgXHR2YXIgb2JqID0ge307XG4gIFx0XG4gIFx0b2JqLmZvcm1hdCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0dmFyIGxlbmd0aCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0dmFyIGxhbmd1YWdlID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9MjtcbiAgXHRvYmouZmlyc3RDb2RlID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9MjtcbiAgXHR2YXIgZW50cnlDb3VudCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0b2JqLmdseXBoSWRBcnJheSA9IFtdO1xuICBcdGZvcih2YXIgaT0wOyBpPGVudHJ5Q291bnQ7IGkrKykge29iai5nbHlwaElkQXJyYXkucHVzaChiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpKTsgIG9mZnNldCs9Mjt9XG4gIFx0XG4gIFx0cmV0dXJuIG9iajtcbiAgfTtcblxuICBUeXByLmNtYXAucGFyc2UxMiA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldClcbiAge1xuICBcdHZhciBiaW4gPSBUeXByLl9iaW47XG4gIFx0dmFyIG9iaiA9IHt9O1xuICBcdFxuICBcdG9iai5mb3JtYXQgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuICBcdG9mZnNldCArPSAyO1xuICBcdHZhciBsZW5ndGggPSBiaW4ucmVhZFVpbnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9NDtcbiAgXHR2YXIgbGFuZyAgID0gYmluLnJlYWRVaW50KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTQ7XG4gIFx0dmFyIG5Hcm91cHM9IGJpbi5yZWFkVWludChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz00O1xuICBcdG9iai5ncm91cHMgPSBbXTtcbiAgXHRcbiAgXHRmb3IodmFyIGk9MDsgaTxuR3JvdXBzOyBpKyspICBcbiAgXHR7XG4gIFx0XHR2YXIgb2ZmID0gb2Zmc2V0ICsgaSAqIDEyO1xuICBcdFx0dmFyIHN0YXJ0Q2hhckNvZGUgPSBiaW4ucmVhZFVpbnQoZGF0YSwgb2ZmKzApO1xuICBcdFx0dmFyIGVuZENoYXJDb2RlICAgPSBiaW4ucmVhZFVpbnQoZGF0YSwgb2ZmKzQpO1xuICBcdFx0dmFyIHN0YXJ0R2x5cGhJRCAgPSBiaW4ucmVhZFVpbnQoZGF0YSwgb2ZmKzgpO1xuICBcdFx0b2JqLmdyb3Vwcy5wdXNoKFsgIHN0YXJ0Q2hhckNvZGUsIGVuZENoYXJDb2RlLCBzdGFydEdseXBoSUQgIF0pO1xuICBcdH1cbiAgXHRyZXR1cm4gb2JqO1xuICB9O1xuXG4gIFR5cHIuZ2x5ZiA9IHt9O1xuICBUeXByLmdseWYucGFyc2UgPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQsIGxlbmd0aCwgZm9udClcbiAge1xuICBcdHZhciBvYmogPSBbXTtcbiAgXHRmb3IodmFyIGc9MDsgZzxmb250Lm1heHAubnVtR2x5cGhzOyBnKyspIHsgb2JqLnB1c2gobnVsbCk7IH1cbiAgXHRyZXR1cm4gb2JqO1xuICB9O1xuXG4gIFR5cHIuZ2x5Zi5fcGFyc2VHbHlmID0gZnVuY3Rpb24oZm9udCwgZylcbiAge1xuICBcdHZhciBiaW4gPSBUeXByLl9iaW47XG4gIFx0dmFyIGRhdGEgPSBmb250Ll9kYXRhO1xuICBcdFxuICBcdHZhciBvZmZzZXQgPSBUeXByLl90YWJPZmZzZXQoZGF0YSwgXCJnbHlmXCIsIGZvbnQuX29mZnNldCkgKyBmb250LmxvY2FbZ107XG4gIFx0XHRcbiAgXHRpZihmb250LmxvY2FbZ109PWZvbnQubG9jYVtnKzFdKSB7IHJldHVybiBudWxsOyB9XG4gIFx0XHRcbiAgXHR2YXIgZ2wgPSB7fTtcbiAgXHRcdFxuICBcdGdsLm5vYyAgPSBiaW4ucmVhZFNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XHRcdC8vIG51bWJlciBvZiBjb250b3Vyc1xuICBcdGdsLnhNaW4gPSBiaW4ucmVhZFNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0Z2wueU1pbiA9IGJpbi5yZWFkU2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9MjtcbiAgXHRnbC54TWF4ID0gYmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuICBcdGdsLnlNYXggPSBiaW4ucmVhZFNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0XG4gIFx0aWYoZ2wueE1pbj49Z2wueE1heCB8fCBnbC55TWluPj1nbC55TWF4KSB7IHJldHVybiBudWxsOyB9XG4gIFx0XHRcbiAgXHRpZihnbC5ub2M+MClcbiAgXHR7XG4gIFx0XHRnbC5lbmRQdHMgPSBbXTtcbiAgXHRcdGZvcih2YXIgaT0wOyBpPGdsLm5vYzsgaSsrKSB7IGdsLmVuZFB0cy5wdXNoKGJpbi5yZWFkVXNob3J0KGRhdGEsb2Zmc2V0KSk7IG9mZnNldCs9MjsgfVxuICBcdFx0XG4gIFx0XHR2YXIgaW5zdHJ1Y3Rpb25MZW5ndGggPSBiaW4ucmVhZFVzaG9ydChkYXRhLG9mZnNldCk7IG9mZnNldCs9MjtcbiAgXHRcdGlmKChkYXRhLmxlbmd0aC1vZmZzZXQpPGluc3RydWN0aW9uTGVuZ3RoKSB7IHJldHVybiBudWxsOyB9XG4gIFx0XHRnbC5pbnN0cnVjdGlvbnMgPSBiaW4ucmVhZEJ5dGVzKGRhdGEsIG9mZnNldCwgaW5zdHJ1Y3Rpb25MZW5ndGgpOyAgIG9mZnNldCs9aW5zdHJ1Y3Rpb25MZW5ndGg7XG4gIFx0XHRcbiAgXHRcdHZhciBjcmRudW0gPSBnbC5lbmRQdHNbZ2wubm9jLTFdKzE7XG4gIFx0XHRnbC5mbGFncyA9IFtdO1xuICBcdFx0Zm9yKHZhciBpPTA7IGk8Y3JkbnVtOyBpKysgKSBcbiAgXHRcdHsgXG4gIFx0XHRcdHZhciBmbGFnID0gZGF0YVtvZmZzZXRdOyAgb2Zmc2V0Kys7IFxuICBcdFx0XHRnbC5mbGFncy5wdXNoKGZsYWcpOyBcbiAgXHRcdFx0aWYoKGZsYWcmOCkhPTApXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHR2YXIgcmVwID0gZGF0YVtvZmZzZXRdOyAgb2Zmc2V0Kys7XG4gIFx0XHRcdFx0Zm9yKHZhciBqPTA7IGo8cmVwOyBqKyspIHsgZ2wuZmxhZ3MucHVzaChmbGFnKTsgaSsrOyB9XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHRcdGdsLnhzID0gW107XG4gIFx0XHRmb3IodmFyIGk9MDsgaTxjcmRudW07IGkrKykge1xuICBcdFx0XHR2YXIgaTg9KChnbC5mbGFnc1tpXSYyKSE9MCksIHNhbWU9KChnbC5mbGFnc1tpXSYxNikhPTApOyAgXG4gIFx0XHRcdGlmKGk4KSB7IGdsLnhzLnB1c2goc2FtZSA/IGRhdGFbb2Zmc2V0XSA6IC1kYXRhW29mZnNldF0pOyAgb2Zmc2V0Kys7IH1cbiAgXHRcdFx0ZWxzZVxuICBcdFx0XHR7XG4gIFx0XHRcdFx0aWYoc2FtZSkgeyBnbC54cy5wdXNoKDApOyB9XG4gIFx0XHRcdFx0ZWxzZSB7IGdsLnhzLnB1c2goYmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpKTsgIG9mZnNldCs9MjsgfVxuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0XHRnbC55cyA9IFtdO1xuICBcdFx0Zm9yKHZhciBpPTA7IGk8Y3JkbnVtOyBpKyspIHtcbiAgXHRcdFx0dmFyIGk4PSgoZ2wuZmxhZ3NbaV0mNCkhPTApLCBzYW1lPSgoZ2wuZmxhZ3NbaV0mMzIpIT0wKTsgIFxuICBcdFx0XHRpZihpOCkgeyBnbC55cy5wdXNoKHNhbWUgPyBkYXRhW29mZnNldF0gOiAtZGF0YVtvZmZzZXRdKTsgIG9mZnNldCsrOyB9XG4gIFx0XHRcdGVsc2VcbiAgXHRcdFx0e1xuICBcdFx0XHRcdGlmKHNhbWUpIHsgZ2wueXMucHVzaCgwKTsgfVxuICBcdFx0XHRcdGVsc2UgeyBnbC55cy5wdXNoKGJpbi5yZWFkU2hvcnQoZGF0YSwgb2Zmc2V0KSk7ICBvZmZzZXQrPTI7IH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdFx0dmFyIHggPSAwLCB5ID0gMDtcbiAgXHRcdGZvcih2YXIgaT0wOyBpPGNyZG51bTsgaSsrKSB7IHggKz0gZ2wueHNbaV07IHkgKz0gZ2wueXNbaV07ICBnbC54c1tpXT14OyAgZ2wueXNbaV09eTsgfVxuICBcdFx0Ly9jb25zb2xlLmxvZyhlbmRQdHNPZkNvbnRvdXJzLCBpbnN0cnVjdGlvbkxlbmd0aCwgaW5zdHJ1Y3Rpb25zLCBmbGFncywgeENvb3JkaW5hdGVzLCB5Q29vcmRpbmF0ZXMpO1xuICBcdH1cbiAgXHRlbHNlXG4gIFx0e1xuICBcdFx0dmFyIEFSR18xX0FORF8yX0FSRV9XT1JEU1x0PSAxPDwwO1xuICBcdFx0dmFyIEFSR1NfQVJFX1hZX1ZBTFVFU1x0XHQ9IDE8PDE7XG4gIFx0XHR2YXIgV0VfSEFWRV9BX1NDQUxFXHRcdFx0PSAxPDwzO1xuICBcdFx0dmFyIE1PUkVfQ09NUE9ORU5UU1x0XHRcdD0gMTw8NTtcbiAgXHRcdHZhciBXRV9IQVZFX0FOX1hfQU5EX1lfU0NBTEU9IDE8PDY7XG4gIFx0XHR2YXIgV0VfSEFWRV9BX1RXT19CWV9UV09cdD0gMTw8NztcbiAgXHRcdHZhciBXRV9IQVZFX0lOU1RSVUNUSU9OU1x0PSAxPDw4O1xuICBcdFx0XG4gIFx0XHRnbC5wYXJ0cyA9IFtdO1xuICBcdFx0dmFyIGZsYWdzO1xuICBcdFx0ZG8ge1xuICBcdFx0XHRmbGFncyA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcbiAgXHRcdFx0dmFyIHBhcnQgPSB7IG06e2E6MSxiOjAsYzowLGQ6MSx0eDowLHR5OjB9LCBwMTotMSwgcDI6LTEgfTsgIGdsLnBhcnRzLnB1c2gocGFydCk7XG4gIFx0XHRcdHBhcnQuZ2x5cGhJbmRleCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcbiAgXHRcdFx0aWYgKCBmbGFncyAmIEFSR18xX0FORF8yX0FSRV9XT1JEUykge1xuICBcdFx0XHRcdHZhciBhcmcxID0gYmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG4gIFx0XHRcdFx0dmFyIGFyZzIgPSBiaW4ucmVhZFNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHR2YXIgYXJnMSA9IGJpbi5yZWFkSW50OChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICsrO1xuICBcdFx0XHRcdHZhciBhcmcyID0gYmluLnJlYWRJbnQ4KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKys7XG4gIFx0XHRcdH1cbiAgXHRcdFx0XG4gIFx0XHRcdGlmKGZsYWdzICYgQVJHU19BUkVfWFlfVkFMVUVTKSB7IHBhcnQubS50eCA9IGFyZzE7ICBwYXJ0Lm0udHkgPSBhcmcyOyB9XG4gIFx0XHRcdGVsc2UgIHsgIHBhcnQucDE9YXJnMTsgIHBhcnQucDI9YXJnMjsgIH1cbiAgXHRcdFx0Ly9wYXJ0Lm0udHggPSBhcmcxOyAgcGFydC5tLnR5ID0gYXJnMjtcbiAgXHRcdFx0Ly9lbHNlIHsgdGhyb3cgXCJwYXJhbXMgYXJlIG5vdCBYWSB2YWx1ZXNcIjsgfVxuICBcdFx0XHRcbiAgXHRcdFx0aWYgKCBmbGFncyAmIFdFX0hBVkVfQV9TQ0FMRSApIHtcbiAgXHRcdFx0XHRwYXJ0Lm0uYSA9IHBhcnQubS5kID0gYmluLnJlYWRGMmRvdDE0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjsgICAgXG4gIFx0XHRcdH0gZWxzZSBpZiAoIGZsYWdzICYgV0VfSEFWRV9BTl9YX0FORF9ZX1NDQUxFICkge1xuICBcdFx0XHRcdHBhcnQubS5hID0gYmluLnJlYWRGMmRvdDE0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjsgXG4gIFx0XHRcdFx0cGFydC5tLmQgPSBiaW4ucmVhZEYyZG90MTQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyOyBcbiAgXHRcdFx0fSBlbHNlIGlmICggZmxhZ3MgJiBXRV9IQVZFX0FfVFdPX0JZX1RXTyApIHtcbiAgXHRcdFx0XHRwYXJ0Lm0uYSA9IGJpbi5yZWFkRjJkb3QxNChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7IFxuICBcdFx0XHRcdHBhcnQubS5iID0gYmluLnJlYWRGMmRvdDE0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjsgXG4gIFx0XHRcdFx0cGFydC5tLmMgPSBiaW4ucmVhZEYyZG90MTQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyOyBcbiAgXHRcdFx0XHRwYXJ0Lm0uZCA9IGJpbi5yZWFkRjJkb3QxNChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7IFxuICBcdFx0XHR9XG4gIFx0XHR9IHdoaWxlICggZmxhZ3MgJiBNT1JFX0NPTVBPTkVOVFMgKSBcbiAgXHRcdGlmIChmbGFncyAmIFdFX0hBVkVfSU5TVFJVQ1RJT05TKXtcbiAgXHRcdFx0dmFyIG51bUluc3RyID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuICBcdFx0XHRnbC5pbnN0ciA9IFtdO1xuICBcdFx0XHRmb3IodmFyIGk9MDsgaTxudW1JbnN0cjsgaSsrKSB7IGdsLmluc3RyLnB1c2goZGF0YVtvZmZzZXRdKTsgIG9mZnNldCsrOyB9XG4gIFx0XHR9XG4gIFx0fVxuICBcdHJldHVybiBnbDtcbiAgfTtcblxuXG4gIFR5cHIuR1BPUyA9IHt9O1xuICBUeXByLkdQT1MucGFyc2UgPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQsIGxlbmd0aCwgZm9udCkgeyAgcmV0dXJuIFR5cHIuX2xjdGYucGFyc2UoZGF0YSwgb2Zmc2V0LCBsZW5ndGgsIGZvbnQsIFR5cHIuR1BPUy5zdWJ0KTsgIH07XG5cblxuICBUeXByLkdQT1Muc3VidCA9IGZ1bmN0aW9uKGRhdGEsIGx0eXBlLCBvZmZzZXQpXHQvLyBsb29rdXAgdHlwZVxuICB7XG4gIFx0dmFyIGJpbiA9IFR5cHIuX2Jpbiwgb2Zmc2V0MCA9IG9mZnNldCwgdGFiID0ge307XG4gIFx0XG4gIFx0dGFiLmZtdCAgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuICBcdFxuICBcdC8vY29uc29sZS5sb2cobHR5cGUsIHRhYi5mbXQpO1xuICBcdFxuICBcdGlmKGx0eXBlPT0xIHx8IGx0eXBlPT0yIHx8IGx0eXBlPT0zIHx8IGx0eXBlPT03IHx8IChsdHlwZT09OCAmJiB0YWIuZm10PD0yKSkge1xuICBcdFx0dmFyIGNvdk9mZiAgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuICBcdFx0dGFiLmNvdmVyYWdlID0gVHlwci5fbGN0Zi5yZWFkQ292ZXJhZ2UoZGF0YSwgY292T2ZmK29mZnNldDApO1xuICBcdH1cbiAgXHRpZihsdHlwZT09MSAmJiB0YWIuZm10PT0xKSB7XG4gIFx0XHR2YXIgdmFsRm10MSA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0XHR2YXIgb25lczEgPSBUeXByLl9sY3RmLm51bU9mT25lcyh2YWxGbXQxKTtcbiAgXHRcdGlmKHZhbEZtdDEhPTApICB7IHRhYi5wb3MgPSBUeXByLkdQT1MucmVhZFZhbHVlUmVjb3JkKGRhdGEsIG9mZnNldCwgdmFsRm10MSk7IH1cbiAgXHR9XG4gIFx0ZWxzZSBpZihsdHlwZT09Mikge1xuICBcdFx0dmFyIHZhbEZtdDEgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuICBcdFx0dmFyIHZhbEZtdDIgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuICBcdFx0dmFyIG9uZXMxID0gVHlwci5fbGN0Zi5udW1PZk9uZXModmFsRm10MSk7XG4gIFx0XHR2YXIgb25lczIgPSBUeXByLl9sY3RmLm51bU9mT25lcyh2YWxGbXQyKTtcbiAgXHRcdGlmKHRhYi5mbXQ9PTEpXG4gIFx0XHR7XG4gIFx0XHRcdHRhYi5wYWlyc2V0cyA9IFtdO1xuICBcdFx0XHR2YXIgcHNjID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9MjsgIC8vIFBhaXJTZXRDb3VudFxuICBcdFx0XHRcbiAgXHRcdFx0Zm9yKHZhciBpPTA7IGk8cHNjOyBpKyspXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHR2YXIgcHNvZmYgPSBvZmZzZXQwICsgYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9MjtcbiAgXHRcdFx0XHRcbiAgXHRcdFx0XHR2YXIgcHZjID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgcHNvZmYpOyAgcHNvZmYrPTI7XG4gIFx0XHRcdFx0dmFyIGFyciA9IFtdO1xuICBcdFx0XHRcdGZvcih2YXIgaj0wOyBqPHB2YzsgaisrKVxuICBcdFx0XHRcdHtcbiAgXHRcdFx0XHRcdHZhciBnaWQyID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgcHNvZmYpOyAgcHNvZmYrPTI7XG4gIFx0XHRcdFx0XHR2YXIgdmFsdWUxLCB2YWx1ZTI7XG4gIFx0XHRcdFx0XHRpZih2YWxGbXQxIT0wKSB7ICB2YWx1ZTEgPSBUeXByLkdQT1MucmVhZFZhbHVlUmVjb3JkKGRhdGEsIHBzb2ZmLCB2YWxGbXQxKTsgIHBzb2ZmKz1vbmVzMSoyOyAgfVxuICBcdFx0XHRcdFx0aWYodmFsRm10MiE9MCkgeyAgdmFsdWUyID0gVHlwci5HUE9TLnJlYWRWYWx1ZVJlY29yZChkYXRhLCBwc29mZiwgdmFsRm10Mik7ICBwc29mZis9b25lczIqMjsgIH1cbiAgXHRcdFx0XHRcdC8vaWYodmFsdWUxIT1udWxsKSB0aHJvdyBcImVcIjtcbiAgXHRcdFx0XHRcdGFyci5wdXNoKHtnaWQyOmdpZDIsIHZhbDE6dmFsdWUxLCB2YWwyOnZhbHVlMn0pO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0XHR0YWIucGFpcnNldHMucHVzaChhcnIpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0XHRpZih0YWIuZm10PT0yKVxuICBcdFx0e1xuICBcdFx0XHR2YXIgY2xhc3NEZWYxID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9MjtcbiAgXHRcdFx0dmFyIGNsYXNzRGVmMiA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0XHRcdHZhciBjbGFzczFDb3VudCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0XHRcdHZhciBjbGFzczJDb3VudCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0XHRcdFxuICBcdFx0XHR0YWIuY2xhc3NEZWYxID0gVHlwci5fbGN0Zi5yZWFkQ2xhc3NEZWYoZGF0YSwgb2Zmc2V0MCArIGNsYXNzRGVmMSk7XG4gIFx0XHRcdHRhYi5jbGFzc0RlZjIgPSBUeXByLl9sY3RmLnJlYWRDbGFzc0RlZihkYXRhLCBvZmZzZXQwICsgY2xhc3NEZWYyKTtcbiAgXHRcdFx0XG4gIFx0XHRcdHRhYi5tYXRyaXggPSBbXTtcbiAgXHRcdFx0Zm9yKHZhciBpPTA7IGk8Y2xhc3MxQ291bnQ7IGkrKylcbiAgXHRcdFx0e1xuICBcdFx0XHRcdHZhciByb3cgPSBbXTtcbiAgXHRcdFx0XHRmb3IodmFyIGo9MDsgajxjbGFzczJDb3VudDsgaisrKVxuICBcdFx0XHRcdHtcbiAgXHRcdFx0XHRcdHZhciB2YWx1ZTEgPSBudWxsLCB2YWx1ZTIgPSBudWxsO1xuICBcdFx0XHRcdFx0aWYodGFiLnZhbEZtdDEhPTApIHsgdmFsdWUxID0gVHlwci5HUE9TLnJlYWRWYWx1ZVJlY29yZChkYXRhLCBvZmZzZXQsIHRhYi52YWxGbXQxKTsgIG9mZnNldCs9b25lczEqMjsgfVxuICBcdFx0XHRcdFx0aWYodGFiLnZhbEZtdDIhPTApIHsgdmFsdWUyID0gVHlwci5HUE9TLnJlYWRWYWx1ZVJlY29yZChkYXRhLCBvZmZzZXQsIHRhYi52YWxGbXQyKTsgIG9mZnNldCs9b25lczIqMjsgfVxuICBcdFx0XHRcdFx0cm93LnB1c2goe3ZhbDE6dmFsdWUxLCB2YWwyOnZhbHVlMn0pO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0XHR0YWIubWF0cml4LnB1c2gocm93KTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cbiAgXHRyZXR1cm4gdGFiO1xuICB9O1xuXG5cbiAgVHlwci5HUE9TLnJlYWRWYWx1ZVJlY29yZCA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgdmFsRm10KVxuICB7XG4gIFx0dmFyIGJpbiA9IFR5cHIuX2JpbjtcbiAgXHR2YXIgYXJyID0gW107XG4gIFx0YXJyLnB1c2goICh2YWxGbXQmMSkgPyBiaW4ucmVhZFNob3J0KGRhdGEsIG9mZnNldCkgOiAwICk7ICBvZmZzZXQgKz0gKHZhbEZtdCYxKSA/IDIgOiAwOyAgLy8gWF9QTEFDRU1FTlRcbiAgXHRhcnIucHVzaCggKHZhbEZtdCYyKSA/IGJpbi5yZWFkU2hvcnQoZGF0YSwgb2Zmc2V0KSA6IDAgKTsgIG9mZnNldCArPSAodmFsRm10JjIpID8gMiA6IDA7ICAvLyBZX1BMQUNFTUVOVFxuICBcdGFyci5wdXNoKCAodmFsRm10JjQpID8gYmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpIDogMCApOyAgb2Zmc2V0ICs9ICh2YWxGbXQmNCkgPyAyIDogMDsgIC8vIFhfQURWQU5DRVxuICBcdGFyci5wdXNoKCAodmFsRm10JjgpID8gYmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpIDogMCApOyAgb2Zmc2V0ICs9ICh2YWxGbXQmOCkgPyAyIDogMDsgIC8vIFlfQURWQU5DRVxuICBcdHJldHVybiBhcnI7XG4gIH07XG5cbiAgVHlwci5HU1VCID0ge307XG4gIFR5cHIuR1NVQi5wYXJzZSA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgbGVuZ3RoLCBmb250KSB7ICByZXR1cm4gVHlwci5fbGN0Zi5wYXJzZShkYXRhLCBvZmZzZXQsIGxlbmd0aCwgZm9udCwgVHlwci5HU1VCLnN1YnQpOyAgfTtcblxuXG4gIFR5cHIuR1NVQi5zdWJ0ID0gZnVuY3Rpb24oZGF0YSwgbHR5cGUsIG9mZnNldClcdC8vIGxvb2t1cCB0eXBlXG4gIHtcbiAgXHR2YXIgYmluID0gVHlwci5fYmluLCBvZmZzZXQwID0gb2Zmc2V0LCB0YWIgPSB7fTtcbiAgXHRcbiAgXHR0YWIuZm10ICA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0XG4gIFx0aWYobHR5cGUhPTEgJiYgbHR5cGUhPTQgJiYgbHR5cGUhPTUgJiYgbHR5cGUhPTYpIHsgcmV0dXJuIG51bGw7IH1cbiAgXHRcbiAgXHRpZihsdHlwZT09MSB8fCBsdHlwZT09NCB8fCAobHR5cGU9PTUgJiYgdGFiLmZtdDw9MikgfHwgKGx0eXBlPT02ICYmIHRhYi5mbXQ8PTIpKSB7XG4gIFx0XHR2YXIgY292T2ZmICA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0XHR0YWIuY292ZXJhZ2UgPSBUeXByLl9sY3RmLnJlYWRDb3ZlcmFnZShkYXRhLCBvZmZzZXQwK2Nvdk9mZik7XHQvLyBub3QgYWx3YXlzIGlzIGNvdmVyYWdlIGhlcmVcbiAgXHR9XG4gIFx0XG4gIFx0aWYobHR5cGU9PTEpIHtcdFxuICBcdFx0aWYodGFiLmZtdD09MSkge1xuICBcdFx0XHR0YWIuZGVsdGEgPSBiaW4ucmVhZFNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0XHR9XG4gIFx0XHRlbHNlIGlmKHRhYi5mbXQ9PTIpIHtcbiAgXHRcdFx0dmFyIGNudCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0XHRcdHRhYi5uZXdnID0gYmluLnJlYWRVc2hvcnRzKGRhdGEsIG9mZnNldCwgY250KTsgIG9mZnNldCs9dGFiLm5ld2cubGVuZ3RoKjI7XG4gIFx0XHR9XG4gIFx0fVxuICBcdC8vICBMaWdhdHVyZSBTdWJzdGl0dXRpb24gU3VidGFibGVcbiAgXHRlbHNlIGlmKGx0eXBlPT00KSB7XG4gIFx0XHR0YWIudmFscyA9IFtdO1xuICBcdFx0dmFyIGNudCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0XHRmb3IodmFyIGk9MDsgaTxjbnQ7IGkrKykge1xuICBcdFx0XHR2YXIgbG9mZiA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0XHRcdHRhYi52YWxzLnB1c2goVHlwci5HU1VCLnJlYWRMaWdhdHVyZVNldChkYXRhLCBvZmZzZXQwK2xvZmYpKTtcbiAgXHRcdH1cbiAgXHRcdC8vY29uc29sZS5sb2codGFiLmNvdmVyYWdlKTtcbiAgXHRcdC8vY29uc29sZS5sb2codGFiLnZhbHMpO1xuICBcdH0gXG4gIFx0Ly8gIENvbnRleHR1YWwgU3Vic3RpdHV0aW9uIFN1YnRhYmxlXG4gIFx0ZWxzZSBpZihsdHlwZT09NSkge1xuICBcdFx0aWYodGFiLmZtdD09Mikge1xuICBcdFx0XHR2YXIgY0RlZk9mZnNldCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0XHRcdHRhYi5jRGVmID0gVHlwci5fbGN0Zi5yZWFkQ2xhc3NEZWYoZGF0YSwgb2Zmc2V0MCArIGNEZWZPZmZzZXQpO1xuICBcdFx0XHR0YWIuc2NzZXQgPSBbXTtcbiAgXHRcdFx0dmFyIHN1YkNsYXNzU2V0Q291bnQgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuICBcdFx0XHRmb3IodmFyIGk9MDsgaTxzdWJDbGFzc1NldENvdW50OyBpKyspXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHR2YXIgc2NzT2ZmID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9MjtcbiAgXHRcdFx0XHR0YWIuc2NzZXQucHVzaCggIHNjc09mZj09MCA/IG51bGwgOiBUeXByLkdTVUIucmVhZFN1YkNsYXNzU2V0KGRhdGEsIG9mZnNldDAgKyBzY3NPZmYpICApO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0XHQvL2Vsc2UgY29uc29sZS5sb2coXCJ1bmtub3duIHRhYmxlIGZvcm1hdFwiLCB0YWIuZm10KTtcbiAgXHR9XG4gIFx0Ly8qXG4gIFx0ZWxzZSBpZihsdHlwZT09Nikge1xuICBcdFx0LypcbiAgXHRcdGlmKHRhYi5mbXQ9PTIpIHtcbiAgXHRcdFx0dmFyIGJ0RGVmID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9MjtcbiAgXHRcdFx0dmFyIGluRGVmID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9MjtcbiAgXHRcdFx0dmFyIGxhRGVmID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9MjtcbiAgXHRcdFx0XG4gIFx0XHRcdHRhYi5idERlZiA9IFR5cHIuX2xjdGYucmVhZENsYXNzRGVmKGRhdGEsIG9mZnNldDAgKyBidERlZik7XG4gIFx0XHRcdHRhYi5pbkRlZiA9IFR5cHIuX2xjdGYucmVhZENsYXNzRGVmKGRhdGEsIG9mZnNldDAgKyBpbkRlZik7XG4gIFx0XHRcdHRhYi5sYURlZiA9IFR5cHIuX2xjdGYucmVhZENsYXNzRGVmKGRhdGEsIG9mZnNldDAgKyBsYURlZik7XG4gIFx0XHRcdFxuICBcdFx0XHR0YWIuc2NzZXQgPSBbXTtcbiAgXHRcdFx0dmFyIGNudCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0XHRcdGZvcih2YXIgaT0wOyBpPGNudDsgaSsrKSB7XG4gIFx0XHRcdFx0dmFyIGxvZmYgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuICBcdFx0XHRcdHRhYi5zY3NldC5wdXNoKFR5cHIuR1NVQi5yZWFkQ2hhaW5TdWJDbGFzc1NldChkYXRhLCBvZmZzZXQwK2xvZmYpKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdFx0Ki9cbiAgXHRcdGlmKHRhYi5mbXQ9PTMpIHtcbiAgXHRcdFx0Zm9yKHZhciBpPTA7IGk8MzsgaSsrKSB7XG4gIFx0XHRcdFx0dmFyIGNudCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0XHRcdFx0dmFyIGN2Z3MgPSBbXTtcbiAgXHRcdFx0XHRmb3IodmFyIGo9MDsgajxjbnQ7IGorKykgeyBjdmdzLnB1c2goICBUeXByLl9sY3RmLnJlYWRDb3ZlcmFnZShkYXRhLCBvZmZzZXQwICsgYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0K2oqMikpICAgKTsgfVxuICBcdFx0XHRcdG9mZnNldCs9Y250KjI7XG4gIFx0XHRcdFx0aWYoaT09MCkgeyB0YWIuYmFja0N2ZyA9IGN2Z3M7IH1cbiAgXHRcdFx0XHRpZihpPT0xKSB7IHRhYi5pbnB0Q3ZnID0gY3ZnczsgfVxuICBcdFx0XHRcdGlmKGk9PTIpIHsgdGFiLmFoZWRDdmcgPSBjdmdzOyB9XG4gIFx0XHRcdH1cbiAgXHRcdFx0dmFyIGNudCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0XHRcdHRhYi5sb29rdXBSZWMgPSBUeXByLkdTVUIucmVhZFN1YnN0TG9va3VwUmVjb3JkcyhkYXRhLCBvZmZzZXQsIGNudCk7XG4gIFx0XHR9XG4gIFx0XHQvL2NvbnNvbGUubG9nKHRhYik7XG4gIFx0fSAvLyovXG4gIFx0Ly9pZih0YWIuY292ZXJhZ2UuaW5kZXhPZigzKSE9LTEpIGNvbnNvbGUubG9nKGx0eXBlLCBmbXQsIHRhYik7XG4gIFx0XG4gIFx0cmV0dXJuIHRhYjtcbiAgfTtcblxuICBUeXByLkdTVUIucmVhZFN1YkNsYXNzU2V0ID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0KVxuICB7XG4gIFx0dmFyIHJVcyA9IFR5cHIuX2Jpbi5yZWFkVXNob3J0LCBvZmZzZXQwID0gb2Zmc2V0LCBsc2V0ID0gW107XG4gIFx0dmFyIGNudCA9IHJVcyhkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuICBcdGZvcih2YXIgaT0wOyBpPGNudDsgaSsrKSB7XG4gIFx0XHR2YXIgbG9mZiA9IHJVcyhkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuICBcdFx0bHNldC5wdXNoKFR5cHIuR1NVQi5yZWFkU3ViQ2xhc3NSdWxlKGRhdGEsIG9mZnNldDArbG9mZikpO1xuICBcdH1cbiAgXHRyZXR1cm4gbHNldDtcbiAgfTtcbiAgVHlwci5HU1VCLnJlYWRTdWJDbGFzc1J1bGU9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldClcbiAge1xuICBcdHZhciByVXMgPSBUeXByLl9iaW4ucmVhZFVzaG9ydCwgcnVsZSA9IHt9O1xuICBcdHZhciBnY291bnQgPSByVXMoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9MjtcbiAgXHR2YXIgc2NvdW50ID0gclVzKGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0cnVsZS5pbnB1dCA9IFtdO1xuICBcdGZvcih2YXIgaT0wOyBpPGdjb3VudC0xOyBpKyspIHtcbiAgXHRcdHJ1bGUuaW5wdXQucHVzaChyVXMoZGF0YSwgb2Zmc2V0KSk7ICBvZmZzZXQrPTI7XG4gIFx0fVxuICBcdHJ1bGUuc3Vic3RMb29rdXBSZWNvcmRzID0gVHlwci5HU1VCLnJlYWRTdWJzdExvb2t1cFJlY29yZHMoZGF0YSwgb2Zmc2V0LCBzY291bnQpO1xuICBcdHJldHVybiBydWxlO1xuICB9O1xuICBUeXByLkdTVUIucmVhZFN1YnN0TG9va3VwUmVjb3JkcyA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgY250KVxuICB7XG4gIFx0dmFyIHJVcyA9IFR5cHIuX2Jpbi5yZWFkVXNob3J0O1xuICBcdHZhciBvdXQgPSBbXTtcbiAgXHRmb3IodmFyIGk9MDsgaTxjbnQ7IGkrKykgeyAgb3V0LnB1c2goclVzKGRhdGEsIG9mZnNldCksIHJVcyhkYXRhLCBvZmZzZXQrMikpOyAgb2Zmc2V0Kz00OyAgfVxuICBcdHJldHVybiBvdXQ7XG4gIH07XG5cbiAgVHlwci5HU1VCLnJlYWRDaGFpblN1YkNsYXNzU2V0ID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0KVxuICB7XG4gIFx0dmFyIGJpbiA9IFR5cHIuX2Jpbiwgb2Zmc2V0MCA9IG9mZnNldCwgbHNldCA9IFtdO1xuICBcdHZhciBjbnQgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuICBcdGZvcih2YXIgaT0wOyBpPGNudDsgaSsrKSB7XG4gIFx0XHR2YXIgbG9mZiA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0XHRsc2V0LnB1c2goVHlwci5HU1VCLnJlYWRDaGFpblN1YkNsYXNzUnVsZShkYXRhLCBvZmZzZXQwK2xvZmYpKTtcbiAgXHR9XG4gIFx0cmV0dXJuIGxzZXQ7XG4gIH07XG4gIFR5cHIuR1NVQi5yZWFkQ2hhaW5TdWJDbGFzc1J1bGU9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldClcbiAge1xuICBcdHZhciBiaW4gPSBUeXByLl9iaW4sIHJ1bGUgPSB7fTtcbiAgXHR2YXIgcHBzID0gW1wiYmFja3RyYWNrXCIsIFwiaW5wdXRcIiwgXCJsb29rYWhlYWRcIl07XG4gIFx0Zm9yKHZhciBwaT0wOyBwaTxwcHMubGVuZ3RoOyBwaSsrKSB7XG4gIFx0XHR2YXIgY250ID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9MjsgIGlmKHBpPT0xKSB7IGNudC0tOyB9XG4gIFx0XHRydWxlW3Bwc1twaV1dPWJpbi5yZWFkVXNob3J0cyhkYXRhLCBvZmZzZXQsIGNudCk7ICBvZmZzZXQrPSBydWxlW3Bwc1twaV1dLmxlbmd0aCoyO1xuICBcdH1cbiAgXHR2YXIgY250ID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9MjtcbiAgXHRydWxlLnN1YnN0ID0gYmluLnJlYWRVc2hvcnRzKGRhdGEsIG9mZnNldCwgY250KjIpOyAgb2Zmc2V0ICs9IHJ1bGUuc3Vic3QubGVuZ3RoKjI7XG4gIFx0cmV0dXJuIHJ1bGU7XG4gIH07XG5cbiAgVHlwci5HU1VCLnJlYWRMaWdhdHVyZVNldCA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldClcbiAge1xuICBcdHZhciBiaW4gPSBUeXByLl9iaW4sIG9mZnNldDAgPSBvZmZzZXQsIGxzZXQgPSBbXTtcbiAgXHR2YXIgbGNudCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0Zm9yKHZhciBqPTA7IGo8bGNudDsgaisrKSB7XG4gIFx0XHR2YXIgbG9mZiA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0XHRsc2V0LnB1c2goVHlwci5HU1VCLnJlYWRMaWdhdHVyZShkYXRhLCBvZmZzZXQwK2xvZmYpKTtcbiAgXHR9XG4gIFx0cmV0dXJuIGxzZXQ7XG4gIH07XG4gIFR5cHIuR1NVQi5yZWFkTGlnYXR1cmUgPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQpXG4gIHtcbiAgXHR2YXIgYmluID0gVHlwci5fYmluLCBsaWcgPSB7Y2hhaW46W119O1xuICBcdGxpZy5uZ2x5cGggPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuICBcdHZhciBjY250ID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9MjtcbiAgXHRmb3IodmFyIGs9MDsgazxjY250LTE7IGsrKykgeyAgbGlnLmNoYWluLnB1c2goYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KSk7ICBvZmZzZXQrPTI7ICB9XG4gIFx0cmV0dXJuIGxpZztcbiAgfTtcblxuXG5cbiAgVHlwci5oZWFkID0ge307XG4gIFR5cHIuaGVhZC5wYXJzZSA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgbGVuZ3RoKVxuICB7XG4gIFx0dmFyIGJpbiA9IFR5cHIuX2JpbjtcbiAgXHR2YXIgb2JqID0ge307XG4gIFx0dmFyIHRhYmxlVmVyc2lvbiA9IGJpbi5yZWFkRml4ZWQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSA0O1xuICBcdG9iai5mb250UmV2aXNpb24gPSBiaW4ucmVhZEZpeGVkKGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gNDtcbiAgXHR2YXIgY2hlY2tTdW1BZGp1c3RtZW50ID0gYmluLnJlYWRVaW50KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gNDtcbiAgXHR2YXIgbWFnaWNOdW1iZXIgPSBiaW4ucmVhZFVpbnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSA0O1xuICBcdG9iai5mbGFncyA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcbiAgXHRvYmoudW5pdHNQZXJFbSA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcbiAgXHRvYmouY3JlYXRlZCAgPSBiaW4ucmVhZFVpbnQ2NChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDg7XG4gIFx0b2JqLm1vZGlmaWVkID0gYmluLnJlYWRVaW50NjQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSA4O1xuICBcdG9iai54TWluID0gYmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG4gIFx0b2JqLnlNaW4gPSBiaW4ucmVhZFNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcbiAgXHRvYmoueE1heCA9IGJpbi5yZWFkU2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuICBcdG9iai55TWF4ID0gYmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG4gIFx0b2JqLm1hY1N0eWxlID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuICBcdG9iai5sb3dlc3RSZWNQUEVNID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuICBcdG9iai5mb250RGlyZWN0aW9uSGludCA9IGJpbi5yZWFkU2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuICBcdG9iai5pbmRleFRvTG9jRm9ybWF0ICA9IGJpbi5yZWFkU2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuICBcdG9iai5nbHlwaERhdGFGb3JtYXQgICA9IGJpbi5yZWFkU2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuICBcdHJldHVybiBvYmo7XG4gIH07XG5cblxuICBUeXByLmhoZWEgPSB7fTtcbiAgVHlwci5oaGVhLnBhcnNlID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0LCBsZW5ndGgpXG4gIHtcbiAgXHR2YXIgYmluID0gVHlwci5fYmluO1xuICBcdHZhciBvYmogPSB7fTtcbiAgXHR2YXIgdGFibGVWZXJzaW9uID0gYmluLnJlYWRGaXhlZChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDQ7XG4gIFx0b2JqLmFzY2VuZGVyICA9IGJpbi5yZWFkU2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuICBcdG9iai5kZXNjZW5kZXIgPSBiaW4ucmVhZFNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcbiAgXHRvYmoubGluZUdhcCA9IGJpbi5yZWFkU2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuICBcdFxuICBcdG9iai5hZHZhbmNlV2lkdGhNYXggPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG4gIFx0b2JqLm1pbkxlZnRTaWRlQmVhcmluZyAgPSBiaW4ucmVhZFNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcbiAgXHRvYmoubWluUmlnaHRTaWRlQmVhcmluZyA9IGJpbi5yZWFkU2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuICBcdG9iai54TWF4RXh0ZW50ID0gYmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG4gIFx0XG4gIFx0b2JqLmNhcmV0U2xvcGVSaXNlID0gYmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG4gIFx0b2JqLmNhcmV0U2xvcGVSdW4gID0gYmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG4gIFx0b2JqLmNhcmV0T2Zmc2V0ICAgID0gYmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG4gIFx0XG4gIFx0b2Zmc2V0ICs9IDQqMjtcbiAgXHRcbiAgXHRvYmoubWV0cmljRGF0YUZvcm1hdCA9IGJpbi5yZWFkU2hvcnQgKGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcbiAgXHRvYmoubnVtYmVyT2ZITWV0cmljcyA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcbiAgXHRyZXR1cm4gb2JqO1xuICB9O1xuXG5cbiAgVHlwci5obXR4ID0ge307XG4gIFR5cHIuaG10eC5wYXJzZSA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgbGVuZ3RoLCBmb250KVxuICB7XG4gIFx0dmFyIGJpbiA9IFR5cHIuX2JpbjtcbiAgXHR2YXIgb2JqID0ge307XG4gIFx0XG4gIFx0b2JqLmFXaWR0aCA9IFtdO1xuICBcdG9iai5sc0JlYXJpbmcgPSBbXTtcbiAgXHRcbiAgXHRcbiAgXHR2YXIgYXcgPSAwLCBsc2IgPSAwO1xuICBcdFxuICBcdGZvcih2YXIgaT0wOyBpPGZvbnQubWF4cC5udW1HbHlwaHM7IGkrKylcbiAgXHR7XG4gIFx0XHRpZihpPGZvbnQuaGhlYS5udW1iZXJPZkhNZXRyaWNzKSB7ICBhdz1iaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7ICBsc2I9YmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yOyAgfVxuICBcdFx0b2JqLmFXaWR0aC5wdXNoKGF3KTtcbiAgXHRcdG9iai5sc0JlYXJpbmcucHVzaChsc2IpO1xuICBcdH1cbiAgXHRcbiAgXHRyZXR1cm4gb2JqO1xuICB9O1xuXG5cbiAgVHlwci5rZXJuID0ge307XG4gIFR5cHIua2Vybi5wYXJzZSA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgbGVuZ3RoLCBmb250KVxuICB7XG4gIFx0dmFyIGJpbiA9IFR5cHIuX2JpbjtcbiAgXHRcbiAgXHR2YXIgdmVyc2lvbiA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0aWYodmVyc2lvbj09MSkgeyByZXR1cm4gVHlwci5rZXJuLnBhcnNlVjEoZGF0YSwgb2Zmc2V0LTIsIGxlbmd0aCwgZm9udCk7IH1cbiAgXHR2YXIgblRhYmxlcyA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0XG4gIFx0dmFyIG1hcCA9IHtnbHlwaDE6IFtdLCBydmFsOltdfTtcbiAgXHRmb3IodmFyIGk9MDsgaTxuVGFibGVzOyBpKyspXG4gIFx0e1xuICBcdFx0b2Zmc2V0Kz0yO1x0Ly8gc2tpcCB2ZXJzaW9uXG4gIFx0XHR2YXIgbGVuZ3RoICA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0XHR2YXIgY292ZXJhZ2UgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuICBcdFx0dmFyIGZvcm1hdCA9IGNvdmVyYWdlPj4+ODtcbiAgXHRcdC8qIEkgaGF2ZSBzZWVuIGZvcm1hdCAxMjggb25jZSwgdGhhdCdzIHdoeSBJIGRvICovIGZvcm1hdCAmPSAweGY7XG4gIFx0XHRpZihmb3JtYXQ9PTApIHsgb2Zmc2V0ID0gVHlwci5rZXJuLnJlYWRGb3JtYXQwKGRhdGEsIG9mZnNldCwgbWFwKTsgfVxuICBcdFx0ZWxzZSB7IHRocm93IFwidW5rbm93biBrZXJuIHRhYmxlIGZvcm1hdDogXCIrZm9ybWF0OyB9XG4gIFx0fVxuICBcdHJldHVybiBtYXA7XG4gIH07XG5cbiAgVHlwci5rZXJuLnBhcnNlVjEgPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQsIGxlbmd0aCwgZm9udClcbiAge1xuICBcdHZhciBiaW4gPSBUeXByLl9iaW47XG4gIFx0XG4gIFx0dmFyIHZlcnNpb24gPSBiaW4ucmVhZEZpeGVkKGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTQ7XG4gIFx0dmFyIG5UYWJsZXMgPSBiaW4ucmVhZFVpbnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9NDtcbiAgXHRcbiAgXHR2YXIgbWFwID0ge2dseXBoMTogW10sIHJ2YWw6W119O1xuICBcdGZvcih2YXIgaT0wOyBpPG5UYWJsZXM7IGkrKylcbiAgXHR7XG4gIFx0XHR2YXIgbGVuZ3RoID0gYmluLnJlYWRVaW50KGRhdGEsIG9mZnNldCk7ICAgb2Zmc2V0Kz00O1xuICBcdFx0dmFyIGNvdmVyYWdlID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9MjtcbiAgXHRcdHZhciB0dXBsZUluZGV4ID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9MjtcbiAgXHRcdHZhciBmb3JtYXQgPSBjb3ZlcmFnZT4+Pjg7XG4gIFx0XHQvKiBJIGhhdmUgc2VlbiBmb3JtYXQgMTI4IG9uY2UsIHRoYXQncyB3aHkgSSBkbyAqLyBmb3JtYXQgJj0gMHhmO1xuICBcdFx0aWYoZm9ybWF0PT0wKSB7IG9mZnNldCA9IFR5cHIua2Vybi5yZWFkRm9ybWF0MChkYXRhLCBvZmZzZXQsIG1hcCk7IH1cbiAgXHRcdGVsc2UgeyB0aHJvdyBcInVua25vd24ga2VybiB0YWJsZSBmb3JtYXQ6IFwiK2Zvcm1hdDsgfVxuICBcdH1cbiAgXHRyZXR1cm4gbWFwO1xuICB9O1xuXG4gIFR5cHIua2Vybi5yZWFkRm9ybWF0MCA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgbWFwKVxuICB7XG4gIFx0dmFyIGJpbiA9IFR5cHIuX2JpbjtcbiAgXHR2YXIgcGxlZnQgPSAtMTtcbiAgXHR2YXIgblBhaXJzICAgICAgICA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0dmFyIHNlYXJjaFJhbmdlICAgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuICBcdHZhciBlbnRyeVNlbGVjdG9yID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9MjtcbiAgXHR2YXIgcmFuZ2VTaGlmdCAgICA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0Zm9yKHZhciBqPTA7IGo8blBhaXJzOyBqKyspXG4gIFx0e1xuICBcdFx0dmFyIGxlZnQgID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9MjtcbiAgXHRcdHZhciByaWdodCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG4gIFx0XHR2YXIgdmFsdWUgPSBiaW4ucmVhZFNob3J0IChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuICBcdFx0aWYobGVmdCE9cGxlZnQpIHsgbWFwLmdseXBoMS5wdXNoKGxlZnQpOyAgbWFwLnJ2YWwucHVzaCh7IGdseXBoMjpbXSwgdmFsczpbXSB9KTsgfVxuICBcdFx0dmFyIHJ2YWwgPSBtYXAucnZhbFttYXAucnZhbC5sZW5ndGgtMV07XG4gIFx0XHRydmFsLmdseXBoMi5wdXNoKHJpZ2h0KTsgICBydmFsLnZhbHMucHVzaCh2YWx1ZSk7XG4gIFx0XHRwbGVmdCA9IGxlZnQ7XG4gIFx0fVxuICBcdHJldHVybiBvZmZzZXQ7XG4gIH07XG5cblxuXG4gIFR5cHIubG9jYSA9IHt9O1xuICBUeXByLmxvY2EucGFyc2UgPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQsIGxlbmd0aCwgZm9udClcbiAge1xuICBcdHZhciBiaW4gPSBUeXByLl9iaW47XG4gIFx0dmFyIG9iaiA9IFtdO1xuICBcdFxuICBcdHZhciB2ZXIgPSBmb250LmhlYWQuaW5kZXhUb0xvY0Zvcm1hdDtcbiAgXHQvL2NvbnNvbGUubG9nKFwibG9jYVwiLCB2ZXIsIGxlbmd0aCwgNCpmb250Lm1heHAubnVtR2x5cGhzKTtcbiAgXHR2YXIgbGVuID0gZm9udC5tYXhwLm51bUdseXBocysxO1xuICBcdFxuICBcdGlmKHZlcj09MCkgeyBmb3IodmFyIGk9MDsgaTxsZW47IGkrKykgeyBvYmoucHVzaChiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQrKGk8PDEpKTw8MSk7IH0gfVxuICBcdGlmKHZlcj09MSkgeyBmb3IodmFyIGk9MDsgaTxsZW47IGkrKykgeyBvYmoucHVzaChiaW4ucmVhZFVpbnQgIChkYXRhLCBvZmZzZXQrKGk8PDIpKSAgICk7IH0gfVxuICBcdFxuICBcdHJldHVybiBvYmo7XG4gIH07XG5cblxuICBUeXByLm1heHAgPSB7fTtcbiAgVHlwci5tYXhwLnBhcnNlID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0LCBsZW5ndGgpXG4gIHtcbiAgXHQvL2NvbnNvbGUubG9nKGRhdGEubGVuZ3RoLCBvZmZzZXQsIGxlbmd0aCk7XG4gIFx0XG4gIFx0dmFyIGJpbiA9IFR5cHIuX2JpbjtcbiAgXHR2YXIgb2JqID0ge307XG4gIFx0XG4gIFx0Ly8gYm90aCB2ZXJzaW9ucyAwLjUgYW5kIDEuMFxuICBcdHZhciB2ZXIgPSBiaW4ucmVhZFVpbnQoZGF0YSwgb2Zmc2V0KTsgb2Zmc2V0ICs9IDQ7XG4gIFx0b2JqLm51bUdseXBocyA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcbiAgXHRcbiAgXHQvLyBvbmx5IDEuMFxuICBcdGlmKHZlciA9PSAweDAwMDEwMDAwKVxuICBcdHtcbiAgXHRcdG9iai5tYXhQb2ludHMgICAgICAgICAgICAgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG4gIFx0XHRvYmoubWF4Q29udG91cnMgICAgICAgICAgID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuICBcdFx0b2JqLm1heENvbXBvc2l0ZVBvaW50cyAgICA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcbiAgXHRcdG9iai5tYXhDb21wb3NpdGVDb250b3VycyAgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG4gIFx0XHRvYmoubWF4Wm9uZXMgICAgICAgICAgICAgID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuICBcdFx0b2JqLm1heFR3aWxpZ2h0UG9pbnRzICAgICA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcbiAgXHRcdG9iai5tYXhTdG9yYWdlICAgICAgICAgICAgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG4gIFx0XHRvYmoubWF4RnVuY3Rpb25EZWZzICAgICAgID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuICBcdFx0b2JqLm1heEluc3RydWN0aW9uRGVmcyAgICA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcbiAgXHRcdG9iai5tYXhTdGFja0VsZW1lbnRzICAgICAgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG4gIFx0XHRvYmoubWF4U2l6ZU9mSW5zdHJ1Y3Rpb25zID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuICBcdFx0b2JqLm1heENvbXBvbmVudEVsZW1lbnRzICA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcbiAgXHRcdG9iai5tYXhDb21wb25lbnREZXB0aCAgICAgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG4gIFx0fVxuICBcdFxuICBcdHJldHVybiBvYmo7XG4gIH07XG5cblxuICBUeXByLm5hbWUgPSB7fTtcbiAgVHlwci5uYW1lLnBhcnNlID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0LCBsZW5ndGgpXG4gIHtcbiAgXHR2YXIgYmluID0gVHlwci5fYmluO1xuICBcdHZhciBvYmogPSB7fTtcbiAgXHR2YXIgZm9ybWF0ID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuICBcdHZhciBjb3VudCAgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG4gIFx0dmFyIHN0cmluZ09mZnNldCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcbiAgXHRcbiAgXHQvL2NvbnNvbGUubG9nKGZvcm1hdCxjb3VudCk7XG4gIFx0XG4gIFx0dmFyIG5hbWVzID0gW1xuICBcdFx0XCJjb3B5cmlnaHRcIixcbiAgXHRcdFwiZm9udEZhbWlseVwiLFxuICBcdFx0XCJmb250U3ViZmFtaWx5XCIsXG4gIFx0XHRcIklEXCIsXG4gIFx0XHRcImZ1bGxOYW1lXCIsXG4gIFx0XHRcInZlcnNpb25cIixcbiAgXHRcdFwicG9zdFNjcmlwdE5hbWVcIixcbiAgXHRcdFwidHJhZGVtYXJrXCIsXG4gIFx0XHRcIm1hbnVmYWN0dXJlclwiLFxuICBcdFx0XCJkZXNpZ25lclwiLFxuICBcdFx0XCJkZXNjcmlwdGlvblwiLFxuICBcdFx0XCJ1cmxWZW5kb3JcIixcbiAgXHRcdFwidXJsRGVzaWduZXJcIixcbiAgXHRcdFwibGljZW5jZVwiLFxuICBcdFx0XCJsaWNlbmNlVVJMXCIsXG4gIFx0XHRcIi0tLVwiLFxuICBcdFx0XCJ0eXBvRmFtaWx5TmFtZVwiLFxuICBcdFx0XCJ0eXBvU3ViZmFtaWx5TmFtZVwiLFxuICBcdFx0XCJjb21wYXRpYmxlRnVsbFwiLFxuICBcdFx0XCJzYW1wbGVUZXh0XCIsXG4gIFx0XHRcInBvc3RTY3JpcHRDSURcIixcbiAgXHRcdFwid3dzRmFtaWx5TmFtZVwiLFxuICBcdFx0XCJ3d3NTdWJmYW1pbHlOYW1lXCIsXG4gIFx0XHRcImxpZ2h0UGFsZXR0ZVwiLFxuICBcdFx0XCJkYXJrUGFsZXR0ZVwiXG4gIFx0XTtcbiAgXHRcbiAgXHR2YXIgb2Zmc2V0MCA9IG9mZnNldDtcbiAgXHRcbiAgXHRmb3IodmFyIGk9MDsgaTxjb3VudDsgaSsrKVxuICBcdHtcbiAgXHRcdHZhciBwbGF0Zm9ybUlEID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuICBcdFx0dmFyIGVuY29kaW5nSUQgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG4gIFx0XHR2YXIgbGFuZ3VhZ2VJRCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcbiAgXHRcdHZhciBuYW1lSUQgICAgID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuICBcdFx0dmFyIHNsZW4gICAgICAgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDI7XG4gIFx0XHR2YXIgbm9mZnNldCAgICA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcbiAgXHRcdC8vY29uc29sZS5sb2cocGxhdGZvcm1JRCwgZW5jb2RpbmdJRCwgbGFuZ3VhZ2VJRC50b1N0cmluZygxNiksIG5hbWVJRCwgbGVuZ3RoLCBub2Zmc2V0KTtcbiAgXHRcdFxuICBcdFx0dmFyIGNuYW1lID0gbmFtZXNbbmFtZUlEXTtcbiAgXHRcdHZhciBzb2ZmID0gb2Zmc2V0MCArIGNvdW50KjEyICsgbm9mZnNldDtcbiAgXHRcdHZhciBzdHI7XG4gIFx0XHRpZihwbGF0Zm9ybUlEID09IDApIHsgc3RyID0gYmluLnJlYWRVbmljb2RlKGRhdGEsIHNvZmYsIHNsZW4vMik7IH1cbiAgXHRcdGVsc2UgaWYocGxhdGZvcm1JRCA9PSAzICYmIGVuY29kaW5nSUQgPT0gMCkgeyBzdHIgPSBiaW4ucmVhZFVuaWNvZGUoZGF0YSwgc29mZiwgc2xlbi8yKTsgfVxuICBcdFx0ZWxzZSBpZihlbmNvZGluZ0lEID09IDApIHsgc3RyID0gYmluLnJlYWRBU0NJSSAgKGRhdGEsIHNvZmYsIHNsZW4pOyB9XG4gIFx0XHRlbHNlIGlmKGVuY29kaW5nSUQgPT0gMSkgeyBzdHIgPSBiaW4ucmVhZFVuaWNvZGUoZGF0YSwgc29mZiwgc2xlbi8yKTsgfVxuICBcdFx0ZWxzZSBpZihlbmNvZGluZ0lEID09IDMpIHsgc3RyID0gYmluLnJlYWRVbmljb2RlKGRhdGEsIHNvZmYsIHNsZW4vMik7IH1cbiAgXHRcdFxuICBcdFx0ZWxzZSBpZihwbGF0Zm9ybUlEID09IDEpIHsgc3RyID0gYmluLnJlYWRBU0NJSShkYXRhLCBzb2ZmLCBzbGVuKTsgIGNvbnNvbGUubG9nKFwicmVhZGluZyB1bmtub3duIE1BQyBlbmNvZGluZyBcIitlbmNvZGluZ0lEK1wiIGFzIEFTQ0lJXCIpOyB9XG4gIFx0XHRlbHNlIHsgdGhyb3cgXCJ1bmtub3duIGVuY29kaW5nIFwiK2VuY29kaW5nSUQgKyBcIiwgcGxhdGZvcm1JRDogXCIrcGxhdGZvcm1JRDsgfVxuICBcdFx0XG4gIFx0XHR2YXIgdGlkID0gXCJwXCIrcGxhdGZvcm1JRCtcIixcIisobGFuZ3VhZ2VJRCkudG9TdHJpbmcoMTYpOy8vVHlwci5fcGxhdGZvcm1zW3BsYXRmb3JtSURdO1xuICBcdFx0aWYob2JqW3RpZF09PW51bGwpIHsgb2JqW3RpZF0gPSB7fTsgfVxuICBcdFx0b2JqW3RpZF1bY25hbWVdID0gc3RyO1xuICBcdFx0b2JqW3RpZF0uX2xhbmcgPSBsYW5ndWFnZUlEO1xuICBcdFx0Ly9jb25zb2xlLmxvZyh0aWQsIG9ialt0aWRdKTtcbiAgXHR9XG4gIFx0LypcbiAgXHRpZihmb3JtYXQgPT0gMSlcbiAgXHR7XG4gIFx0XHR2YXIgbGFuZ1RhZ0NvdW50ID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuICBcdFx0Zm9yKHZhciBpPTA7IGk8bGFuZ1RhZ0NvdW50OyBpKyspXG4gIFx0XHR7XG4gIFx0XHRcdHZhciBsZW5ndGggID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuICBcdFx0XHR2YXIgbm9mZnNldCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcbiAgXHRcdH1cbiAgXHR9XG4gIFx0Ki9cbiAgXHRcbiAgXHQvL2NvbnNvbGUubG9nKG9iaik7XG4gIFx0XG4gIFx0Zm9yKHZhciBwIGluIG9iaikgeyBpZihvYmpbcF0ucG9zdFNjcmlwdE5hbWUhPW51bGwgJiYgb2JqW3BdLl9sYW5nPT0weDA0MDkpIHsgcmV0dXJuIG9ialtwXTsgfSB9XHRcdC8vIFVuaXRlZCBTdGF0ZXNcbiAgXHRmb3IodmFyIHAgaW4gb2JqKSB7IGlmKG9ialtwXS5wb3N0U2NyaXB0TmFtZSE9bnVsbCAmJiBvYmpbcF0uX2xhbmc9PTB4MDAwMCkgeyByZXR1cm4gb2JqW3BdOyB9IH1cdFx0Ly8gVW5pdmVyc2FsXG4gIFx0Zm9yKHZhciBwIGluIG9iaikgeyBpZihvYmpbcF0ucG9zdFNjcmlwdE5hbWUhPW51bGwgJiYgb2JqW3BdLl9sYW5nPT0weDBjMGMpIHsgcmV0dXJuIG9ialtwXTsgfSB9XHRcdC8vIENhbmFkYVxuICBcdGZvcih2YXIgcCBpbiBvYmopIHsgaWYob2JqW3BdLnBvc3RTY3JpcHROYW1lIT1udWxsKSB7IHJldHVybiBvYmpbcF07IH0gfVxuICBcdFxuICBcdHZhciB0bmFtZTtcbiAgXHRmb3IodmFyIHAgaW4gb2JqKSB7IHRuYW1lPXA7IGJyZWFrOyB9XG4gIFx0Y29uc29sZS5sb2coXCJyZXR1cm5pbmcgbmFtZSB0YWJsZSB3aXRoIGxhbmd1YWdlSUQgXCIrIG9ialt0bmFtZV0uX2xhbmcpO1xuICBcdHJldHVybiBvYmpbdG5hbWVdO1xuICB9O1xuXG5cbiAgVHlwcltcIk9TLzJcIl0gPSB7fTtcbiAgVHlwcltcIk9TLzJcIl0ucGFyc2UgPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQsIGxlbmd0aClcbiAge1xuICBcdHZhciBiaW4gPSBUeXByLl9iaW47XG4gIFx0dmFyIHZlciA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7IG9mZnNldCArPSAyO1xuICBcdFxuICBcdHZhciBvYmogPSB7fTtcbiAgXHRpZiAgICAgKHZlcj09MCkgeyBUeXByW1wiT1MvMlwiXS52ZXJzaW9uMChkYXRhLCBvZmZzZXQsIG9iaik7IH1cbiAgXHRlbHNlIGlmKHZlcj09MSkgeyBUeXByW1wiT1MvMlwiXS52ZXJzaW9uMShkYXRhLCBvZmZzZXQsIG9iaik7IH1cbiAgXHRlbHNlIGlmKHZlcj09MiB8fCB2ZXI9PTMgfHwgdmVyPT00KSB7IFR5cHJbXCJPUy8yXCJdLnZlcnNpb24yKGRhdGEsIG9mZnNldCwgb2JqKTsgfVxuICBcdGVsc2UgaWYodmVyPT01KSB7IFR5cHJbXCJPUy8yXCJdLnZlcnNpb241KGRhdGEsIG9mZnNldCwgb2JqKTsgfVxuICBcdGVsc2UgeyB0aHJvdyBcInVua25vd24gT1MvMiB0YWJsZSB2ZXJzaW9uOiBcIit2ZXI7IH1cbiAgXHRcbiAgXHRyZXR1cm4gb2JqO1xuICB9O1xuXG4gIFR5cHJbXCJPUy8yXCJdLnZlcnNpb24wID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0LCBvYmopXG4gIHtcbiAgXHR2YXIgYmluID0gVHlwci5fYmluO1xuICBcdG9iai54QXZnQ2hhcldpZHRoID0gYmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpOyBvZmZzZXQgKz0gMjtcbiAgXHRvYmoudXNXZWlnaHRDbGFzcyA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7IG9mZnNldCArPSAyO1xuICBcdG9iai51c1dpZHRoQ2xhc3MgID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgb2Zmc2V0ICs9IDI7XG4gIFx0b2JqLmZzVHlwZSA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7IG9mZnNldCArPSAyO1xuICBcdG9iai55U3Vic2NyaXB0WFNpemUgPSBiaW4ucmVhZFNob3J0KGRhdGEsIG9mZnNldCk7IG9mZnNldCArPSAyO1xuICBcdG9iai55U3Vic2NyaXB0WVNpemUgPSBiaW4ucmVhZFNob3J0KGRhdGEsIG9mZnNldCk7IG9mZnNldCArPSAyO1xuICBcdG9iai55U3Vic2NyaXB0WE9mZnNldCA9IGJpbi5yZWFkU2hvcnQoZGF0YSwgb2Zmc2V0KTsgb2Zmc2V0ICs9IDI7XG4gIFx0b2JqLnlTdWJzY3JpcHRZT2Zmc2V0ID0gYmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpOyBvZmZzZXQgKz0gMjsgXG4gIFx0b2JqLnlTdXBlcnNjcmlwdFhTaXplID0gYmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpOyBvZmZzZXQgKz0gMjsgXG4gIFx0b2JqLnlTdXBlcnNjcmlwdFlTaXplID0gYmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpOyBvZmZzZXQgKz0gMjsgXG4gIFx0b2JqLnlTdXBlcnNjcmlwdFhPZmZzZXQgPSBiaW4ucmVhZFNob3J0KGRhdGEsIG9mZnNldCk7IG9mZnNldCArPSAyO1xuICBcdG9iai55U3VwZXJzY3JpcHRZT2Zmc2V0ID0gYmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpOyBvZmZzZXQgKz0gMjtcbiAgXHRvYmoueVN0cmlrZW91dFNpemUgPSBiaW4ucmVhZFNob3J0KGRhdGEsIG9mZnNldCk7IG9mZnNldCArPSAyO1xuICBcdG9iai55U3RyaWtlb3V0UG9zaXRpb24gPSBiaW4ucmVhZFNob3J0KGRhdGEsIG9mZnNldCk7IG9mZnNldCArPSAyO1xuICBcdG9iai5zRmFtaWx5Q2xhc3MgPSBiaW4ucmVhZFNob3J0KGRhdGEsIG9mZnNldCk7IG9mZnNldCArPSAyO1xuICBcdG9iai5wYW5vc2UgPSBiaW4ucmVhZEJ5dGVzKGRhdGEsIG9mZnNldCwgMTApOyAgb2Zmc2V0ICs9IDEwO1xuICBcdG9iai51bFVuaWNvZGVSYW5nZTFcdD0gYmluLnJlYWRVaW50KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gNDtcbiAgXHRvYmoudWxVbmljb2RlUmFuZ2UyXHQ9IGJpbi5yZWFkVWludChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDQ7XG4gIFx0b2JqLnVsVW5pY29kZVJhbmdlM1x0PSBiaW4ucmVhZFVpbnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSA0O1xuICBcdG9iai51bFVuaWNvZGVSYW5nZTRcdD0gYmluLnJlYWRVaW50KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gNDtcbiAgXHRvYmouYWNoVmVuZElEID0gW2Jpbi5yZWFkSW50OChkYXRhLCBvZmZzZXQpLCBiaW4ucmVhZEludDgoZGF0YSwgb2Zmc2V0KzEpLGJpbi5yZWFkSW50OChkYXRhLCBvZmZzZXQrMiksYmluLnJlYWRJbnQ4KGRhdGEsIG9mZnNldCszKV07ICBvZmZzZXQgKz0gNDtcbiAgXHRvYmouZnNTZWxlY3Rpb25cdCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7IG9mZnNldCArPSAyO1xuICBcdG9iai51c0ZpcnN0Q2hhckluZGV4ID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgb2Zmc2V0ICs9IDI7XG4gIFx0b2JqLnVzTGFzdENoYXJJbmRleCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7IG9mZnNldCArPSAyO1xuICBcdG9iai5zVHlwb0FzY2VuZGVyID0gYmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpOyBvZmZzZXQgKz0gMjtcbiAgXHRvYmouc1R5cG9EZXNjZW5kZXIgPSBiaW4ucmVhZFNob3J0KGRhdGEsIG9mZnNldCk7IG9mZnNldCArPSAyO1xuICBcdG9iai5zVHlwb0xpbmVHYXAgPSBiaW4ucmVhZFNob3J0KGRhdGEsIG9mZnNldCk7IG9mZnNldCArPSAyO1xuICBcdG9iai51c1dpbkFzY2VudCA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7IG9mZnNldCArPSAyO1xuICBcdG9iai51c1dpbkRlc2NlbnQgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyBvZmZzZXQgKz0gMjtcbiAgXHRyZXR1cm4gb2Zmc2V0O1xuICB9O1xuXG4gIFR5cHJbXCJPUy8yXCJdLnZlcnNpb24xID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0LCBvYmopXG4gIHtcbiAgXHR2YXIgYmluID0gVHlwci5fYmluO1xuICBcdG9mZnNldCA9IFR5cHJbXCJPUy8yXCJdLnZlcnNpb24wKGRhdGEsIG9mZnNldCwgb2JqKTtcbiAgXHRcbiAgXHRvYmoudWxDb2RlUGFnZVJhbmdlMSA9IGJpbi5yZWFkVWludChkYXRhLCBvZmZzZXQpOyBvZmZzZXQgKz0gNDtcbiAgXHRvYmoudWxDb2RlUGFnZVJhbmdlMiA9IGJpbi5yZWFkVWludChkYXRhLCBvZmZzZXQpOyBvZmZzZXQgKz0gNDtcbiAgXHRyZXR1cm4gb2Zmc2V0O1xuICB9O1xuXG4gIFR5cHJbXCJPUy8yXCJdLnZlcnNpb24yID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0LCBvYmopXG4gIHtcbiAgXHR2YXIgYmluID0gVHlwci5fYmluO1xuICBcdG9mZnNldCA9IFR5cHJbXCJPUy8yXCJdLnZlcnNpb24xKGRhdGEsIG9mZnNldCwgb2JqKTtcbiAgXHRcbiAgXHRvYmouc3hIZWlnaHQgPSBiaW4ucmVhZFNob3J0KGRhdGEsIG9mZnNldCk7IG9mZnNldCArPSAyO1xuICBcdG9iai5zQ2FwSGVpZ2h0ID0gYmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpOyBvZmZzZXQgKz0gMjtcbiAgXHRvYmoudXNEZWZhdWx0ID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgb2Zmc2V0ICs9IDI7XG4gIFx0b2JqLnVzQnJlYWsgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyBvZmZzZXQgKz0gMjtcbiAgXHRvYmoudXNNYXhDb250ZXh0ID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgb2Zmc2V0ICs9IDI7XG4gIFx0cmV0dXJuIG9mZnNldDtcbiAgfTtcblxuICBUeXByW1wiT1MvMlwiXS52ZXJzaW9uNSA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgb2JqKVxuICB7XG4gIFx0dmFyIGJpbiA9IFR5cHIuX2JpbjtcbiAgXHRvZmZzZXQgPSBUeXByW1wiT1MvMlwiXS52ZXJzaW9uMihkYXRhLCBvZmZzZXQsIG9iaik7XG5cbiAgXHRvYmoudXNMb3dlck9wdGljYWxQb2ludFNpemUgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyBvZmZzZXQgKz0gMjtcbiAgXHRvYmoudXNVcHBlck9wdGljYWxQb2ludFNpemUgPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpOyBvZmZzZXQgKz0gMjtcbiAgXHRyZXR1cm4gb2Zmc2V0O1xuICB9O1xuXG4gIFR5cHIucG9zdCA9IHt9O1xuICBUeXByLnBvc3QucGFyc2UgPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQsIGxlbmd0aClcbiAge1xuICBcdHZhciBiaW4gPSBUeXByLl9iaW47XG4gIFx0dmFyIG9iaiA9IHt9O1xuICBcdFxuICBcdG9iai52ZXJzaW9uICAgICAgICAgICA9IGJpbi5yZWFkRml4ZWQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCs9NDtcbiAgXHRvYmouaXRhbGljQW5nbGUgICAgICAgPSBiaW4ucmVhZEZpeGVkKGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTQ7XG4gIFx0b2JqLnVuZGVybGluZVBvc2l0aW9uID0gYmluLnJlYWRTaG9ydChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0Kz0yO1xuICBcdG9iai51bmRlcmxpbmVUaGlja25lc3MgPSBiaW4ucmVhZFNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQrPTI7XG5cbiAgXHRyZXR1cm4gb2JqO1xuICB9O1xuICBUeXByLlNWRyA9IHt9O1xuICBUeXByLlNWRy5wYXJzZSA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgbGVuZ3RoKVxuICB7XG4gIFx0dmFyIGJpbiA9IFR5cHIuX2JpbjtcbiAgXHR2YXIgb2JqID0geyBlbnRyaWVzOiBbXX07XG5cbiAgXHR2YXIgb2Zmc2V0MCA9IG9mZnNldDtcblxuICBcdHZhciB0YWJsZVZlcnNpb24gPSBiaW4ucmVhZFVzaG9ydChkYXRhLCBvZmZzZXQpO1x0b2Zmc2V0ICs9IDI7XG4gIFx0dmFyIHN2Z0RvY0luZGV4T2Zmc2V0ID0gYmluLnJlYWRVaW50KGRhdGEsIG9mZnNldCk7XHRvZmZzZXQgKz0gNDtcbiAgXHR2YXIgcmVzZXJ2ZWQgPSBiaW4ucmVhZFVpbnQoZGF0YSwgb2Zmc2V0KTsgb2Zmc2V0ICs9IDQ7XG5cbiAgXHRvZmZzZXQgPSBzdmdEb2NJbmRleE9mZnNldCArIG9mZnNldDA7XG5cbiAgXHR2YXIgbnVtRW50cmllcyA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7XHRvZmZzZXQgKz0gMjtcblxuICBcdGZvcih2YXIgaT0wOyBpPG51bUVudHJpZXM7IGkrKylcbiAgXHR7XG4gIFx0XHR2YXIgc3RhcnRHbHlwaElEID0gYmluLnJlYWRVc2hvcnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSAyO1xuICBcdFx0dmFyIGVuZEdseXBoSUQgICA9IGJpbi5yZWFkVXNob3J0KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gMjtcbiAgXHRcdHZhciBzdmdEb2NPZmZzZXQgPSBiaW4ucmVhZFVpbnQgIChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDQ7XG4gIFx0XHR2YXIgc3ZnRG9jTGVuZ3RoID0gYmluLnJlYWRVaW50ICAoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSA0O1xuXG4gIFx0XHR2YXIgc2J1ZiA9IG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLCBvZmZzZXQwICsgc3ZnRG9jT2Zmc2V0ICsgc3ZnRG9jSW5kZXhPZmZzZXQsIHN2Z0RvY0xlbmd0aCk7XG4gIFx0XHR2YXIgc3ZnID0gYmluLnJlYWRVVEY4KHNidWYsIDAsIHNidWYubGVuZ3RoKTtcbiAgXHRcdFxuICBcdFx0Zm9yKHZhciBmPXN0YXJ0R2x5cGhJRDsgZjw9ZW5kR2x5cGhJRDsgZisrKSB7XG4gIFx0XHRcdG9iai5lbnRyaWVzW2ZdID0gc3ZnO1xuICBcdFx0fVxuICBcdH1cbiAgXHRyZXR1cm4gb2JqO1xuICB9O1xuXG4gIFR5cHIuU1ZHLnRvUGF0aCA9IGZ1bmN0aW9uKHN0cilcbiAge1xuICBcdHZhciBwdGggPSB7Y21kczpbXSwgY3JkczpbXX07XG4gIFx0aWYoc3RyPT1udWxsKSB7IHJldHVybiBwdGg7IH1cbiAgXHRcbiAgXHR2YXIgcHJzciA9IG5ldyBET01QYXJzZXIoKTtcbiAgXHR2YXIgZG9jID0gcHJzcltcInBhcnNlRnJvbVN0cmluZ1wiXShzdHIsXCJpbWFnZS9zdmcreG1sXCIpO1xuICBcdFxuICBcdHZhciBzdmcgPSBkb2MuZmlyc3RDaGlsZDsgIHdoaWxlKHN2Zy50YWdOYW1lIT1cInN2Z1wiKSB7IHN2ZyA9IHN2Zy5uZXh0U2libGluZzsgfVxuICBcdHZhciB2YiA9IHN2Zy5nZXRBdHRyaWJ1dGUoXCJ2aWV3Qm94XCIpO1xuICBcdGlmKHZiKSB7IHZiID0gdmIudHJpbSgpLnNwbGl0KFwiIFwiKS5tYXAocGFyc2VGbG9hdCk7IH0gIGVsc2UgICB7IHZiID0gWzAsMCwxMDAwLDEwMDBdOyB9XG4gIFx0VHlwci5TVkcuX3RvUGF0aChzdmcuY2hpbGRyZW4sIHB0aCk7XG4gIFx0Zm9yKHZhciBpPTA7IGk8cHRoLmNyZHMubGVuZ3RoOyBpKz0yKSB7XG4gIFx0XHR2YXIgeCA9IHB0aC5jcmRzW2ldLCB5ID0gcHRoLmNyZHNbaSsxXTtcbiAgXHRcdHggLT0gdmJbMF07XG4gIFx0XHR5IC09IHZiWzFdO1xuICBcdFx0eSA9IC15O1xuICBcdFx0cHRoLmNyZHNbaV0gPSB4O1xuICBcdFx0cHRoLmNyZHNbaSsxXSA9IHk7XG4gIFx0fVxuICBcdHJldHVybiBwdGg7XG4gIH07XG5cbiAgVHlwci5TVkcuX3RvUGF0aCA9IGZ1bmN0aW9uKG5kcywgcHRoLCBmaWxsKSB7XG4gIFx0Zm9yKHZhciBuaT0wOyBuaTxuZHMubGVuZ3RoOyBuaSsrKSB7XG4gIFx0XHR2YXIgbmQgPSBuZHNbbmldLCB0biA9IG5kLnRhZ05hbWU7XG4gIFx0XHR2YXIgY2ZsID0gbmQuZ2V0QXR0cmlidXRlKFwiZmlsbFwiKTsgIGlmKGNmbD09bnVsbCkgeyBjZmwgPSBmaWxsOyB9XG4gIFx0XHRpZih0bj09XCJnXCIpIHsgVHlwci5TVkcuX3RvUGF0aChuZC5jaGlsZHJlbiwgcHRoLCBjZmwpOyB9XG4gIFx0XHRlbHNlIGlmKHRuPT1cInBhdGhcIikge1xuICBcdFx0XHRwdGguY21kcy5wdXNoKGNmbD9jZmw6XCIjMDAwMDAwXCIpO1xuICBcdFx0XHR2YXIgZCA9IG5kLmdldEF0dHJpYnV0ZShcImRcIik7ICAvL2NvbnNvbGUubG9nKGQpO1xuICBcdFx0XHR2YXIgdG9rcyA9IFR5cHIuU1ZHLl90b2tlbnMoZCk7ICAvL2NvbnNvbGUubG9nKHRva3MpO1xuICBcdFx0XHRUeXByLlNWRy5fdG9rc1RvUGF0aCh0b2tzLCBwdGgpOyAgcHRoLmNtZHMucHVzaChcIlhcIik7XG4gIFx0XHR9XG4gIFx0XHRlbHNlIGlmKHRuPT1cImRlZnNcIikgO1xuICBcdFx0ZWxzZSB7IGNvbnNvbGUubG9nKHRuLCBuZCk7IH1cbiAgXHR9XG4gIH07XG5cbiAgVHlwci5TVkcuX3Rva2VucyA9IGZ1bmN0aW9uKGQpIHtcbiAgXHR2YXIgdHMgPSBbXSwgb2ZmID0gMCwgcm49ZmFsc2UsIGNuPVwiXCI7ICAvLyByZWFkaW5nIG51bWJlciwgY3VycmVudCBudW1iZXJcbiAgXHR3aGlsZShvZmY8ZC5sZW5ndGgpe1xuICBcdFx0dmFyIGNjPWQuY2hhckNvZGVBdChvZmYpLCBjaCA9IGQuY2hhckF0KG9mZik7ICBvZmYrKztcbiAgXHRcdHZhciBpc051bSA9ICg0ODw9Y2MgJiYgY2M8PTU3KSB8fCBjaD09XCIuXCIgfHwgY2g9PVwiLVwiO1xuICBcdFx0XG4gIFx0XHRpZihybikge1xuICBcdFx0XHRpZihjaD09XCItXCIpIHsgIHRzLnB1c2gocGFyc2VGbG9hdChjbikpOyAgY249Y2g7ICB9XG4gIFx0XHRcdGVsc2UgaWYoaXNOdW0pIHsgY24rPWNoOyB9XG4gIFx0XHRcdGVsc2UgeyAgdHMucHVzaChwYXJzZUZsb2F0KGNuKSk7ICBpZihjaCE9XCIsXCIgJiYgY2ghPVwiIFwiKSB7IHRzLnB1c2goY2gpOyB9ICBybj1mYWxzZTsgIH1cbiAgXHRcdH1cbiAgXHRcdGVsc2Uge1xuICBcdFx0XHRpZihpc051bSkgeyAgY249Y2g7ICBybj10cnVlOyAgfVxuICBcdFx0XHRlbHNlIGlmKGNoIT1cIixcIiAmJiBjaCE9XCIgXCIpIHsgdHMucHVzaChjaCk7IH1cbiAgXHRcdH1cbiAgXHR9XG4gIFx0aWYocm4pIHsgdHMucHVzaChwYXJzZUZsb2F0KGNuKSk7IH1cbiAgXHRyZXR1cm4gdHM7XG4gIH07XG5cbiAgVHlwci5TVkcuX3Rva3NUb1BhdGggPSBmdW5jdGlvbih0cywgcHRoKSB7XHRcbiAgXHR2YXIgaSA9IDAsIHggPSAwLCB5ID0gMCwgb3ggPSAwLCBveSA9IDA7XG4gIFx0dmFyIHBjID0ge1wiTVwiOjIsXCJMXCI6MixcIkhcIjoxLFwiVlwiOjEsICAgXCJTXCI6NCwgICBcIkNcIjo2fTtcbiAgXHR2YXIgY21kcyA9IHB0aC5jbWRzLCBjcmRzID0gcHRoLmNyZHM7XG4gIFx0XG4gIFx0d2hpbGUoaTx0cy5sZW5ndGgpIHtcbiAgXHRcdHZhciBjbWQgPSB0c1tpXTsgIGkrKztcbiAgXHRcdFxuICBcdFx0aWYoY21kPT1cInpcIikgeyAgY21kcy5wdXNoKFwiWlwiKTsgIHg9b3g7ICB5PW95OyAgfVxuICBcdFx0ZWxzZSB7XG4gIFx0XHRcdHZhciBjbXUgPSBjbWQudG9VcHBlckNhc2UoKTtcbiAgXHRcdFx0dmFyIHBzID0gcGNbY211XSwgcmVwcyA9IFR5cHIuU1ZHLl9yZXBzKHRzLCBpLCBwcyk7XG4gIFx0XHRcbiAgXHRcdFx0Zm9yKHZhciBqPTA7IGo8cmVwczsgaisrKSB7XG4gIFx0XHRcdFx0dmFyIHhpID0gMCwgeWkgPSAwOyAgIGlmKGNtZCE9Y211KSB7ICB4aT14OyAgeWk9eTsgIH1cbiAgXHRcdFx0XHRcbiAgXHRcdFx0XHRpZihjbXU9PVwiTVwiKSB7ICB4ID0geGkrdHNbaSsrXTsgIHkgPSB5aSt0c1tpKytdOyAgY21kcy5wdXNoKFwiTVwiKTsgIGNyZHMucHVzaCh4LHkpOyAgb3g9eDsgIG95PXk7IH1cbiAgXHRcdFx0XHRlbHNlIGlmKGNtdT09XCJMXCIpIHsgIHggPSB4aSt0c1tpKytdOyAgeSA9IHlpK3RzW2krK107ICBjbWRzLnB1c2goXCJMXCIpOyAgY3Jkcy5wdXNoKHgseSk7ICB9XG4gIFx0XHRcdFx0ZWxzZSBpZihjbXU9PVwiSFwiKSB7ICB4ID0geGkrdHNbaSsrXTsgICAgICAgICAgICAgICAgICAgY21kcy5wdXNoKFwiTFwiKTsgIGNyZHMucHVzaCh4LHkpOyAgfVxuICBcdFx0XHRcdGVsc2UgaWYoY211PT1cIlZcIikgeyAgeSA9IHlpK3RzW2krK107ICAgICAgICAgICAgICAgICAgIGNtZHMucHVzaChcIkxcIik7ICBjcmRzLnB1c2goeCx5KTsgIH1cbiAgXHRcdFx0XHRlbHNlIGlmKGNtdT09XCJDXCIpIHtcbiAgXHRcdFx0XHRcdHZhciB4MT14aSt0c1tpKytdLCB5MT15aSt0c1tpKytdLCB4Mj14aSt0c1tpKytdLCB5Mj15aSt0c1tpKytdLCB4Mz14aSt0c1tpKytdLCB5Mz15aSt0c1tpKytdO1xuICBcdFx0XHRcdFx0Y21kcy5wdXNoKFwiQ1wiKTsgIGNyZHMucHVzaCh4MSx5MSx4Mix5Mix4Myx5Myk7ICB4PXgzOyAgeT15MztcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdFx0ZWxzZSBpZihjbXU9PVwiU1wiKSB7XG4gIFx0XHRcdFx0XHR2YXIgY28gPSBNYXRoLm1heChjcmRzLmxlbmd0aC00LCAwKTtcbiAgXHRcdFx0XHRcdHZhciB4MSA9IHgreC1jcmRzW2NvXSwgeTEgPSB5K3ktY3Jkc1tjbysxXTtcbiAgXHRcdFx0XHRcdHZhciB4Mj14aSt0c1tpKytdLCB5Mj15aSt0c1tpKytdLCB4Mz14aSt0c1tpKytdLCB5Mz15aSt0c1tpKytdOyAgXG4gIFx0XHRcdFx0XHRjbWRzLnB1c2goXCJDXCIpOyAgY3Jkcy5wdXNoKHgxLHkxLHgyLHkyLHgzLHkzKTsgIHg9eDM7ICB5PXkzO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0XHRlbHNlIHsgY29uc29sZS5sb2coXCJVbmtub3duIFNWRyBjb21tYW5kIFwiK2NtZCk7IH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cbiAgfTtcbiAgVHlwci5TVkcuX3JlcHMgPSBmdW5jdGlvbih0cywgb2ZmLCBwcykge1xuICBcdHZhciBpID0gb2ZmO1xuICBcdHdoaWxlKGk8dHMubGVuZ3RoKSB7ICBpZigodHlwZW9mIHRzW2ldKSA9PSBcInN0cmluZ1wiKSB7IGJyZWFrOyB9ICBpKz1wczsgIH1cbiAgXHRyZXR1cm4gKGktb2ZmKS9wcztcbiAgfTtcbiAgLy8gRW5kIFR5cHIuanNcblxuICAvLyBCZWdpbiBUeXByLlUuanNcblxuICBpZihUeXByICA9PW51bGwpIHsgVHlwciAgID0ge307IH1cbiAgaWYoVHlwci5VPT1udWxsKSB7IFR5cHIuVSA9IHt9OyB9XG5cblxuICBUeXByLlUuY29kZVRvR2x5cGggPSBmdW5jdGlvbihmb250LCBjb2RlKVxuICB7XG4gIFx0dmFyIGNtYXAgPSBmb250LmNtYXA7XG4gIFx0XG4gIFx0dmFyIHRpbmQgPSAtMTtcbiAgXHRpZihjbWFwLnAwZTQhPW51bGwpIHsgdGluZCA9IGNtYXAucDBlNDsgfVxuICBcdGVsc2UgaWYoY21hcC5wM2UxIT1udWxsKSB7IHRpbmQgPSBjbWFwLnAzZTE7IH1cbiAgXHRlbHNlIGlmKGNtYXAucDFlMCE9bnVsbCkgeyB0aW5kID0gY21hcC5wMWUwOyB9XG4gIFx0ZWxzZSBpZihjbWFwLnAwZTMhPW51bGwpIHsgdGluZCA9IGNtYXAucDBlMzsgfVxuICBcdFxuICBcdGlmKHRpbmQ9PS0xKSB7IHRocm93IFwibm8gZmFtaWxpYXIgcGxhdGZvcm0gYW5kIGVuY29kaW5nIVwiOyB9XG4gIFx0XG4gIFx0dmFyIHRhYiA9IGNtYXAudGFibGVzW3RpbmRdO1xuICBcdFxuICBcdGlmKHRhYi5mb3JtYXQ9PTApXG4gIFx0e1xuICBcdFx0aWYoY29kZT49dGFiLm1hcC5sZW5ndGgpIHsgcmV0dXJuIDA7IH1cbiAgXHRcdHJldHVybiB0YWIubWFwW2NvZGVdO1xuICBcdH1cbiAgXHRlbHNlIGlmKHRhYi5mb3JtYXQ9PTQpXG4gIFx0e1xuICBcdFx0dmFyIHNpbmQgPSAtMTtcbiAgXHRcdGZvcih2YXIgaT0wOyBpPHRhYi5lbmRDb3VudC5sZW5ndGg7IGkrKykgICB7IGlmKGNvZGU8PXRhYi5lbmRDb3VudFtpXSl7ICBzaW5kPWk7ICBicmVhazsgIH0gfSBcbiAgXHRcdGlmKHNpbmQ9PS0xKSB7IHJldHVybiAwOyB9XG4gIFx0XHRpZih0YWIuc3RhcnRDb3VudFtzaW5kXT5jb2RlKSB7IHJldHVybiAwOyB9XG4gIFx0XHRcbiAgXHRcdHZhciBnbGkgPSAwO1xuICBcdFx0aWYodGFiLmlkUmFuZ2VPZmZzZXRbc2luZF0hPTApIHsgZ2xpID0gdGFiLmdseXBoSWRBcnJheVsoY29kZS10YWIuc3RhcnRDb3VudFtzaW5kXSkgKyAodGFiLmlkUmFuZ2VPZmZzZXRbc2luZF0+PjEpIC0gKHRhYi5pZFJhbmdlT2Zmc2V0Lmxlbmd0aC1zaW5kKV07IH1cbiAgXHRcdGVsc2UgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGdsaSA9IGNvZGUgKyB0YWIuaWREZWx0YVtzaW5kXTsgfVxuICBcdFx0cmV0dXJuIGdsaSAmIDB4RkZGRjtcbiAgXHR9XG4gIFx0ZWxzZSBpZih0YWIuZm9ybWF0PT0xMilcbiAgXHR7XG4gIFx0XHRpZihjb2RlPnRhYi5ncm91cHNbdGFiLmdyb3Vwcy5sZW5ndGgtMV1bMV0pIHsgcmV0dXJuIDA7IH1cbiAgXHRcdGZvcih2YXIgaT0wOyBpPHRhYi5ncm91cHMubGVuZ3RoOyBpKyspXG4gIFx0XHR7XG4gIFx0XHRcdHZhciBncnAgPSB0YWIuZ3JvdXBzW2ldO1xuICBcdFx0XHRpZihncnBbMF08PWNvZGUgJiYgY29kZTw9Z3JwWzFdKSB7IHJldHVybiBncnBbMl0gKyAoY29kZS1ncnBbMF0pOyB9XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gMDtcbiAgXHR9XG4gIFx0ZWxzZSB7IHRocm93IFwidW5rbm93biBjbWFwIHRhYmxlIGZvcm1hdCBcIit0YWIuZm9ybWF0OyB9XG4gIH07XG5cblxuICBUeXByLlUuZ2x5cGhUb1BhdGggPSBmdW5jdGlvbihmb250LCBnaWQpXG4gIHtcbiAgXHR2YXIgcGF0aCA9IHsgY21kczpbXSwgY3JkczpbXSB9O1xuICBcdGlmKGZvbnQuU1ZHICYmIGZvbnQuU1ZHLmVudHJpZXNbZ2lkXSkge1xuICBcdFx0dmFyIHAgPSBmb250LlNWRy5lbnRyaWVzW2dpZF07ICBpZihwPT1udWxsKSB7IHJldHVybiBwYXRoOyB9XG4gIFx0XHRpZih0eXBlb2YgcCA9PSBcInN0cmluZ1wiKSB7ICBwID0gVHlwci5TVkcudG9QYXRoKHApOyAgZm9udC5TVkcuZW50cmllc1tnaWRdPXA7ICB9XG4gIFx0XHRyZXR1cm4gcDtcbiAgXHR9XG4gIFx0ZWxzZSBpZihmb250LkNGRikge1xuICBcdFx0dmFyIHN0YXRlID0ge3g6MCx5OjAsc3RhY2s6W10sblN0ZW1zOjAsaGF2ZVdpZHRoOmZhbHNlLHdpZHRoOiBmb250LkNGRi5Qcml2YXRlID8gZm9udC5DRkYuUHJpdmF0ZS5kZWZhdWx0V2lkdGhYIDogMCxvcGVuOmZhbHNlfTtcbiAgXHRcdHZhciBjZmY9Zm9udC5DRkYsIHBkY3QgPSBmb250LkNGRi5Qcml2YXRlO1xuICBcdFx0aWYoY2ZmLlJPUykge1xuICBcdFx0XHR2YXIgZ2kgPSAwO1xuICBcdFx0XHR3aGlsZShjZmYuRkRTZWxlY3RbZ2krMl08PWdpZCkgeyBnaSs9MjsgfVxuICBcdFx0XHRwZGN0ID0gY2ZmLkZEQXJyYXlbY2ZmLkZEU2VsZWN0W2dpKzFdXS5Qcml2YXRlO1xuICBcdFx0fVxuICBcdFx0VHlwci5VLl9kcmF3Q0ZGKGZvbnQuQ0ZGLkNoYXJTdHJpbmdzW2dpZF0sIHN0YXRlLCBjZmYsIHBkY3QsIHBhdGgpO1xuICBcdH1cbiAgXHRlbHNlIGlmKGZvbnQuZ2x5ZikgeyAgVHlwci5VLl9kcmF3R2x5ZihnaWQsIGZvbnQsIHBhdGgpOyAgfVxuICBcdHJldHVybiBwYXRoO1xuICB9O1xuXG4gIFR5cHIuVS5fZHJhd0dseWYgPSBmdW5jdGlvbihnaWQsIGZvbnQsIHBhdGgpXG4gIHtcbiAgXHR2YXIgZ2wgPSBmb250LmdseWZbZ2lkXTtcbiAgXHRpZihnbD09bnVsbCkgeyBnbCA9IGZvbnQuZ2x5ZltnaWRdID0gVHlwci5nbHlmLl9wYXJzZUdseWYoZm9udCwgZ2lkKTsgfVxuICBcdGlmKGdsIT1udWxsKXtcbiAgXHRcdGlmKGdsLm5vYz4tMSkgeyBUeXByLlUuX3NpbXBsZUdseXBoKGdsLCBwYXRoKTsgfVxuICBcdFx0ZWxzZSAgICAgICAgICB7IFR5cHIuVS5fY29tcG9HbHlwaCAoZ2wsIGZvbnQsIHBhdGgpOyB9XG4gIFx0fVxuICB9O1xuICBUeXByLlUuX3NpbXBsZUdseXBoID0gZnVuY3Rpb24oZ2wsIHApXG4gIHtcbiAgXHRmb3IodmFyIGM9MDsgYzxnbC5ub2M7IGMrKylcbiAgXHR7XG4gIFx0XHR2YXIgaTAgPSAoYz09MCkgPyAwIDogKGdsLmVuZFB0c1tjLTFdICsgMSk7XG4gIFx0XHR2YXIgaWwgPSBnbC5lbmRQdHNbY107XG4gIFx0XHRcbiAgXHRcdGZvcih2YXIgaT1pMDsgaTw9aWw7IGkrKylcbiAgXHRcdHtcbiAgXHRcdFx0dmFyIHByID0gKGk9PWkwKT9pbDooaS0xKTtcbiAgXHRcdFx0dmFyIG54ID0gKGk9PWlsKT9pMDooaSsxKTtcbiAgXHRcdFx0dmFyIG9uQ3VydmUgPSBnbC5mbGFnc1tpXSYxO1xuICBcdFx0XHR2YXIgcHJPbkN1cnZlID0gZ2wuZmxhZ3NbcHJdJjE7XG4gIFx0XHRcdHZhciBueE9uQ3VydmUgPSBnbC5mbGFnc1tueF0mMTtcbiAgXHRcdFx0XG4gIFx0XHRcdHZhciB4ID0gZ2wueHNbaV0sIHkgPSBnbC55c1tpXTtcbiAgXHRcdFx0XG4gIFx0XHRcdGlmKGk9PWkwKSB7IFxuICBcdFx0XHRcdGlmKG9uQ3VydmUpICBcbiAgXHRcdFx0XHR7XG4gIFx0XHRcdFx0XHRpZihwck9uQ3VydmUpIHsgVHlwci5VLlAubW92ZVRvKHAsIGdsLnhzW3ByXSwgZ2wueXNbcHJdKTsgfSBcbiAgXHRcdFx0XHRcdGVsc2UgICAgICAgICAgeyAgVHlwci5VLlAubW92ZVRvKHAseCx5KTsgIGNvbnRpbnVlOyAgLyogIHdpbGwgZG8gY3VydmVUbyBhdCBpbCAgKi8gIH1cbiAgXHRcdFx0XHR9XG4gIFx0XHRcdFx0ZWxzZSAgICAgICAgXG4gIFx0XHRcdFx0e1xuICBcdFx0XHRcdFx0aWYocHJPbkN1cnZlKSB7IFR5cHIuVS5QLm1vdmVUbyhwLCAgZ2wueHNbcHJdLCAgICAgICBnbC55c1twcl0gICAgICAgICk7IH1cbiAgXHRcdFx0XHRcdGVsc2UgICAgICAgICAgeyBUeXByLlUuUC5tb3ZlVG8ocCwgKGdsLnhzW3ByXSt4KS8yLCAoZ2wueXNbcHJdK3kpLzIgICApOyB9IFxuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0XHRpZihvbkN1cnZlKVxuICBcdFx0XHR7XG4gIFx0XHRcdFx0aWYocHJPbkN1cnZlKSB7IFR5cHIuVS5QLmxpbmVUbyhwLHgseSk7IH1cbiAgXHRcdFx0fVxuICBcdFx0XHRlbHNlXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRpZihueE9uQ3VydmUpIHsgVHlwci5VLlAucWN1cnZlVG8ocCwgeCwgeSwgZ2wueHNbbnhdLCBnbC55c1tueF0pOyB9IFxuICBcdFx0XHRcdGVsc2UgICAgICAgICAgeyBUeXByLlUuUC5xY3VydmVUbyhwLCB4LCB5LCAoeCtnbC54c1tueF0pLzIsICh5K2dsLnlzW254XSkvMik7IH0gXG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHRcdFR5cHIuVS5QLmNsb3NlUGF0aChwKTtcbiAgXHR9XG4gIH07XG4gIFR5cHIuVS5fY29tcG9HbHlwaCA9IGZ1bmN0aW9uKGdsLCBmb250LCBwKVxuICB7XG4gIFx0Zm9yKHZhciBqPTA7IGo8Z2wucGFydHMubGVuZ3RoOyBqKyspXG4gIFx0e1xuICBcdFx0dmFyIHBhdGggPSB7IGNtZHM6W10sIGNyZHM6W10gfTtcbiAgXHRcdHZhciBwcnQgPSBnbC5wYXJ0c1tqXTtcbiAgXHRcdFR5cHIuVS5fZHJhd0dseWYocHJ0LmdseXBoSW5kZXgsIGZvbnQsIHBhdGgpO1xuICBcdFx0XG4gIFx0XHR2YXIgbSA9IHBydC5tO1xuICBcdFx0Zm9yKHZhciBpPTA7IGk8cGF0aC5jcmRzLmxlbmd0aDsgaSs9MilcbiAgXHRcdHtcbiAgXHRcdFx0dmFyIHggPSBwYXRoLmNyZHNbaSAgXSwgeSA9IHBhdGguY3Jkc1tpKzFdO1xuICBcdFx0XHRwLmNyZHMucHVzaCh4Km0uYSArIHkqbS5iICsgbS50eCk7XG4gIFx0XHRcdHAuY3Jkcy5wdXNoKHgqbS5jICsgeSptLmQgKyBtLnR5KTtcbiAgXHRcdH1cbiAgXHRcdGZvcih2YXIgaT0wOyBpPHBhdGguY21kcy5sZW5ndGg7IGkrKykgeyBwLmNtZHMucHVzaChwYXRoLmNtZHNbaV0pOyB9XG4gIFx0fVxuICB9O1xuXG5cbiAgVHlwci5VLl9nZXRHbHlwaENsYXNzID0gZnVuY3Rpb24oZywgY2QpXG4gIHtcbiAgXHR2YXIgaW50ciA9IFR5cHIuX2xjdGYuZ2V0SW50ZXJ2YWwoY2QsIGcpO1xuICBcdHJldHVybiBpbnRyPT0tMSA/IDAgOiBjZFtpbnRyKzJdO1xuICBcdC8vZm9yKHZhciBpPTA7IGk8Y2Quc3RhcnQubGVuZ3RoOyBpKyspIFxuICBcdC8vXHRpZihjZC5zdGFydFtpXTw9ZyAmJiBjZC5lbmRbaV0+PWcpIHJldHVybiBjZC5jbGFzc1tpXTtcbiAgXHQvL3JldHVybiAwO1xuICB9O1xuXG4gIFR5cHIuVS5nZXRQYWlyQWRqdXN0bWVudCA9IGZ1bmN0aW9uKGZvbnQsIGcxLCBnMilcbiAge1xuICBcdC8vcmV0dXJuIDA7XG4gIFx0aWYoZm9udC5HUE9TKSB7XG4gIFx0XHR2YXIgZ3BvcyA9IGZvbnRbXCJHUE9TXCJdO1xuICBcdFx0dmFyIGxsaXN0ID0gZ3Bvcy5sb29rdXBMaXN0LCBmbGlzdCA9IGdwb3MuZmVhdHVyZUxpc3Q7XG4gIFx0XHR2YXIgdHVzZWQgPSBbXTtcbiAgXHRcdGZvcih2YXIgaT0wOyBpPGZsaXN0Lmxlbmd0aDsgaSsrKSBcbiAgXHRcdHtcbiAgXHRcdFx0dmFyIGZsID0gZmxpc3RbaV07ICAvL2NvbnNvbGUubG9nKGZsKTtcbiAgXHRcdFx0aWYoZmwudGFnIT1cImtlcm5cIikgeyBjb250aW51ZTsgfVxuICBcdFx0XHRmb3IodmFyIHRpPTA7IHRpPGZsLnRhYi5sZW5ndGg7IHRpKyspIHtcbiAgXHRcdFx0XHRpZih0dXNlZFtmbC50YWJbdGldXSkgeyBjb250aW51ZTsgfSAgdHVzZWRbZmwudGFiW3RpXV0gPSB0cnVlO1xuICBcdFx0XHRcdHZhciB0YWIgPSBsbGlzdFtmbC50YWJbdGldXTtcbiAgXHRcdFx0XHQvL2NvbnNvbGUubG9nKHRhYik7XG4gIFx0XHRcdFx0XG4gIFx0XHRcdFx0Zm9yKHZhciBqPTA7IGo8dGFiLnRhYnMubGVuZ3RoOyBqKyspXG4gIFx0XHRcdFx0e1xuICBcdFx0XHRcdFx0aWYodGFiLnRhYnNbaV09PW51bGwpIHsgY29udGludWU7IH1cbiAgXHRcdFx0XHRcdHZhciBsdGFiID0gdGFiLnRhYnNbal0sIGluZDtcbiAgXHRcdFx0XHRcdGlmKGx0YWIuY292ZXJhZ2UpIHsgIGluZCA9IFR5cHIuX2xjdGYuY292ZXJhZ2VJbmRleChsdGFiLmNvdmVyYWdlLCBnMSk7ICBpZihpbmQ9PS0xKSB7IGNvbnRpbnVlOyB9ICB9XG4gIFx0XHRcdFx0XHRcbiAgXHRcdFx0XHRcdGlmKHRhYi5sdHlwZT09MSkgO1xuICBcdFx0XHRcdFx0ZWxzZSBpZih0YWIubHR5cGU9PTIpXG4gIFx0XHRcdFx0XHR7XG4gIFx0XHRcdFx0XHRcdHZhciBhZGo7XG4gIFx0XHRcdFx0XHRcdGlmKGx0YWIuZm10PT0xKVxuICBcdFx0XHRcdFx0XHR7XG4gIFx0XHRcdFx0XHRcdFx0dmFyIHJpZ2h0ID0gbHRhYi5wYWlyc2V0c1tpbmRdO1xuICBcdFx0XHRcdFx0XHRcdGZvcih2YXIgaT0wOyBpPHJpZ2h0Lmxlbmd0aDsgaSsrKSB7IGlmKHJpZ2h0W2ldLmdpZDI9PWcyKSB7IGFkaiA9IHJpZ2h0W2ldOyB9IH1cbiAgXHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0XHRlbHNlIGlmKGx0YWIuZm10PT0yKVxuICBcdFx0XHRcdFx0XHR7XG4gIFx0XHRcdFx0XHRcdFx0dmFyIGMxID0gVHlwci5VLl9nZXRHbHlwaENsYXNzKGcxLCBsdGFiLmNsYXNzRGVmMSk7XG4gIFx0XHRcdFx0XHRcdFx0dmFyIGMyID0gVHlwci5VLl9nZXRHbHlwaENsYXNzKGcyLCBsdGFiLmNsYXNzRGVmMik7XG4gIFx0XHRcdFx0XHRcdFx0YWRqID0gbHRhYi5tYXRyaXhbYzFdW2MyXTtcbiAgXHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0XHQvL2lmKGFkaikgY29uc29sZS5sb2cobHRhYiwgYWRqKTtcbiAgXHRcdFx0XHRcdFx0aWYoYWRqICYmIGFkai52YWwyKSB7IHJldHVybiBhZGoudmFsMlsyXTsgfVxuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cbiAgXHRpZihmb250Lmtlcm4pXG4gIFx0e1xuICBcdFx0dmFyIGluZDEgPSBmb250Lmtlcm4uZ2x5cGgxLmluZGV4T2YoZzEpO1xuICBcdFx0aWYoaW5kMSE9LTEpXG4gIFx0XHR7XG4gIFx0XHRcdHZhciBpbmQyID0gZm9udC5rZXJuLnJ2YWxbaW5kMV0uZ2x5cGgyLmluZGV4T2YoZzIpO1xuICBcdFx0XHRpZihpbmQyIT0tMSkgeyByZXR1cm4gZm9udC5rZXJuLnJ2YWxbaW5kMV0udmFsc1tpbmQyXTsgfVxuICBcdFx0fVxuICBcdH1cbiAgXHRcbiAgXHRyZXR1cm4gMDtcbiAgfTtcblxuICBUeXByLlUuc3RyaW5nVG9HbHlwaHMgPSBmdW5jdGlvbihmb250LCBzdHIpXG4gIHtcbiAgXHR2YXIgZ2xzID0gW107XG4gIFx0Zm9yKHZhciBpPTA7IGk8c3RyLmxlbmd0aDsgaSsrKSB7XG4gIFx0XHR2YXIgY2MgPSBzdHIuY29kZVBvaW50QXQoaSk7ICBpZihjYz4weGZmZmYpIHsgaSsrOyB9XG4gIFx0XHRnbHMucHVzaChUeXByLlUuY29kZVRvR2x5cGgoZm9udCwgY2MpKTtcbiAgXHR9XG4gIFx0Zm9yKHZhciBpPTA7IGk8c3RyLmxlbmd0aDsgaSsrKSB7XG4gIFx0XHR2YXIgY2MgPSBzdHIuY29kZVBvaW50QXQoaSk7ICAvL1xuICBcdFx0aWYoY2M9PTIzNjcpIHsgIHZhciB0PWdsc1tpLTFdOyAgZ2xzW2ktMV09Z2xzW2ldOyAgZ2xzW2ldPXQ7ICB9XG4gIFx0XHQvL2lmKGNjPT0yMzgxKSB7ICB2YXIgdD1nbHNbaSsxXTsgIGdsc1tpKzFdPWdsc1tpXTsgIGdsc1tpXT10OyAgfVxuICBcdFx0aWYoY2M+MHhmZmZmKSB7IGkrKzsgfVxuICBcdH1cbiAgXHQvL2NvbnNvbGUubG9nKGdscy5zbGljZSgwKSk7XG4gIFx0XG4gIFx0Ly9jb25zb2xlLmxvZyhnbHMpOyAgcmV0dXJuIGdscztcbiAgXHRcbiAgXHR2YXIgZ3N1YiA9IGZvbnRbXCJHU1VCXCJdOyAgaWYoZ3N1Yj09bnVsbCkgeyByZXR1cm4gZ2xzOyB9XG4gIFx0dmFyIGxsaXN0ID0gZ3N1Yi5sb29rdXBMaXN0LCBmbGlzdCA9IGdzdWIuZmVhdHVyZUxpc3Q7XG4gIFx0XG4gIFx0dmFyIGNsaWdzID0gW1wicmxpZ1wiLCBcImxpZ2FcIiwgXCJtc2V0XCIsICBcImlzb2xcIixcImluaXRcIixcImZpbmFcIixcIm1lZGlcIiwgICBcImhhbGZcIiwgXCJwcmVzXCIsIFxuICBcdFx0XHRcdFwiYmx3c1wiIC8qIFRpYmV0YW4gZm9udHMgbGlrZSBIaW1hbGF5YS50dGYgKi8gXTtcbiAgXHRcbiAgXHQvL2NvbnNvbGUubG9nKGdscy5zbGljZSgwKSk7XG4gIFx0dmFyIHR1c2VkID0gW107XG4gIFx0Zm9yKHZhciBmaT0wOyBmaTxmbGlzdC5sZW5ndGg7IGZpKyspXG4gIFx0e1xuICBcdFx0dmFyIGZsID0gZmxpc3RbZmldOyAgaWYoY2xpZ3MuaW5kZXhPZihmbC50YWcpPT0tMSkgeyBjb250aW51ZTsgfVxuICBcdFx0Ly9pZihmbC50YWc9PVwiYmx3ZlwiKSBjb250aW51ZTtcbiAgXHRcdC8vY29uc29sZS5sb2coZmwpO1xuICBcdFx0Ly9jb25zb2xlLmxvZyhmbC50YWcpO1xuICBcdFx0Zm9yKHZhciB0aT0wOyB0aTxmbC50YWIubGVuZ3RoOyB0aSsrKSB7XG4gIFx0XHRcdGlmKHR1c2VkW2ZsLnRhYlt0aV1dKSB7IGNvbnRpbnVlOyB9ICB0dXNlZFtmbC50YWJbdGldXSA9IHRydWU7XG4gIFx0XHRcdHZhciB0YWIgPSBsbGlzdFtmbC50YWJbdGldXTtcbiAgXHRcdFx0Ly9jb25zb2xlLmxvZyhmbC50YWJbdGldLCB0YWIubHR5cGUpO1xuICBcdFx0XHQvL2NvbnNvbGUubG9nKGZsLnRhZywgdGFiKTtcbiAgXHRcdFx0Zm9yKHZhciBjaT0wOyBjaTxnbHMubGVuZ3RoOyBjaSsrKSB7XG4gIFx0XHRcdFx0dmFyIGZlYXQgPSBUeXByLlUuX2dldFdQZmVhdHVyZShzdHIsIGNpKTtcbiAgXHRcdFx0XHRpZihcImlzb2wsaW5pdCxmaW5hLG1lZGlcIi5pbmRleE9mKGZsLnRhZykhPS0xICYmIGZsLnRhZyE9ZmVhdCkgeyBjb250aW51ZTsgfVxuICBcdFx0XHRcdFxuICBcdFx0XHRcdFR5cHIuVS5fYXBwbHlTdWJzKGdscywgY2ksIHRhYiwgbGxpc3QpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuICBcdFxuICBcdHJldHVybiBnbHM7XG4gIH07XG4gIFR5cHIuVS5fZ2V0V1BmZWF0dXJlID0gZnVuY3Rpb24oc3RyLCBjaSkgeyAgLy8gZ2V0IFdvcmQgUG9zaXRpb24gZmVhdHVyZVxuICBcdHZhciB3c2VwID0gXCJcXG5cXHRcXFwiICwuOjshPygpICDYjFwiO1xuICBcdHZhciBSID0gXCLYotij2KTYpdin2KnYr9iw2LHYstmI2bHZstmz2bXZttm32ojaidqK2ovajNqN2o7aj9qQ2pHaktqT2pTaldqW2pfamNqZ24Dbg9uE24XbhtuH24jbiduK24vbjduP25Lbk9uV267br9yQ3JXcltyX3Jjcmdye3Kjcqtys3K/djd2Z3Zrdm92r3azdsd2z3bTduN254KGA4KGG4KGH4KGJ4KGU4KGn4KGp4KGq4KKq4KKr4KKs4KKu4KKx4KKy4KK54KuF4KuH4KuJ4KuK4KuO4KuP4KuQ4KuR4KuS4Kud4Kuh4Kuk4Kuv4K6B4K6D4K6E4K6F4K6J4K6M4K6O4K6P4K6R4K6p4K6q4K6r4K6sXCI7XG4gIFx0dmFyIEwgPSBcIuqhsuCrjeCrl1wiO1xuICBcdFxuICBcdHZhciBzbGZ0ID0gY2k9PTAgICAgICAgICAgICB8fCB3c2VwLmluZGV4T2Yoc3RyW2NpLTFdKSE9LTE7XG4gIFx0dmFyIHNyZ3QgPSBjaT09c3RyLmxlbmd0aC0xIHx8IHdzZXAuaW5kZXhPZihzdHJbY2krMV0pIT0tMTtcbiAgXHRcdFxuICBcdGlmKCFzbGZ0ICYmIFIuaW5kZXhPZihzdHJbY2ktMV0pIT0tMSkgeyBzbGZ0PXRydWU7IH1cbiAgXHRpZighc3JndCAmJiBSLmluZGV4T2Yoc3RyW2NpICBdKSE9LTEpIHsgc3JndD10cnVlOyB9XG4gIFx0XHRcbiAgXHRpZighc3JndCAmJiBMLmluZGV4T2Yoc3RyW2NpKzFdKSE9LTEpIHsgc3JndD10cnVlOyB9XG4gIFx0aWYoIXNsZnQgJiYgTC5pbmRleE9mKHN0cltjaSAgXSkhPS0xKSB7IHNsZnQ9dHJ1ZTsgfVxuICBcdFx0XG4gIFx0dmFyIGZlYXQgPSBudWxsO1xuICBcdGlmKHNsZnQpIHsgZmVhdCA9IHNyZ3QgPyBcImlzb2xcIiA6IFwiaW5pdFwiOyB9XG4gIFx0ZWxzZSAgICAgeyBmZWF0ID0gc3JndCA/IFwiZmluYVwiIDogXCJtZWRpXCI7IH1cbiAgXHRcbiAgXHRyZXR1cm4gZmVhdDtcbiAgfTtcbiAgVHlwci5VLl9hcHBseVN1YnMgPSBmdW5jdGlvbihnbHMsIGNpLCB0YWIsIGxsaXN0KSB7XG4gIFx0dmFyIHJsaW0gPSBnbHMubGVuZ3RoLWNpLTE7XG4gIFx0Ly9pZihjaT09MCkgY29uc29sZS5sb2coXCIrKysrIFwiLCB0YWIubHR5cGUpO1xuICBcdGZvcih2YXIgaj0wOyBqPHRhYi50YWJzLmxlbmd0aDsgaisrKVxuICBcdHtcbiAgXHRcdGlmKHRhYi50YWJzW2pdPT1udWxsKSB7IGNvbnRpbnVlOyB9XG4gIFx0XHR2YXIgbHRhYiA9IHRhYi50YWJzW2pdLCBpbmQ7XG4gIFx0XHRpZihsdGFiLmNvdmVyYWdlKSB7ICBpbmQgPSBUeXByLl9sY3RmLmNvdmVyYWdlSW5kZXgobHRhYi5jb3ZlcmFnZSwgZ2xzW2NpXSk7ICBpZihpbmQ9PS0xKSB7IGNvbnRpbnVlOyB9ICB9XG4gIFx0XHQvL2lmKGNpPT0wKSBjb25zb2xlLmxvZyhpbmQsIGx0YWIpO1xuICBcdFx0Ly8qXG4gIFx0XHRpZih0YWIubHR5cGU9PTEpIHtcbiAgXHRcdFx0dmFyIGdsID0gZ2xzW2NpXTtcbiAgXHRcdFx0aWYobHRhYi5mbXQ9PTEpIHsgZ2xzW2NpXSA9IGdsc1tjaV0rbHRhYi5kZWx0YTsgfVxuICBcdFx0XHRlbHNlICAgICAgICAgICAgeyBnbHNbY2ldID0gbHRhYi5uZXdnW2luZF07IH1cbiAgXHRcdFx0Ly9jb25zb2xlLmxvZyhcImFwcGx5aW5nIC4uLiAxXCIsIGNpLCBnbCwgZ2xzW2NpXSk7XG4gIFx0XHR9Ly8qXG4gIFx0XHRlbHNlIGlmKHRhYi5sdHlwZT09NCkge1xuICBcdFx0XHR2YXIgdmFscyA9IGx0YWIudmFsc1tpbmRdO1xuICBcdFx0XHRcbiAgXHRcdFx0Zm9yKHZhciBrPTA7IGs8dmFscy5sZW5ndGg7IGsrKykge1xuICBcdFx0XHRcdHZhciBsaWcgPSB2YWxzW2tdLCBybCA9IGxpZy5jaGFpbi5sZW5ndGg7ICBpZihybD5ybGltKSB7IGNvbnRpbnVlOyB9XG4gIFx0XHRcdFx0dmFyIGdvb2QgPSB0cnVlLCBlbTEgPSAwO1xuICBcdFx0XHRcdGZvcih2YXIgbD0wOyBsPHJsOyBsKyspIHsgIHdoaWxlKGdsc1tjaStlbTErKDErbCldPT0tMSl7IGVtMSsrOyB9ICBpZihsaWcuY2hhaW5bbF0hPWdsc1tjaStlbTErKDErbCldKSB7IGdvb2Q9ZmFsc2U7IH0gIH1cbiAgXHRcdFx0XHRpZighZ29vZCkgeyBjb250aW51ZTsgfVxuICBcdFx0XHRcdGdsc1tjaV09bGlnLm5nbHlwaDtcbiAgXHRcdFx0XHRmb3IodmFyIGw9MDsgbDxybCtlbTE7IGwrKykgeyBnbHNbY2krbCsxXT0tMTsgfSAgIGJyZWFrOyAgLy8gZmlyc3QgY2hhcmFjdGVyIGNoYW5nZWQsIG90aGVyIGxpZ2F0dXJlcyBkbyBub3QgYXBwbHkgYW55bW9yZVxuICBcdFx0XHRcdC8vY29uc29sZS5sb2coXCJsaWdcIiwgY2ksIGxpZy5jaGFpbiwgbGlnLm5nbHlwaCk7XG4gIFx0XHRcdFx0Ly9jb25zb2xlLmxvZyhcImFwcGx5aW5nIC4uLlwiKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdFx0ZWxzZSAgaWYodGFiLmx0eXBlPT01ICYmIGx0YWIuZm10PT0yKSB7XG4gIFx0XHRcdHZhciBjaW5kID0gVHlwci5fbGN0Zi5nZXRJbnRlcnZhbChsdGFiLmNEZWYsIGdsc1tjaV0pO1xuICBcdFx0XHR2YXIgY2xzID0gbHRhYi5jRGVmW2NpbmQrMl0sIHNjcyA9IGx0YWIuc2NzZXRbY2xzXTsgXG4gIFx0XHRcdGZvcih2YXIgaT0wOyBpPHNjcy5sZW5ndGg7IGkrKykge1xuICBcdFx0XHRcdHZhciBzYyA9IHNjc1tpXSwgaW5wID0gc2MuaW5wdXQ7XG4gIFx0XHRcdFx0aWYoaW5wLmxlbmd0aD5ybGltKSB7IGNvbnRpbnVlOyB9XG4gIFx0XHRcdFx0dmFyIGdvb2QgPSB0cnVlO1xuICBcdFx0XHRcdGZvcih2YXIgbD0wOyBsPGlucC5sZW5ndGg7IGwrKykge1xuICBcdFx0XHRcdFx0dmFyIGNpbmQyID0gVHlwci5fbGN0Zi5nZXRJbnRlcnZhbChsdGFiLmNEZWYsIGdsc1tjaSsxK2xdKTtcbiAgXHRcdFx0XHRcdGlmKGNpbmQ9PS0xICYmIGx0YWIuY0RlZltjaW5kMisyXSE9aW5wW2xdKSB7ICBnb29kPWZhbHNlOyAgYnJlYWs7ICB9XG4gIFx0XHRcdFx0fVxuICBcdFx0XHRcdGlmKCFnb29kKSB7IGNvbnRpbnVlOyB9XG4gIFx0XHRcdFx0Ly9jb25zb2xlLmxvZyhjaSwgZ2wpO1xuICBcdFx0XHRcdHZhciBscnMgPSBzYy5zdWJzdExvb2t1cFJlY29yZHM7XG4gIFx0XHRcdFx0Zm9yKHZhciBrPTA7IGs8bHJzLmxlbmd0aDsgays9MilcbiAgXHRcdFx0XHR7XG4gIFx0XHRcdFx0XHR2YXIgZ2kgPSBscnNba10sIHRhYmkgPSBscnNbaysxXTtcbiAgXHRcdFx0XHRcdC8vVHlwci5VLl9hcHBseVR5cGUxKGdscywgY2krZ2ksIGxsaXN0W3RhYmldKTtcbiAgXHRcdFx0XHRcdC8vY29uc29sZS5sb2codGFiaSwgZ2xzW2NpK2dpXSwgbGxpc3RbdGFiaV0pO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdFx0ZWxzZSBpZih0YWIubHR5cGU9PTYgJiYgbHRhYi5mbXQ9PTMpIHtcbiAgXHRcdFx0Ly9pZihsdGFiLmJhY2tDdmcubGVuZ3RoPT0wKSByZXR1cm47XG4gIFx0XHRcdGlmKCFUeXByLlUuX2dsc0NvdmVyZWQoZ2xzLCBsdGFiLmJhY2tDdmcsIGNpLWx0YWIuYmFja0N2Zy5sZW5ndGgpKSB7IGNvbnRpbnVlOyB9XG4gIFx0XHRcdGlmKCFUeXByLlUuX2dsc0NvdmVyZWQoZ2xzLCBsdGFiLmlucHRDdmcsIGNpKSkgeyBjb250aW51ZTsgfVxuICBcdFx0XHRpZighVHlwci5VLl9nbHNDb3ZlcmVkKGdscywgbHRhYi5haGVkQ3ZnLCBjaStsdGFiLmlucHRDdmcubGVuZ3RoKSkgeyBjb250aW51ZTsgfVxuICBcdFx0XHQvL2NvbnNvbGUubG9nKGNpLCBsdGFiKTtcbiAgXHRcdFx0dmFyIGxyID0gbHRhYi5sb29rdXBSZWM7ICAvL2NvbnNvbGUubG9nKGNpLCBnbCwgbHIpO1xuICBcdFx0XHRmb3IodmFyIGk9MDsgaTxsci5sZW5ndGg7IGkrPTIpIHtcbiAgXHRcdFx0XHR2YXIgY2luZCA9IGxyW2ldLCB0YWIyID0gbGxpc3RbbHJbaSsxXV07XG4gIFx0XHRcdFx0Ly9jb25zb2xlLmxvZyhcIi1cIiwgbHJbaSsxXSwgdGFiMik7XG4gIFx0XHRcdFx0VHlwci5VLl9hcHBseVN1YnMoZ2xzLCBjaStjaW5kLCB0YWIyLCBsbGlzdCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHRcdC8vZWxzZSBjb25zb2xlLmxvZyhcIlVua25vd24gdGFibGVcIiwgdGFiLmx0eXBlLCBsdGFiLmZtdCk7XG4gIFx0XHQvLyovXG4gIFx0fVxuICB9O1xuXG4gIFR5cHIuVS5fZ2xzQ292ZXJlZCA9IGZ1bmN0aW9uKGdscywgY3ZncywgY2kpIHtcbiAgXHRmb3IodmFyIGk9MDsgaTxjdmdzLmxlbmd0aDsgaSsrKSB7XG4gIFx0XHR2YXIgaW5kID0gVHlwci5fbGN0Zi5jb3ZlcmFnZUluZGV4KGN2Z3NbaV0sIGdsc1tjaStpXSk7ICBpZihpbmQ9PS0xKSB7IHJldHVybiBmYWxzZTsgfVxuICBcdH1cbiAgXHRyZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBUeXByLlUuZ2x5cGhzVG9QYXRoID0gZnVuY3Rpb24oZm9udCwgZ2xzLCBjbHIpXG4gIHtcdFxuICBcdC8vZ2xzID0gZ2xzLnJldmVyc2UoKTsvL2dscy5zbGljZSgwLDEyKS5jb25jYXQoZ2xzLnNsaWNlKDEyKS5yZXZlcnNlKCkpO1xuICBcdFxuICBcdHZhciB0cGF0aCA9IHtjbWRzOltdLCBjcmRzOltdfTtcbiAgXHR2YXIgeCA9IDA7XG4gIFx0XG4gIFx0Zm9yKHZhciBpPTA7IGk8Z2xzLmxlbmd0aDsgaSsrKVxuICBcdHtcbiAgXHRcdHZhciBnaWQgPSBnbHNbaV07ICBpZihnaWQ9PS0xKSB7IGNvbnRpbnVlOyB9XG4gIFx0XHR2YXIgZ2lkMiA9IChpPGdscy5sZW5ndGgtMSAmJiBnbHNbaSsxXSE9LTEpICA/IGdsc1tpKzFdIDogMDtcbiAgXHRcdHZhciBwYXRoID0gVHlwci5VLmdseXBoVG9QYXRoKGZvbnQsIGdpZCk7XG4gIFx0XHRmb3IodmFyIGo9MDsgajxwYXRoLmNyZHMubGVuZ3RoOyBqKz0yKVxuICBcdFx0e1xuICBcdFx0XHR0cGF0aC5jcmRzLnB1c2gocGF0aC5jcmRzW2pdICsgeCk7XG4gIFx0XHRcdHRwYXRoLmNyZHMucHVzaChwYXRoLmNyZHNbaisxXSk7XG4gIFx0XHR9XG4gIFx0XHRpZihjbHIpIHsgdHBhdGguY21kcy5wdXNoKGNscik7IH1cbiAgXHRcdGZvcih2YXIgaj0wOyBqPHBhdGguY21kcy5sZW5ndGg7IGorKykgeyB0cGF0aC5jbWRzLnB1c2gocGF0aC5jbWRzW2pdKTsgfVxuICBcdFx0aWYoY2xyKSB7IHRwYXRoLmNtZHMucHVzaChcIlhcIik7IH1cbiAgXHRcdHggKz0gZm9udC5obXR4LmFXaWR0aFtnaWRdOy8vIC0gZm9udC5obXR4LmxzQmVhcmluZ1tnaWRdO1xuICBcdFx0aWYoaTxnbHMubGVuZ3RoLTEpIHsgeCArPSBUeXByLlUuZ2V0UGFpckFkanVzdG1lbnQoZm9udCwgZ2lkLCBnaWQyKTsgfVxuICBcdH1cbiAgXHRyZXR1cm4gdHBhdGg7XG4gIH07XG5cbiAgVHlwci5VLnBhdGhUb1NWRyA9IGZ1bmN0aW9uKHBhdGgsIHByZWMpXG4gIHtcbiAgXHRpZihwcmVjPT1udWxsKSB7IHByZWMgPSA1OyB9XG4gIFx0dmFyIG91dCA9IFtdLCBjbyA9IDAsIGxtYXAgPSB7XCJNXCI6MixcIkxcIjoyLFwiUVwiOjQsXCJDXCI6Nn07XG4gIFx0Zm9yKHZhciBpPTA7IGk8cGF0aC5jbWRzLmxlbmd0aDsgaSsrKVxuICBcdHtcbiAgXHRcdHZhciBjbWQgPSBwYXRoLmNtZHNbaV0sIGNuID0gY28rKGxtYXBbY21kXT9sbWFwW2NtZF06MCk7ICBcbiAgXHRcdG91dC5wdXNoKGNtZCk7XG4gIFx0XHR3aGlsZShjbzxjbikgeyAgdmFyIGMgPSBwYXRoLmNyZHNbY28rK107ICBvdXQucHVzaChwYXJzZUZsb2F0KGMudG9GaXhlZChwcmVjKSkrKGNvPT1jbj9cIlwiOlwiIFwiKSk7ICB9XG4gIFx0fVxuICBcdHJldHVybiBvdXQuam9pbihcIlwiKTtcbiAgfTtcblxuICBUeXByLlUucGF0aFRvQ29udGV4dCA9IGZ1bmN0aW9uKHBhdGgsIGN0eClcbiAge1xuICBcdHZhciBjID0gMCwgY3JkcyA9IHBhdGguY3JkcztcbiAgXHRcbiAgXHRmb3IodmFyIGo9MDsgajxwYXRoLmNtZHMubGVuZ3RoOyBqKyspXG4gIFx0e1xuICBcdFx0dmFyIGNtZCA9IHBhdGguY21kc1tqXTtcbiAgXHRcdGlmICAgICAoY21kPT1cIk1cIikge1xuICBcdFx0XHRjdHgubW92ZVRvKGNyZHNbY10sIGNyZHNbYysxXSk7XG4gIFx0XHRcdGMrPTI7XG4gIFx0XHR9XG4gIFx0XHRlbHNlIGlmKGNtZD09XCJMXCIpIHtcbiAgXHRcdFx0Y3R4LmxpbmVUbyhjcmRzW2NdLCBjcmRzW2MrMV0pO1xuICBcdFx0XHRjKz0yO1xuICBcdFx0fVxuICBcdFx0ZWxzZSBpZihjbWQ9PVwiQ1wiKSB7XG4gIFx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvKGNyZHNbY10sIGNyZHNbYysxXSwgY3Jkc1tjKzJdLCBjcmRzW2MrM10sIGNyZHNbYys0XSwgY3Jkc1tjKzVdKTtcbiAgXHRcdFx0Yys9NjtcbiAgXHRcdH1cbiAgXHRcdGVsc2UgaWYoY21kPT1cIlFcIikge1xuICBcdFx0XHRjdHgucXVhZHJhdGljQ3VydmVUbyhjcmRzW2NdLCBjcmRzW2MrMV0sIGNyZHNbYysyXSwgY3Jkc1tjKzNdKTtcbiAgXHRcdFx0Yys9NDtcbiAgXHRcdH1cbiAgXHRcdGVsc2UgaWYoY21kLmNoYXJBdCgwKT09XCIjXCIpIHtcbiAgXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuICBcdFx0XHRjdHguZmlsbFN0eWxlID0gY21kO1xuICBcdFx0fVxuICBcdFx0ZWxzZSBpZihjbWQ9PVwiWlwiKSB7XG4gIFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcbiAgXHRcdH1cbiAgXHRcdGVsc2UgaWYoY21kPT1cIlhcIikge1xuICBcdFx0XHRjdHguZmlsbCgpO1xuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuXG4gIFR5cHIuVS5QID0ge307XG4gIFR5cHIuVS5QLm1vdmVUbyA9IGZ1bmN0aW9uKHAsIHgsIHkpXG4gIHtcbiAgXHRwLmNtZHMucHVzaChcIk1cIik7ICBwLmNyZHMucHVzaCh4LHkpO1xuICB9O1xuICBUeXByLlUuUC5saW5lVG8gPSBmdW5jdGlvbihwLCB4LCB5KVxuICB7XG4gIFx0cC5jbWRzLnB1c2goXCJMXCIpOyAgcC5jcmRzLnB1c2goeCx5KTtcbiAgfTtcbiAgVHlwci5VLlAuY3VydmVUbyA9IGZ1bmN0aW9uKHAsIGEsYixjLGQsZSxmKVxuICB7XG4gIFx0cC5jbWRzLnB1c2goXCJDXCIpOyAgcC5jcmRzLnB1c2goYSxiLGMsZCxlLGYpO1xuICB9O1xuICBUeXByLlUuUC5xY3VydmVUbyA9IGZ1bmN0aW9uKHAsIGEsYixjLGQpXG4gIHtcbiAgXHRwLmNtZHMucHVzaChcIlFcIik7ICBwLmNyZHMucHVzaChhLGIsYyxkKTtcbiAgfTtcbiAgVHlwci5VLlAuY2xvc2VQYXRoID0gZnVuY3Rpb24ocCkgeyAgcC5jbWRzLnB1c2goXCJaXCIpOyAgfTtcblxuXG5cblxuICBUeXByLlUuX2RyYXdDRkYgPSBmdW5jdGlvbihjbWRzLCBzdGF0ZSwgZm9udCwgcGRjdCwgcClcbiAge1xuICBcdHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICBcdHZhciBuU3RlbXMgPSBzdGF0ZS5uU3RlbXMsIGhhdmVXaWR0aD1zdGF0ZS5oYXZlV2lkdGgsIHdpZHRoPXN0YXRlLndpZHRoLCBvcGVuPXN0YXRlLm9wZW47XG4gIFx0dmFyIGk9MDtcbiAgXHR2YXIgeD1zdGF0ZS54LCB5PXN0YXRlLnksIGMxeD0wLCBjMXk9MCwgYzJ4PTAsIGMyeT0wLCBjM3g9MCwgYzN5PTAsIGM0eD0wLCBjNHk9MCwganB4PTAsIGpweT0wO1xuICBcdFxuICBcdHZhciBvID0ge3ZhbDowLHNpemU6MH07XG4gIFx0Ly9jb25zb2xlLmxvZyhjbWRzKTtcbiAgXHR3aGlsZShpPGNtZHMubGVuZ3RoKVxuICBcdHtcbiAgXHRcdFR5cHIuQ0ZGLmdldENoYXJTdHJpbmcoY21kcywgaSwgbyk7XG4gIFx0XHR2YXIgdiA9IG8udmFsO1xuICBcdFx0aSArPSBvLnNpemU7XG4gIFx0XHRcdFxuICBcdFx0aWYodj09XCJvMVwiIHx8IHY9PVwibzE4XCIpICAvLyAgaHN0ZW0gfHwgaHN0ZW1obVxuICBcdFx0e1xuICBcdFx0XHR2YXIgaGFzV2lkdGhBcmc7XG5cbiAgXHRcdFx0Ly8gVGhlIG51bWJlciBvZiBzdGVtIG9wZXJhdG9ycyBvbiB0aGUgc3RhY2sgaXMgYWx3YXlzIGV2ZW4uXG4gIFx0XHRcdC8vIElmIHRoZSB2YWx1ZSBpcyB1bmV2ZW4sIHRoYXQgbWVhbnMgYSB3aWR0aCBpcyBzcGVjaWZpZWQuXG4gIFx0XHRcdGhhc1dpZHRoQXJnID0gc3RhY2subGVuZ3RoICUgMiAhPT0gMDtcbiAgXHRcdFx0aWYgKGhhc1dpZHRoQXJnICYmICFoYXZlV2lkdGgpIHtcbiAgXHRcdFx0XHR3aWR0aCA9IHN0YWNrLnNoaWZ0KCkgKyBwZGN0Lm5vbWluYWxXaWR0aFg7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRuU3RlbXMgKz0gc3RhY2subGVuZ3RoID4+IDE7XG4gIFx0XHRcdHN0YWNrLmxlbmd0aCA9IDA7XG4gIFx0XHRcdGhhdmVXaWR0aCA9IHRydWU7XG4gIFx0XHR9XG4gIFx0XHRlbHNlIGlmKHY9PVwibzNcIiB8fCB2PT1cIm8yM1wiKSAgLy8gdnN0ZW0gfHwgdnN0ZW1obVxuICBcdFx0e1xuICBcdFx0XHR2YXIgaGFzV2lkdGhBcmc7XG5cbiAgXHRcdFx0Ly8gVGhlIG51bWJlciBvZiBzdGVtIG9wZXJhdG9ycyBvbiB0aGUgc3RhY2sgaXMgYWx3YXlzIGV2ZW4uXG4gIFx0XHRcdC8vIElmIHRoZSB2YWx1ZSBpcyB1bmV2ZW4sIHRoYXQgbWVhbnMgYSB3aWR0aCBpcyBzcGVjaWZpZWQuXG4gIFx0XHRcdGhhc1dpZHRoQXJnID0gc3RhY2subGVuZ3RoICUgMiAhPT0gMDtcbiAgXHRcdFx0aWYgKGhhc1dpZHRoQXJnICYmICFoYXZlV2lkdGgpIHtcbiAgXHRcdFx0XHR3aWR0aCA9IHN0YWNrLnNoaWZ0KCkgKyBwZGN0Lm5vbWluYWxXaWR0aFg7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRuU3RlbXMgKz0gc3RhY2subGVuZ3RoID4+IDE7XG4gIFx0XHRcdHN0YWNrLmxlbmd0aCA9IDA7XG4gIFx0XHRcdGhhdmVXaWR0aCA9IHRydWU7XG4gIFx0XHR9XG4gIFx0XHRlbHNlIGlmKHY9PVwibzRcIilcbiAgXHRcdHtcbiAgXHRcdFx0aWYgKHN0YWNrLmxlbmd0aCA+IDEgJiYgIWhhdmVXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHN0YWNrLnNoaWZ0KCkgKyBwZGN0Lm5vbWluYWxXaWR0aFg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGhhdmVXaWR0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICBcdFx0XHRpZihvcGVuKSB7IFR5cHIuVS5QLmNsb3NlUGF0aChwKTsgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5wb3AoKTtcbiAgXHRcdFx0XHRcdFR5cHIuVS5QLm1vdmVUbyhwLHgseSk7ICAgb3Blbj10cnVlO1xuICBcdFx0fVxuICBcdFx0ZWxzZSBpZih2PT1cIm81XCIpXG4gIFx0XHR7XG4gIFx0XHRcdHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBUeXByLlUuUC5saW5lVG8ocCwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICBcdFx0fVxuICBcdFx0ZWxzZSBpZih2PT1cIm82XCIgfHwgdj09XCJvN1wiKSAgLy8gaGxpbmV0byB8fCB2bGluZXRvXG4gIFx0XHR7XG4gIFx0XHRcdHZhciBjb3VudCA9IHN0YWNrLmxlbmd0aDtcbiAgXHRcdFx0dmFyIGlzWCA9ICh2ID09IFwibzZcIik7XG4gIFx0XHRcdFxuICBcdFx0XHRmb3IodmFyIGo9MDsgajxjb3VudDsgaisrKSB7XG4gIFx0XHRcdFx0dmFyIHN2YWwgPSBzdGFjay5zaGlmdCgpO1xuICBcdFx0XHRcdFxuICBcdFx0XHRcdGlmKGlzWCkgeyB4ICs9IHN2YWw7IH0gIGVsc2UgIHsgeSArPSBzdmFsOyB9XG4gIFx0XHRcdFx0aXNYID0gIWlzWDtcbiAgXHRcdFx0XHRUeXByLlUuUC5saW5lVG8ocCwgeCwgeSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHRcdGVsc2UgaWYodj09XCJvOFwiIHx8IHY9PVwibzI0XCIpXHQvLyBycmN1cnZldG8gfHwgcmN1cnZlbGluZVxuICBcdFx0e1xuICBcdFx0XHR2YXIgY291bnQgPSBzdGFjay5sZW5ndGg7XG4gIFx0XHRcdHZhciBpbmRleCA9IDA7XG4gIFx0XHRcdHdoaWxlKGluZGV4KzYgPD0gY291bnQpIHtcbiAgXHRcdFx0XHRjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcbiAgXHRcdFx0XHRjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTtcbiAgXHRcdFx0XHRjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICBcdFx0XHRcdGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gIFx0XHRcdFx0eCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7XG4gIFx0XHRcdFx0eSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG4gIFx0XHRcdFx0VHlwci5VLlAuY3VydmVUbyhwLCBjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICBcdFx0XHRcdGluZGV4Kz02O1xuICBcdFx0XHR9XG4gIFx0XHRcdGlmKHY9PVwibzI0XCIpXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHR4ICs9IHN0YWNrLnNoaWZ0KCk7XG4gIFx0XHRcdFx0eSArPSBzdGFjay5zaGlmdCgpO1xuICBcdFx0XHRcdFR5cHIuVS5QLmxpbmVUbyhwLCB4LCB5KTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdFx0ZWxzZSBpZih2PT1cIm8xMVwiKSAgeyBicmVhazsgfVxuICBcdFx0ZWxzZSBpZih2PT1cIm8xMjM0XCIgfHwgdj09XCJvMTIzNVwiIHx8IHY9PVwibzEyMzZcIiB8fCB2PT1cIm8xMjM3XCIpLy9pZigoditcIlwiKS5zbGljZSgwLDMpPT1cIm8xMlwiKVxuICBcdFx0e1xuICBcdFx0XHRpZih2PT1cIm8xMjM0XCIpXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRjMXggPSB4ICAgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDFcbiAgICAgICAgICAgICAgICAgIGMxeSA9IHk7ICAgICAgICAgICAgICAgICAgICAgIC8vIGR5MVxuICBcdFx0XHRcdGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4MlxuICBcdFx0XHRcdGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5MlxuICBcdFx0XHRcdGpweCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4M1xuICBcdFx0XHRcdGpweSA9IGMyeTsgICAgICAgICAgICAgICAgICAgIC8vIGR5M1xuICBcdFx0XHRcdGMzeCA9IGpweCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4NFxuICBcdFx0XHRcdGMzeSA9IGMyeTsgICAgICAgICAgICAgICAgICAgIC8vIGR5NFxuICBcdFx0XHRcdGM0eCA9IGMzeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4NVxuICBcdFx0XHRcdGM0eSA9IHk7ICAgICAgICAgICAgICAgICAgICAgIC8vIGR5NVxuICBcdFx0XHRcdHggPSBjNHggKyBzdGFjay5zaGlmdCgpOyAgICAgIC8vIGR4NlxuICBcdFx0XHRcdFR5cHIuVS5QLmN1cnZlVG8ocCwgYzF4LCBjMXksIGMyeCwgYzJ5LCBqcHgsIGpweSk7XG4gIFx0XHRcdFx0VHlwci5VLlAuY3VydmVUbyhwLCBjM3gsIGMzeSwgYzR4LCBjNHksIHgsIHkpO1xuICBcdFx0XHRcdFxuICBcdFx0XHR9XG4gIFx0XHRcdGlmKHY9PVwibzEyMzVcIilcbiAgXHRcdFx0e1xuICBcdFx0XHRcdGMxeCA9IHggICArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4MVxuICBcdFx0XHRcdGMxeSA9IHkgICArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5MVxuICBcdFx0XHRcdGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4MlxuICBcdFx0XHRcdGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5MlxuICBcdFx0XHRcdGpweCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4M1xuICBcdFx0XHRcdGpweSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5M1xuICBcdFx0XHRcdGMzeCA9IGpweCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4NFxuICBcdFx0XHRcdGMzeSA9IGpweSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5NFxuICBcdFx0XHRcdGM0eCA9IGMzeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4NVxuICBcdFx0XHRcdGM0eSA9IGMzeSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5NVxuICBcdFx0XHRcdHggPSBjNHggKyBzdGFjay5zaGlmdCgpOyAgICAgIC8vIGR4NlxuICBcdFx0XHRcdHkgPSBjNHkgKyBzdGFjay5zaGlmdCgpOyAgICAgIC8vIGR5NlxuICBcdFx0XHRcdHN0YWNrLnNoaWZ0KCk7ICAgICAgICAgICAgICAgIC8vIGZsZXggZGVwdGhcbiAgXHRcdFx0XHRUeXByLlUuUC5jdXJ2ZVRvKHAsIGMxeCwgYzF5LCBjMngsIGMyeSwganB4LCBqcHkpO1xuICBcdFx0XHRcdFR5cHIuVS5QLmN1cnZlVG8ocCwgYzN4LCBjM3ksIGM0eCwgYzR5LCB4LCB5KTtcbiAgXHRcdFx0fVxuICBcdFx0XHRpZih2PT1cIm8xMjM2XCIpXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRjMXggPSB4ICAgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDFcbiAgXHRcdFx0XHRjMXkgPSB5ICAgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTFcbiAgXHRcdFx0XHRjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDJcbiAgXHRcdFx0XHRjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTJcbiAgXHRcdFx0XHRqcHggPSBjMnggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDNcbiAgXHRcdFx0XHRqcHkgPSBjMnk7ICAgICAgICAgICAgICAgICAgICAvLyBkeTNcbiAgXHRcdFx0XHRjM3ggPSBqcHggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDRcbiAgXHRcdFx0XHRjM3kgPSBjMnk7ICAgICAgICAgICAgICAgICAgICAvLyBkeTRcbiAgXHRcdFx0XHRjNHggPSBjM3ggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDVcbiAgXHRcdFx0XHRjNHkgPSBjM3kgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTVcbiAgXHRcdFx0XHR4ID0gYzR4ICsgc3RhY2suc2hpZnQoKTsgICAgICAvLyBkeDZcbiAgXHRcdFx0XHRUeXByLlUuUC5jdXJ2ZVRvKHAsIGMxeCwgYzF5LCBjMngsIGMyeSwganB4LCBqcHkpO1xuICBcdFx0XHRcdFR5cHIuVS5QLmN1cnZlVG8ocCwgYzN4LCBjM3ksIGM0eCwgYzR5LCB4LCB5KTtcbiAgXHRcdFx0fVxuICBcdFx0XHRpZih2PT1cIm8xMjM3XCIpXG4gIFx0XHRcdHtcbiAgXHRcdFx0XHRjMXggPSB4ICAgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDFcbiAgXHRcdFx0XHRjMXkgPSB5ICAgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTFcbiAgXHRcdFx0XHRjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDJcbiAgXHRcdFx0XHRjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTJcbiAgXHRcdFx0XHRqcHggPSBjMnggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDNcbiAgXHRcdFx0XHRqcHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTNcbiAgXHRcdFx0XHRjM3ggPSBqcHggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDRcbiAgXHRcdFx0XHRjM3kgPSBqcHkgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTRcbiAgXHRcdFx0XHRjNHggPSBjM3ggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDVcbiAgXHRcdFx0XHRjNHkgPSBjM3kgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTVcbiAgXHRcdFx0XHRpZiAoTWF0aC5hYnMoYzR4IC0geCkgPiBNYXRoLmFicyhjNHkgLSB5KSkge1xuICBcdFx0XHRcdCAgICB4ID0gYzR4ICsgc3RhY2suc2hpZnQoKTtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdCAgICB5ID0gYzR5ICsgc3RhY2suc2hpZnQoKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdFx0VHlwci5VLlAuY3VydmVUbyhwLCBjMXgsIGMxeSwgYzJ4LCBjMnksIGpweCwganB5KTtcbiAgXHRcdFx0XHRUeXByLlUuUC5jdXJ2ZVRvKHAsIGMzeCwgYzN5LCBjNHgsIGM0eSwgeCwgeSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHRcdGVsc2UgaWYodj09XCJvMTRcIilcbiAgXHRcdHtcbiAgXHRcdFx0aWYgKHN0YWNrLmxlbmd0aCA+IDAgJiYgIWhhdmVXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHN0YWNrLnNoaWZ0KCkgKyBmb250Lm5vbWluYWxXaWR0aFg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGhhdmVXaWR0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICBcdFx0XHRpZihzdGFjay5sZW5ndGg9PTQpIC8vIHNlYWMgPSBzdGFuZGFyZCBlbmNvZGluZyBhY2NlbnRlZCBjaGFyYWN0ZXJcbiAgXHRcdFx0e1xuICBcdFx0XHRcdHZhciBhZHggPSBzdGFjay5zaGlmdCgpO1xuICBcdFx0XHRcdHZhciBhZHkgPSBzdGFjay5zaGlmdCgpO1xuICBcdFx0XHRcdHZhciBiY2hhciA9IHN0YWNrLnNoaWZ0KCk7XG4gIFx0XHRcdFx0dmFyIGFjaGFyID0gc3RhY2suc2hpZnQoKTtcbiAgXHRcdFx0XG4gIFx0XHRcdFx0XG4gIFx0XHRcdFx0dmFyIGJpbmQgPSBUeXByLkNGRi5nbHlwaEJ5U0UoZm9udCwgYmNoYXIpO1xuICBcdFx0XHRcdHZhciBhaW5kID0gVHlwci5DRkYuZ2x5cGhCeVNFKGZvbnQsIGFjaGFyKTtcbiAgXHRcdFx0XHRcbiAgXHRcdFx0XHQvL2NvbnNvbGUubG9nKGJjaGFyLCBiaW5kKTtcbiAgXHRcdFx0XHQvL2NvbnNvbGUubG9nKGFjaGFyLCBhaW5kKTtcbiAgXHRcdFx0XHQvL3N0YXRlLng9eDsgc3RhdGUueT15OyBzdGF0ZS5uU3RlbXM9blN0ZW1zOyBzdGF0ZS5oYXZlV2lkdGg9aGF2ZVdpZHRoOyBzdGF0ZS53aWR0aD13aWR0aDsgIHN0YXRlLm9wZW49b3BlbjtcbiAgXHRcdFx0XHRcbiAgXHRcdFx0XHRUeXByLlUuX2RyYXdDRkYoZm9udC5DaGFyU3RyaW5nc1tiaW5kXSwgc3RhdGUsZm9udCxwZGN0LHApO1xuICBcdFx0XHRcdHN0YXRlLnggPSBhZHg7IHN0YXRlLnkgPSBhZHk7XG4gIFx0XHRcdFx0VHlwci5VLl9kcmF3Q0ZGKGZvbnQuQ2hhclN0cmluZ3NbYWluZF0sIHN0YXRlLGZvbnQscGRjdCxwKTtcbiAgXHRcdFx0XHRcbiAgXHRcdFx0XHQvL3g9c3RhdGUueDsgeT1zdGF0ZS55OyBuU3RlbXM9c3RhdGUublN0ZW1zOyBoYXZlV2lkdGg9c3RhdGUuaGF2ZVdpZHRoOyB3aWR0aD1zdGF0ZS53aWR0aDsgIG9wZW49c3RhdGUub3BlbjtcbiAgXHRcdFx0fVxuICBcdFx0XHRpZihvcGVuKSB7ICBUeXByLlUuUC5jbG9zZVBhdGgocCk7ICBvcGVuPWZhbHNlOyAgfVxuICBcdFx0fVx0XHRcbiAgXHRcdGVsc2UgaWYodj09XCJvMTlcIiB8fCB2PT1cIm8yMFwiKSBcbiAgXHRcdHsgXG4gIFx0XHRcdHZhciBoYXNXaWR0aEFyZztcblxuICBcdFx0XHQvLyBUaGUgbnVtYmVyIG9mIHN0ZW0gb3BlcmF0b3JzIG9uIHRoZSBzdGFjayBpcyBhbHdheXMgZXZlbi5cbiAgXHRcdFx0Ly8gSWYgdGhlIHZhbHVlIGlzIHVuZXZlbiwgdGhhdCBtZWFucyBhIHdpZHRoIGlzIHNwZWNpZmllZC5cbiAgXHRcdFx0aGFzV2lkdGhBcmcgPSBzdGFjay5sZW5ndGggJSAyICE9PSAwO1xuICBcdFx0XHRpZiAoaGFzV2lkdGhBcmcgJiYgIWhhdmVXaWR0aCkge1xuICBcdFx0XHRcdHdpZHRoID0gc3RhY2suc2hpZnQoKSArIHBkY3Qubm9taW5hbFdpZHRoWDtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdG5TdGVtcyArPSBzdGFjay5sZW5ndGggPj4gMTtcbiAgXHRcdFx0c3RhY2subGVuZ3RoID0gMDtcbiAgXHRcdFx0aGF2ZVdpZHRoID0gdHJ1ZTtcbiAgXHRcdFx0XG4gIFx0XHRcdGkgKz0gKG5TdGVtcyArIDcpID4+IDM7XG4gIFx0XHR9XG4gIFx0XHRcbiAgXHRcdGVsc2UgaWYodj09XCJvMjFcIikge1xuICBcdFx0XHRpZiAoc3RhY2subGVuZ3RoID4gMiAmJiAhaGF2ZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gc3RhY2suc2hpZnQoKSArIHBkY3Qubm9taW5hbFdpZHRoWDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaGF2ZVdpZHRoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2sucG9wKCk7XG4gIFx0XHRcdFx0XHRcbiAgXHRcdFx0XHRcdGlmKG9wZW4pIHsgVHlwci5VLlAuY2xvc2VQYXRoKHApOyB9XG4gICAgICAgICAgICAgICAgICAgICAgVHlwci5VLlAubW92ZVRvKHAseCx5KTsgICBvcGVuPXRydWU7XG4gIFx0XHR9XG4gIFx0XHRlbHNlIGlmKHY9PVwibzIyXCIpXG4gIFx0XHR7XG4gIFx0XHRcdCBpZiAoc3RhY2subGVuZ3RoID4gMSAmJiAhaGF2ZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gc3RhY2suc2hpZnQoKSArIHBkY3Qubm9taW5hbFdpZHRoWDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaGF2ZVdpZHRoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gIFx0XHRcdFx0XHRcbiAgICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnBvcCgpO1xuICBcdFx0XHRcdFx0XG4gIFx0XHRcdFx0XHRpZihvcGVuKSB7IFR5cHIuVS5QLmNsb3NlUGF0aChwKTsgfVxuICBcdFx0XHRcdFx0VHlwci5VLlAubW92ZVRvKHAseCx5KTsgICBvcGVuPXRydWU7ICAgICAgICAgICAgICAgICAgICBcbiAgXHRcdH1cbiAgXHRcdGVsc2UgaWYodj09XCJvMjVcIilcbiAgXHRcdHtcbiAgXHRcdFx0d2hpbGUgKHN0YWNrLmxlbmd0aCA+IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIFR5cHIuVS5QLmxpbmVUbyhwLCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgVHlwci5VLlAuY3VydmVUbyhwLCBjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICBcdFx0fVxuICBcdFx0ZWxzZSBpZih2PT1cIm8yNlwiKSBcbiAgXHRcdHtcbiAgXHRcdFx0aWYgKHN0YWNrLmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgVHlwci5VLlAuY3VydmVUbyhwLCBjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICBcdFx0fVxuICBcdFx0ZWxzZSBpZih2PT1cIm8yN1wiKVxuICBcdFx0e1xuICBcdFx0XHRpZiAoc3RhY2subGVuZ3RoICUgMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBUeXByLlUuUC5jdXJ2ZVRvKHAsIGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICBcdFx0fVxuICBcdFx0ZWxzZSBpZih2PT1cIm8xMFwiIHx8IHY9PVwibzI5XCIpXHQvLyBjYWxsc3ViciB8fCBjYWxsZ3N1YnJcbiAgXHRcdHtcbiAgXHRcdFx0dmFyIG9iaiA9ICh2PT1cIm8xMFwiID8gcGRjdCA6IGZvbnQpO1xuICBcdFx0XHRpZihzdGFjay5sZW5ndGg9PTApIHsgY29uc29sZS5sb2coXCJlcnJvcjogZW1wdHkgc3RhY2tcIik7ICB9XG4gIFx0XHRcdGVsc2Uge1xuICBcdFx0XHRcdHZhciBpbmQgPSBzdGFjay5wb3AoKTtcbiAgXHRcdFx0XHR2YXIgc3ViciA9IG9iai5TdWJyc1sgaW5kICsgb2JqLkJpYXMgXTtcbiAgXHRcdFx0XHRzdGF0ZS54PXg7IHN0YXRlLnk9eTsgc3RhdGUublN0ZW1zPW5TdGVtczsgc3RhdGUuaGF2ZVdpZHRoPWhhdmVXaWR0aDsgc3RhdGUud2lkdGg9d2lkdGg7ICBzdGF0ZS5vcGVuPW9wZW47XG4gIFx0XHRcdFx0VHlwci5VLl9kcmF3Q0ZGKHN1YnIsIHN0YXRlLGZvbnQscGRjdCxwKTtcbiAgXHRcdFx0XHR4PXN0YXRlLng7IHk9c3RhdGUueTsgblN0ZW1zPXN0YXRlLm5TdGVtczsgaGF2ZVdpZHRoPXN0YXRlLmhhdmVXaWR0aDsgd2lkdGg9c3RhdGUud2lkdGg7ICBvcGVuPXN0YXRlLm9wZW47XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHRcdGVsc2UgaWYodj09XCJvMzBcIiB8fCB2PT1cIm8zMVwiKSAgIC8vIHZoY3VydmV0byB8fCBodmN1cnZldG9cbiAgXHRcdHtcbiAgXHRcdFx0dmFyIGNvdW50LCBjb3VudDEgPSBzdGFjay5sZW5ndGg7XG4gIFx0XHRcdHZhciBpbmRleCA9IDA7XG4gIFx0XHRcdHZhciBhbHRlcm5hdGUgPSB2ID09IFwibzMxXCI7XG4gIFx0XHRcdFxuICBcdFx0XHRjb3VudCAgPSBjb3VudDEgJiB+MjtcbiAgXHRcdFx0aW5kZXggKz0gY291bnQxIC0gY291bnQ7XG4gIFx0XHRcdFxuICBcdFx0XHR3aGlsZSAoIGluZGV4IDwgY291bnQgKSBcbiAgXHRcdFx0e1xuICBcdFx0XHRcdGlmKGFsdGVybmF0ZSlcbiAgXHRcdFx0XHR7XG4gIFx0XHRcdFx0XHRjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcbiAgXHRcdFx0XHRcdGMxeSA9IHk7XG4gIFx0XHRcdFx0XHRjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICBcdFx0XHRcdFx0YzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgXHRcdFx0XHRcdHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpO1xuICBcdFx0XHRcdFx0aWYoY291bnQtaW5kZXggPT0gNSkgeyAgeCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7ICBpbmRleCsrOyAgfVxuICBcdFx0XHRcdFx0ZWxzZSB7IHggPSBjMng7IH1cbiAgXHRcdFx0XHRcdGFsdGVybmF0ZSA9IGZhbHNlO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0XHRlbHNlXG4gIFx0XHRcdFx0e1xuICBcdFx0XHRcdFx0YzF4ID0geDtcbiAgXHRcdFx0XHRcdGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpO1xuICBcdFx0XHRcdFx0YzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgXHRcdFx0XHRcdGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gIFx0XHRcdFx0XHR4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcbiAgXHRcdFx0XHRcdGlmKGNvdW50LWluZGV4ID09IDUpIHsgIHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpOyAgaW5kZXgrKzsgIH1cbiAgXHRcdFx0XHRcdGVsc2UgeyB5ID0gYzJ5OyB9XG4gIFx0XHRcdFx0XHRhbHRlcm5hdGUgPSB0cnVlO1xuICBcdFx0XHRcdH1cbiAgICAgICAgICAgICAgICAgIFR5cHIuVS5QLmN1cnZlVG8ocCwgYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgXHRcdFx0XHRpbmRleCArPSA0O1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0XHRcbiAgXHRcdGVsc2UgaWYoKHYrXCJcIikuY2hhckF0KDApPT1cIm9cIikgeyAgIGNvbnNvbGUubG9nKFwiVW5rbm93biBvcGVyYXRpb246IFwiK3YsIGNtZHMpOyB0aHJvdyB2OyAgfVxuICBcdFx0ZWxzZSB7IHN0YWNrLnB1c2godik7IH1cbiAgXHR9XG4gIFx0Ly9jb25zb2xlLmxvZyhjbWRzKTtcbiAgXHRzdGF0ZS54PXg7IHN0YXRlLnk9eTsgc3RhdGUublN0ZW1zPW5TdGVtczsgc3RhdGUuaGF2ZVdpZHRoPWhhdmVXaWR0aDsgc3RhdGUud2lkdGg9d2lkdGg7IHN0YXRlLm9wZW49b3BlbjtcbiAgfTtcblxuICAvLyBFbmQgVHlwci5VLmpzXG5cbiAgcmV0dXJuIFR5cHJcblxuICB9XG5cbiAgLy8gQ3VzdG9tIGJ1bmRsZSBvZiB3b2ZmMm90ZiAoaHR0cHM6Ly9naXRodWIuY29tL2FydHktbmFtZS93b2ZmMm90Zikgd2l0aCB0aW55LWluZmxhdGUgXG4gIC8vIChodHRwczovL2dpdGh1Yi5jb20vZm9saW9qcy90aW55LWluZmxhdGUpIGZvciB1c2UgaW4gdHJvaWthLTNkLXRleHQuIFxuICAvLyBPcmlnaW5hbCBsaWNlbnNlcyBhcHBseTogXG4gIC8vIC0gdGlueS1pbmZsYXRlOiBodHRwczovL2dpdGh1Yi5jb20vZm9saW9qcy90aW55LWluZmxhdGUvYmxvYi9tYXN0ZXIvTElDRU5TRSAoTUlUKVxuICAvLyAtIHdvZmYyb3RmLmpzOiBodHRwczovL2dpdGh1Yi5jb20vYXJ0eS1uYW1lL3dvZmYyb3RmL2Jsb2IvbWFzdGVyL3dvZmYyb3RmLmpzIChBcGFjaGUyKVxuXG4gIGZ1bmN0aW9uIHdvZmYyb3RmRmFjdG9yeSgpIHtcblxuICAvLyBCZWdpbiB0aW55SW5mbGF0ZVxuICB2YXIgdGlueUluZmxhdGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1vZHVsZSA9IHt9O1xuICAgIHZhciBUSU5GX09LID0gMDtcbiAgdmFyIFRJTkZfREFUQV9FUlJPUiA9IC0zO1xuXG4gIGZ1bmN0aW9uIFRyZWUoKSB7XG4gICAgdGhpcy50YWJsZSA9IG5ldyBVaW50MTZBcnJheSgxNik7ICAgLyogdGFibGUgb2YgY29kZSBsZW5ndGggY291bnRzICovXG4gICAgdGhpcy50cmFucyA9IG5ldyBVaW50MTZBcnJheSgyODgpOyAgLyogY29kZSAtPiBzeW1ib2wgdHJhbnNsYXRpb24gdGFibGUgKi9cbiAgfVxuXG4gIGZ1bmN0aW9uIERhdGEoc291cmNlLCBkZXN0KSB7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5zb3VyY2VJbmRleCA9IDA7XG4gICAgdGhpcy50YWcgPSAwO1xuICAgIHRoaXMuYml0Y291bnQgPSAwO1xuICAgIFxuICAgIHRoaXMuZGVzdCA9IGRlc3Q7XG4gICAgdGhpcy5kZXN0TGVuID0gMDtcbiAgICBcbiAgICB0aGlzLmx0cmVlID0gbmV3IFRyZWUoKTsgIC8qIGR5bmFtaWMgbGVuZ3RoL3N5bWJvbCB0cmVlICovXG4gICAgdGhpcy5kdHJlZSA9IG5ldyBUcmVlKCk7ICAvKiBkeW5hbWljIGRpc3RhbmNlIHRyZWUgKi9cbiAgfVxuXG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG4gICAqIC0tIHVuaW5pdGlhbGl6ZWQgZ2xvYmFsIGRhdGEgKHN0YXRpYyBzdHJ1Y3R1cmVzKSAtLSAqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gIHZhciBzbHRyZWUgPSBuZXcgVHJlZSgpO1xuICB2YXIgc2R0cmVlID0gbmV3IFRyZWUoKTtcblxuICAvKiBleHRyYSBiaXRzIGFuZCBiYXNlIHRhYmxlcyBmb3IgbGVuZ3RoIGNvZGVzICovXG4gIHZhciBsZW5ndGhfYml0cyA9IG5ldyBVaW50OEFycmF5KDMwKTtcbiAgdmFyIGxlbmd0aF9iYXNlID0gbmV3IFVpbnQxNkFycmF5KDMwKTtcblxuICAvKiBleHRyYSBiaXRzIGFuZCBiYXNlIHRhYmxlcyBmb3IgZGlzdGFuY2UgY29kZXMgKi9cbiAgdmFyIGRpc3RfYml0cyA9IG5ldyBVaW50OEFycmF5KDMwKTtcbiAgdmFyIGRpc3RfYmFzZSA9IG5ldyBVaW50MTZBcnJheSgzMCk7XG5cbiAgLyogc3BlY2lhbCBvcmRlcmluZyBvZiBjb2RlIGxlbmd0aCBjb2RlcyAqL1xuICB2YXIgY2xjaWR4ID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgIDE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsXG4gICAgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsXG4gICAgMTQsIDEsIDE1XG4gIF0pO1xuXG4gIC8qIHVzZWQgYnkgdGluZl9kZWNvZGVfdHJlZXMsIGF2b2lkcyBhbGxvY2F0aW9ucyBldmVyeSBjYWxsICovXG4gIHZhciBjb2RlX3RyZWUgPSBuZXcgVHJlZSgpO1xuICB2YXIgbGVuZ3RocyA9IG5ldyBVaW50OEFycmF5KDI4OCArIDMyKTtcblxuICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG4gICAqIC0tIHV0aWxpdHkgZnVuY3Rpb25zIC0tICpcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAvKiBidWlsZCBleHRyYSBiaXRzIGFuZCBiYXNlIHRhYmxlcyAqL1xuICBmdW5jdGlvbiB0aW5mX2J1aWxkX2JpdHNfYmFzZShiaXRzLCBiYXNlLCBkZWx0YSwgZmlyc3QpIHtcbiAgICB2YXIgaSwgc3VtO1xuXG4gICAgLyogYnVpbGQgYml0cyB0YWJsZSAqL1xuICAgIGZvciAoaSA9IDA7IGkgPCBkZWx0YTsgKytpKSB7IGJpdHNbaV0gPSAwOyB9XG4gICAgZm9yIChpID0gMDsgaSA8IDMwIC0gZGVsdGE7ICsraSkgeyBiaXRzW2kgKyBkZWx0YV0gPSBpIC8gZGVsdGEgfCAwOyB9XG5cbiAgICAvKiBidWlsZCBiYXNlIHRhYmxlICovXG4gICAgZm9yIChzdW0gPSBmaXJzdCwgaSA9IDA7IGkgPCAzMDsgKytpKSB7XG4gICAgICBiYXNlW2ldID0gc3VtO1xuICAgICAgc3VtICs9IDEgPDwgYml0c1tpXTtcbiAgICB9XG4gIH1cblxuICAvKiBidWlsZCB0aGUgZml4ZWQgaHVmZm1hbiB0cmVlcyAqL1xuICBmdW5jdGlvbiB0aW5mX2J1aWxkX2ZpeGVkX3RyZWVzKGx0LCBkdCkge1xuICAgIHZhciBpO1xuXG4gICAgLyogYnVpbGQgZml4ZWQgbGVuZ3RoIHRyZWUgKi9cbiAgICBmb3IgKGkgPSAwOyBpIDwgNzsgKytpKSB7IGx0LnRhYmxlW2ldID0gMDsgfVxuXG4gICAgbHQudGFibGVbN10gPSAyNDtcbiAgICBsdC50YWJsZVs4XSA9IDE1MjtcbiAgICBsdC50YWJsZVs5XSA9IDExMjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCAyNDsgKytpKSB7IGx0LnRyYW5zW2ldID0gMjU2ICsgaTsgfVxuICAgIGZvciAoaSA9IDA7IGkgPCAxNDQ7ICsraSkgeyBsdC50cmFuc1syNCArIGldID0gaTsgfVxuICAgIGZvciAoaSA9IDA7IGkgPCA4OyArK2kpIHsgbHQudHJhbnNbMjQgKyAxNDQgKyBpXSA9IDI4MCArIGk7IH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgMTEyOyArK2kpIHsgbHQudHJhbnNbMjQgKyAxNDQgKyA4ICsgaV0gPSAxNDQgKyBpOyB9XG5cbiAgICAvKiBidWlsZCBmaXhlZCBkaXN0YW5jZSB0cmVlICovXG4gICAgZm9yIChpID0gMDsgaSA8IDU7ICsraSkgeyBkdC50YWJsZVtpXSA9IDA7IH1cblxuICAgIGR0LnRhYmxlWzVdID0gMzI7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgMzI7ICsraSkgeyBkdC50cmFuc1tpXSA9IGk7IH1cbiAgfVxuXG4gIC8qIGdpdmVuIGFuIGFycmF5IG9mIGNvZGUgbGVuZ3RocywgYnVpbGQgYSB0cmVlICovXG4gIHZhciBvZmZzID0gbmV3IFVpbnQxNkFycmF5KDE2KTtcblxuICBmdW5jdGlvbiB0aW5mX2J1aWxkX3RyZWUodCwgbGVuZ3Rocywgb2ZmLCBudW0pIHtcbiAgICB2YXIgaSwgc3VtO1xuXG4gICAgLyogY2xlYXIgY29kZSBsZW5ndGggY291bnQgdGFibGUgKi9cbiAgICBmb3IgKGkgPSAwOyBpIDwgMTY7ICsraSkgeyB0LnRhYmxlW2ldID0gMDsgfVxuXG4gICAgLyogc2NhbiBzeW1ib2wgbGVuZ3RocywgYW5kIHN1bSBjb2RlIGxlbmd0aCBjb3VudHMgKi9cbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtOyArK2kpIHsgdC50YWJsZVtsZW5ndGhzW29mZiArIGldXSsrOyB9XG5cbiAgICB0LnRhYmxlWzBdID0gMDtcblxuICAgIC8qIGNvbXB1dGUgb2Zmc2V0IHRhYmxlIGZvciBkaXN0cmlidXRpb24gc29ydCAqL1xuICAgIGZvciAoc3VtID0gMCwgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICBvZmZzW2ldID0gc3VtO1xuICAgICAgc3VtICs9IHQudGFibGVbaV07XG4gICAgfVxuXG4gICAgLyogY3JlYXRlIGNvZGUtPnN5bWJvbCB0cmFuc2xhdGlvbiB0YWJsZSAoc3ltYm9scyBzb3J0ZWQgYnkgY29kZSkgKi9cbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtOyArK2kpIHtcbiAgICAgIGlmIChsZW5ndGhzW29mZiArIGldKSB7IHQudHJhbnNbb2Zmc1tsZW5ndGhzW29mZiArIGldXSsrXSA9IGk7IH1cbiAgICB9XG4gIH1cblxuICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcbiAgICogLS0gZGVjb2RlIGZ1bmN0aW9ucyAtLSAqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAvKiBnZXQgb25lIGJpdCBmcm9tIHNvdXJjZSBzdHJlYW0gKi9cbiAgZnVuY3Rpb24gdGluZl9nZXRiaXQoZCkge1xuICAgIC8qIGNoZWNrIGlmIHRhZyBpcyBlbXB0eSAqL1xuICAgIGlmICghZC5iaXRjb3VudC0tKSB7XG4gICAgICAvKiBsb2FkIG5leHQgdGFnICovXG4gICAgICBkLnRhZyA9IGQuc291cmNlW2Quc291cmNlSW5kZXgrK107XG4gICAgICBkLmJpdGNvdW50ID0gNztcbiAgICB9XG5cbiAgICAvKiBzaGlmdCBiaXQgb3V0IG9mIHRhZyAqL1xuICAgIHZhciBiaXQgPSBkLnRhZyAmIDE7XG4gICAgZC50YWcgPj4+PSAxO1xuXG4gICAgcmV0dXJuIGJpdDtcbiAgfVxuXG4gIC8qIHJlYWQgYSBudW0gYml0IHZhbHVlIGZyb20gYSBzdHJlYW0gYW5kIGFkZCBiYXNlICovXG4gIGZ1bmN0aW9uIHRpbmZfcmVhZF9iaXRzKGQsIG51bSwgYmFzZSkge1xuICAgIGlmICghbnVtKVxuICAgICAgeyByZXR1cm4gYmFzZTsgfVxuXG4gICAgd2hpbGUgKGQuYml0Y291bnQgPCAyNCkge1xuICAgICAgZC50YWcgfD0gZC5zb3VyY2VbZC5zb3VyY2VJbmRleCsrXSA8PCBkLmJpdGNvdW50O1xuICAgICAgZC5iaXRjb3VudCArPSA4O1xuICAgIH1cblxuICAgIHZhciB2YWwgPSBkLnRhZyAmICgweGZmZmYgPj4+ICgxNiAtIG51bSkpO1xuICAgIGQudGFnID4+Pj0gbnVtO1xuICAgIGQuYml0Y291bnQgLT0gbnVtO1xuICAgIHJldHVybiB2YWwgKyBiYXNlO1xuICB9XG5cbiAgLyogZ2l2ZW4gYSBkYXRhIHN0cmVhbSBhbmQgYSB0cmVlLCBkZWNvZGUgYSBzeW1ib2wgKi9cbiAgZnVuY3Rpb24gdGluZl9kZWNvZGVfc3ltYm9sKGQsIHQpIHtcbiAgICB3aGlsZSAoZC5iaXRjb3VudCA8IDI0KSB7XG4gICAgICBkLnRhZyB8PSBkLnNvdXJjZVtkLnNvdXJjZUluZGV4KytdIDw8IGQuYml0Y291bnQ7XG4gICAgICBkLmJpdGNvdW50ICs9IDg7XG4gICAgfVxuICAgIFxuICAgIHZhciBzdW0gPSAwLCBjdXIgPSAwLCBsZW4gPSAwO1xuICAgIHZhciB0YWcgPSBkLnRhZztcblxuICAgIC8qIGdldCBtb3JlIGJpdHMgd2hpbGUgY29kZSB2YWx1ZSBpcyBhYm92ZSBzdW0gKi9cbiAgICBkbyB7XG4gICAgICBjdXIgPSAyICogY3VyICsgKHRhZyAmIDEpO1xuICAgICAgdGFnID4+Pj0gMTtcbiAgICAgICsrbGVuO1xuXG4gICAgICBzdW0gKz0gdC50YWJsZVtsZW5dO1xuICAgICAgY3VyIC09IHQudGFibGVbbGVuXTtcbiAgICB9IHdoaWxlIChjdXIgPj0gMCk7XG4gICAgXG4gICAgZC50YWcgPSB0YWc7XG4gICAgZC5iaXRjb3VudCAtPSBsZW47XG5cbiAgICByZXR1cm4gdC50cmFuc1tzdW0gKyBjdXJdO1xuICB9XG5cbiAgLyogZ2l2ZW4gYSBkYXRhIHN0cmVhbSwgZGVjb2RlIGR5bmFtaWMgdHJlZXMgZnJvbSBpdCAqL1xuICBmdW5jdGlvbiB0aW5mX2RlY29kZV90cmVlcyhkLCBsdCwgZHQpIHtcbiAgICB2YXIgaGxpdCwgaGRpc3QsIGhjbGVuO1xuICAgIHZhciBpLCBudW0sIGxlbmd0aDtcblxuICAgIC8qIGdldCA1IGJpdHMgSExJVCAoMjU3LTI4NikgKi9cbiAgICBobGl0ID0gdGluZl9yZWFkX2JpdHMoZCwgNSwgMjU3KTtcblxuICAgIC8qIGdldCA1IGJpdHMgSERJU1QgKDEtMzIpICovXG4gICAgaGRpc3QgPSB0aW5mX3JlYWRfYml0cyhkLCA1LCAxKTtcblxuICAgIC8qIGdldCA0IGJpdHMgSENMRU4gKDQtMTkpICovXG4gICAgaGNsZW4gPSB0aW5mX3JlYWRfYml0cyhkLCA0LCA0KTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCAxOTsgKytpKSB7IGxlbmd0aHNbaV0gPSAwOyB9XG5cbiAgICAvKiByZWFkIGNvZGUgbGVuZ3RocyBmb3IgY29kZSBsZW5ndGggYWxwaGFiZXQgKi9cbiAgICBmb3IgKGkgPSAwOyBpIDwgaGNsZW47ICsraSkge1xuICAgICAgLyogZ2V0IDMgYml0cyBjb2RlIGxlbmd0aCAoMC03KSAqL1xuICAgICAgdmFyIGNsZW4gPSB0aW5mX3JlYWRfYml0cyhkLCAzLCAwKTtcbiAgICAgIGxlbmd0aHNbY2xjaWR4W2ldXSA9IGNsZW47XG4gICAgfVxuXG4gICAgLyogYnVpbGQgY29kZSBsZW5ndGggdHJlZSAqL1xuICAgIHRpbmZfYnVpbGRfdHJlZShjb2RlX3RyZWUsIGxlbmd0aHMsIDAsIDE5KTtcblxuICAgIC8qIGRlY29kZSBjb2RlIGxlbmd0aHMgZm9yIHRoZSBkeW5hbWljIHRyZWVzICovXG4gICAgZm9yIChudW0gPSAwOyBudW0gPCBobGl0ICsgaGRpc3Q7KSB7XG4gICAgICB2YXIgc3ltID0gdGluZl9kZWNvZGVfc3ltYm9sKGQsIGNvZGVfdHJlZSk7XG5cbiAgICAgIHN3aXRjaCAoc3ltKSB7XG4gICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgLyogY29weSBwcmV2aW91cyBjb2RlIGxlbmd0aCAzLTYgdGltZXMgKHJlYWQgMiBiaXRzKSAqL1xuICAgICAgICAgIHZhciBwcmV2ID0gbGVuZ3Roc1tudW0gLSAxXTtcbiAgICAgICAgICBmb3IgKGxlbmd0aCA9IHRpbmZfcmVhZF9iaXRzKGQsIDIsIDMpOyBsZW5ndGg7IC0tbGVuZ3RoKSB7XG4gICAgICAgICAgICBsZW5ndGhzW251bSsrXSA9IHByZXY7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgIC8qIHJlcGVhdCBjb2RlIGxlbmd0aCAwIGZvciAzLTEwIHRpbWVzIChyZWFkIDMgYml0cykgKi9cbiAgICAgICAgICBmb3IgKGxlbmd0aCA9IHRpbmZfcmVhZF9iaXRzKGQsIDMsIDMpOyBsZW5ndGg7IC0tbGVuZ3RoKSB7XG4gICAgICAgICAgICBsZW5ndGhzW251bSsrXSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgIC8qIHJlcGVhdCBjb2RlIGxlbmd0aCAwIGZvciAxMS0xMzggdGltZXMgKHJlYWQgNyBiaXRzKSAqL1xuICAgICAgICAgIGZvciAobGVuZ3RoID0gdGluZl9yZWFkX2JpdHMoZCwgNywgMTEpOyBsZW5ndGg7IC0tbGVuZ3RoKSB7XG4gICAgICAgICAgICBsZW5ndGhzW251bSsrXSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8qIHZhbHVlcyAwLTE1IHJlcHJlc2VudCB0aGUgYWN0dWFsIGNvZGUgbGVuZ3RocyAqL1xuICAgICAgICAgIGxlbmd0aHNbbnVtKytdID0gc3ltO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIGJ1aWxkIGR5bmFtaWMgdHJlZXMgKi9cbiAgICB0aW5mX2J1aWxkX3RyZWUobHQsIGxlbmd0aHMsIDAsIGhsaXQpO1xuICAgIHRpbmZfYnVpbGRfdHJlZShkdCwgbGVuZ3RocywgaGxpdCwgaGRpc3QpO1xuICB9XG5cbiAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuICAgKiAtLSBibG9jayBpbmZsYXRlIGZ1bmN0aW9ucyAtLSAqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgLyogZ2l2ZW4gYSBzdHJlYW0gYW5kIHR3byB0cmVlcywgaW5mbGF0ZSBhIGJsb2NrIG9mIGRhdGEgKi9cbiAgZnVuY3Rpb24gdGluZl9pbmZsYXRlX2Jsb2NrX2RhdGEoZCwgbHQsIGR0KSB7XG4gICAgd2hpbGUgKDEpIHtcbiAgICAgIHZhciBzeW0gPSB0aW5mX2RlY29kZV9zeW1ib2woZCwgbHQpO1xuXG4gICAgICAvKiBjaGVjayBmb3IgZW5kIG9mIGJsb2NrICovXG4gICAgICBpZiAoc3ltID09PSAyNTYpIHtcbiAgICAgICAgcmV0dXJuIFRJTkZfT0s7XG4gICAgICB9XG5cbiAgICAgIGlmIChzeW0gPCAyNTYpIHtcbiAgICAgICAgZC5kZXN0W2QuZGVzdExlbisrXSA9IHN5bTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBsZW5ndGgsIGRpc3QsIG9mZnM7XG4gICAgICAgIHZhciBpO1xuXG4gICAgICAgIHN5bSAtPSAyNTc7XG5cbiAgICAgICAgLyogcG9zc2libHkgZ2V0IG1vcmUgYml0cyBmcm9tIGxlbmd0aCBjb2RlICovXG4gICAgICAgIGxlbmd0aCA9IHRpbmZfcmVhZF9iaXRzKGQsIGxlbmd0aF9iaXRzW3N5bV0sIGxlbmd0aF9iYXNlW3N5bV0pO1xuXG4gICAgICAgIGRpc3QgPSB0aW5mX2RlY29kZV9zeW1ib2woZCwgZHQpO1xuXG4gICAgICAgIC8qIHBvc3NpYmx5IGdldCBtb3JlIGJpdHMgZnJvbSBkaXN0YW5jZSBjb2RlICovXG4gICAgICAgIG9mZnMgPSBkLmRlc3RMZW4gLSB0aW5mX3JlYWRfYml0cyhkLCBkaXN0X2JpdHNbZGlzdF0sIGRpc3RfYmFzZVtkaXN0XSk7XG5cbiAgICAgICAgLyogY29weSBtYXRjaCAqL1xuICAgICAgICBmb3IgKGkgPSBvZmZzOyBpIDwgb2ZmcyArIGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgZC5kZXN0W2QuZGVzdExlbisrXSA9IGQuZGVzdFtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qIGluZmxhdGUgYW4gdW5jb21wcmVzc2VkIGJsb2NrIG9mIGRhdGEgKi9cbiAgZnVuY3Rpb24gdGluZl9pbmZsYXRlX3VuY29tcHJlc3NlZF9ibG9jayhkKSB7XG4gICAgdmFyIGxlbmd0aCwgaW52bGVuZ3RoO1xuICAgIHZhciBpO1xuICAgIFxuICAgIC8qIHVucmVhZCBmcm9tIGJpdGJ1ZmZlciAqL1xuICAgIHdoaWxlIChkLmJpdGNvdW50ID4gOCkge1xuICAgICAgZC5zb3VyY2VJbmRleC0tO1xuICAgICAgZC5iaXRjb3VudCAtPSA4O1xuICAgIH1cblxuICAgIC8qIGdldCBsZW5ndGggKi9cbiAgICBsZW5ndGggPSBkLnNvdXJjZVtkLnNvdXJjZUluZGV4ICsgMV07XG4gICAgbGVuZ3RoID0gMjU2ICogbGVuZ3RoICsgZC5zb3VyY2VbZC5zb3VyY2VJbmRleF07XG5cbiAgICAvKiBnZXQgb25lJ3MgY29tcGxlbWVudCBvZiBsZW5ndGggKi9cbiAgICBpbnZsZW5ndGggPSBkLnNvdXJjZVtkLnNvdXJjZUluZGV4ICsgM107XG4gICAgaW52bGVuZ3RoID0gMjU2ICogaW52bGVuZ3RoICsgZC5zb3VyY2VbZC5zb3VyY2VJbmRleCArIDJdO1xuXG4gICAgLyogY2hlY2sgbGVuZ3RoICovXG4gICAgaWYgKGxlbmd0aCAhPT0gKH5pbnZsZW5ndGggJiAweDAwMDBmZmZmKSlcbiAgICAgIHsgcmV0dXJuIFRJTkZfREFUQV9FUlJPUjsgfVxuXG4gICAgZC5zb3VyY2VJbmRleCArPSA0O1xuXG4gICAgLyogY29weSBibG9jayAqL1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaTsgLS1pKVxuICAgICAgeyBkLmRlc3RbZC5kZXN0TGVuKytdID0gZC5zb3VyY2VbZC5zb3VyY2VJbmRleCsrXTsgfVxuXG4gICAgLyogbWFrZSBzdXJlIHdlIHN0YXJ0IG5leHQgYmxvY2sgb24gYSBieXRlIGJvdW5kYXJ5ICovXG4gICAgZC5iaXRjb3VudCA9IDA7XG5cbiAgICByZXR1cm4gVElORl9PSztcbiAgfVxuXG4gIC8qIGluZmxhdGUgc3RyZWFtIGZyb20gc291cmNlIHRvIGRlc3QgKi9cbiAgZnVuY3Rpb24gdGluZl91bmNvbXByZXNzKHNvdXJjZSwgZGVzdCkge1xuICAgIHZhciBkID0gbmV3IERhdGEoc291cmNlLCBkZXN0KTtcbiAgICB2YXIgYmZpbmFsLCBidHlwZSwgcmVzO1xuXG4gICAgZG8ge1xuICAgICAgLyogcmVhZCBmaW5hbCBibG9jayBmbGFnICovXG4gICAgICBiZmluYWwgPSB0aW5mX2dldGJpdChkKTtcblxuICAgICAgLyogcmVhZCBibG9jayB0eXBlICgyIGJpdHMpICovXG4gICAgICBidHlwZSA9IHRpbmZfcmVhZF9iaXRzKGQsIDIsIDApO1xuXG4gICAgICAvKiBkZWNvbXByZXNzIGJsb2NrICovXG4gICAgICBzd2l0Y2ggKGJ0eXBlKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAvKiBkZWNvbXByZXNzIHVuY29tcHJlc3NlZCBibG9jayAqL1xuICAgICAgICAgIHJlcyA9IHRpbmZfaW5mbGF0ZV91bmNvbXByZXNzZWRfYmxvY2soZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAvKiBkZWNvbXByZXNzIGJsb2NrIHdpdGggZml4ZWQgaHVmZm1hbiB0cmVlcyAqL1xuICAgICAgICAgIHJlcyA9IHRpbmZfaW5mbGF0ZV9ibG9ja19kYXRhKGQsIHNsdHJlZSwgc2R0cmVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIC8qIGRlY29tcHJlc3MgYmxvY2sgd2l0aCBkeW5hbWljIGh1ZmZtYW4gdHJlZXMgKi9cbiAgICAgICAgICB0aW5mX2RlY29kZV90cmVlcyhkLCBkLmx0cmVlLCBkLmR0cmVlKTtcbiAgICAgICAgICByZXMgPSB0aW5mX2luZmxhdGVfYmxvY2tfZGF0YShkLCBkLmx0cmVlLCBkLmR0cmVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXMgPSBUSU5GX0RBVEFfRVJST1I7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXMgIT09IFRJTkZfT0spXG4gICAgICAgIHsgdGhyb3cgbmV3IEVycm9yKCdEYXRhIGVycm9yJyk7IH1cblxuICAgIH0gd2hpbGUgKCFiZmluYWwpO1xuXG4gICAgaWYgKGQuZGVzdExlbiA8IGQuZGVzdC5sZW5ndGgpIHtcbiAgICAgIGlmICh0eXBlb2YgZC5kZXN0LnNsaWNlID09PSAnZnVuY3Rpb24nKVxuICAgICAgICB7IHJldHVybiBkLmRlc3Quc2xpY2UoMCwgZC5kZXN0TGVuKTsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IHJldHVybiBkLmRlc3Quc3ViYXJyYXkoMCwgZC5kZXN0TGVuKTsgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZC5kZXN0O1xuICB9XG5cbiAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuICAgKiAtLSBpbml0aWFsaXphdGlvbiAtLSAqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgLyogYnVpbGQgZml4ZWQgaHVmZm1hbiB0cmVlcyAqL1xuICB0aW5mX2J1aWxkX2ZpeGVkX3RyZWVzKHNsdHJlZSwgc2R0cmVlKTtcblxuICAvKiBidWlsZCBleHRyYSBiaXRzIGFuZCBiYXNlIHRhYmxlcyAqL1xuICB0aW5mX2J1aWxkX2JpdHNfYmFzZShsZW5ndGhfYml0cywgbGVuZ3RoX2Jhc2UsIDQsIDMpO1xuICB0aW5mX2J1aWxkX2JpdHNfYmFzZShkaXN0X2JpdHMsIGRpc3RfYmFzZSwgMiwgMSk7XG5cbiAgLyogZml4IGEgc3BlY2lhbCBjYXNlICovXG4gIGxlbmd0aF9iaXRzWzI4XSA9IDA7XG4gIGxlbmd0aF9iYXNlWzI4XSA9IDI1ODtcblxuICBtb2R1bGUuZXhwb3J0cyA9IHRpbmZfdW5jb21wcmVzcztcblxuICAgIHJldHVybiBtb2R1bGUuZXhwb3J0c1xuICB9KSgpO1xuICAvLyBFbmQgdGlueUluZmxhdGVcblxuICAvLyBCZWdpbiB3b2ZmMm90Zi5qc1xuICAvKlxuICAgQ29weXJpZ2h0IDIwMTIsIFN0ZWZmZW4gSGFuaWtlbCAoaHR0cHM6Ly9naXRodWIuY29tL2hhbmlrZXNuKVxuICAgTW9kaWZpZWQgYnkgQXJ0ZW15IFRyZWd1YmVua28sIDIwMTQgKGh0dHBzOi8vZ2l0aHViLmNvbS9hcnR5LW5hbWUvd29mZjJvdGYpXG4gICBNb2RpZmllZCBieSBKYXNvbiBKb2huc3RvbiwgMjAxOSAocGFrbyAtLT4gdGlueS1pbmZsYXRlKVxuICAgXG4gICAgIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gICAgIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuICAgQSB0b29sIHRvIGNvbnZlcnQgYSBXT0ZGIGJhY2sgdG8gYSBUVEYvT1RGIGZvbnQgZmlsZSwgaW4gcHVyZSBKYXZhc2NyaXB0XG4gICovXG5cbiAgZnVuY3Rpb24gY29udmVydF9zdHJlYW1zKGJ1ZmZlckluLCB0aW55SW5mbGF0ZSkge1xuICAgICAgdmFyIGRhdGFWaWV3SW4gPSBuZXcgRGF0YVZpZXcoYnVmZmVySW4pO1xuICAgICAgdmFyIG9mZnNldEluID0gMDtcblxuICAgICAgZnVuY3Rpb24gcmVhZDIoKSB7XG4gICAgICAgICAgdmFyIHVpbnQxNiA9IGRhdGFWaWV3SW4uZ2V0VWludDE2KG9mZnNldEluKTtcbiAgICAgICAgICBvZmZzZXRJbiArPSAyO1xuICAgICAgICAgIHJldHVybiB1aW50MTY7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJlYWQ0KCkge1xuICAgICAgICAgIHZhciB1aW50MzIgPSBkYXRhVmlld0luLmdldFVpbnQzMihvZmZzZXRJbik7XG4gICAgICAgICAgb2Zmc2V0SW4gKz0gNDtcbiAgICAgICAgICByZXR1cm4gdWludDMyO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB3cml0ZTIodWludDE2KSB7XG4gICAgICAgICAgZGF0YVZpZXdPdXQuc2V0VWludDE2KG9mZnNldE91dCwgdWludDE2KTtcbiAgICAgICAgICBvZmZzZXRPdXQgKz0gMjtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gd3JpdGU0KHVpbnQzMikge1xuICAgICAgICAgIGRhdGFWaWV3T3V0LnNldFVpbnQzMihvZmZzZXRPdXQsIHVpbnQzMik7XG4gICAgICAgICAgb2Zmc2V0T3V0ICs9IDQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBXT0ZGSGVhZGVyID0ge1xuICAgICAgICAgIHNpZ25hdHVyZTogcmVhZDQoKSxcbiAgICAgICAgICBmbGF2b3I6IHJlYWQ0KCksXG4gICAgICAgICAgbGVuZ3RoOiByZWFkNCgpLFxuICAgICAgICAgIG51bVRhYmxlczogcmVhZDIoKSxcbiAgICAgICAgICByZXNlcnZlZDogcmVhZDIoKSxcbiAgICAgICAgICB0b3RhbFNmbnRTaXplOiByZWFkNCgpLFxuICAgICAgICAgIG1ham9yVmVyc2lvbjogcmVhZDIoKSxcbiAgICAgICAgICBtaW5vclZlcnNpb246IHJlYWQyKCksXG4gICAgICAgICAgbWV0YU9mZnNldDogcmVhZDQoKSxcbiAgICAgICAgICBtZXRhTGVuZ3RoOiByZWFkNCgpLFxuICAgICAgICAgIG1ldGFPcmlnTGVuZ3RoOiByZWFkNCgpLFxuICAgICAgICAgIHByaXZPZmZzZXQ6IHJlYWQ0KCksXG4gICAgICAgICAgcHJpdkxlbmd0aDogcmVhZDQoKVxuICAgICAgfTtcblxuICAgICAgdmFyIGVudHJ5U2VsZWN0b3IgPSAwO1xuICAgICAgd2hpbGUgKE1hdGgucG93KDIsIGVudHJ5U2VsZWN0b3IpIDw9IFdPRkZIZWFkZXIubnVtVGFibGVzKSB7XG4gICAgICAgICAgZW50cnlTZWxlY3RvcisrO1xuICAgICAgfVxuICAgICAgZW50cnlTZWxlY3Rvci0tO1xuXG4gICAgICB2YXIgc2VhcmNoUmFuZ2UgPSBNYXRoLnBvdygyLCBlbnRyeVNlbGVjdG9yKSAqIDE2O1xuICAgICAgdmFyIHJhbmdlU2hpZnQgPSBXT0ZGSGVhZGVyLm51bVRhYmxlcyAqIDE2IC0gc2VhcmNoUmFuZ2U7XG5cbiAgICAgIHZhciBvZmZzZXQgPSA0ICsgMiArIDIgKyAyICsgMjtcbiAgICAgIHZhciBUYWJsZURpcmVjdG9yeUVudHJpZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgV09GRkhlYWRlci5udW1UYWJsZXM7IGkrKykge1xuICAgICAgICAgIFRhYmxlRGlyZWN0b3J5RW50cmllcy5wdXNoKHtcbiAgICAgICAgICAgICAgdGFnOiByZWFkNCgpLFxuICAgICAgICAgICAgICBvZmZzZXQ6IHJlYWQ0KCksXG4gICAgICAgICAgICAgIGNvbXBMZW5ndGg6IHJlYWQ0KCksXG4gICAgICAgICAgICAgIG9yaWdMZW5ndGg6IHJlYWQ0KCksXG4gICAgICAgICAgICAgIG9yaWdDaGVja3N1bTogcmVhZDQoKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG9mZnNldCArPSA0ICogNDtcbiAgICAgIH1cblxuICAgICAgdmFyIGFycmF5T3V0ID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgICAgNCArIDIgKyAyICsgMiArIDIgK1xuICAgICAgICAgIFRhYmxlRGlyZWN0b3J5RW50cmllcy5sZW5ndGggKiAoNCArIDQgKyA0ICsgNCkgK1xuICAgICAgICAgIFRhYmxlRGlyZWN0b3J5RW50cmllcy5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBlbnRyeSkgeyByZXR1cm4gYWNjICsgZW50cnkub3JpZ0xlbmd0aCArIDQ7IH0sIDApXG4gICAgICApO1xuICAgICAgdmFyIGJ1ZmZlck91dCA9IGFycmF5T3V0LmJ1ZmZlcjtcbiAgICAgIHZhciBkYXRhVmlld091dCA9IG5ldyBEYXRhVmlldyhidWZmZXJPdXQpO1xuICAgICAgdmFyIG9mZnNldE91dCA9IDA7XG5cbiAgICAgIHdyaXRlNChXT0ZGSGVhZGVyLmZsYXZvcik7XG4gICAgICB3cml0ZTIoV09GRkhlYWRlci5udW1UYWJsZXMpO1xuICAgICAgd3JpdGUyKHNlYXJjaFJhbmdlKTtcbiAgICAgIHdyaXRlMihlbnRyeVNlbGVjdG9yKTtcbiAgICAgIHdyaXRlMihyYW5nZVNoaWZ0KTtcblxuICAgICAgVGFibGVEaXJlY3RvcnlFbnRyaWVzLmZvckVhY2goZnVuY3Rpb24oVGFibGVEaXJlY3RvcnlFbnRyeSkge1xuICAgICAgICAgIHdyaXRlNChUYWJsZURpcmVjdG9yeUVudHJ5LnRhZyk7XG4gICAgICAgICAgd3JpdGU0KFRhYmxlRGlyZWN0b3J5RW50cnkub3JpZ0NoZWNrc3VtKTtcbiAgICAgICAgICB3cml0ZTQob2Zmc2V0KTtcbiAgICAgICAgICB3cml0ZTQoVGFibGVEaXJlY3RvcnlFbnRyeS5vcmlnTGVuZ3RoKTtcblxuICAgICAgICAgIFRhYmxlRGlyZWN0b3J5RW50cnkub3V0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgIG9mZnNldCArPSBUYWJsZURpcmVjdG9yeUVudHJ5Lm9yaWdMZW5ndGg7XG4gICAgICAgICAgaWYgKChvZmZzZXQgJSA0KSAhPSAwKSB7XG4gICAgICAgICAgICAgIG9mZnNldCArPSA0IC0gKG9mZnNldCAlIDQpO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB2YXIgc2l6ZTtcblxuICAgICAgVGFibGVEaXJlY3RvcnlFbnRyaWVzLmZvckVhY2goZnVuY3Rpb24oVGFibGVEaXJlY3RvcnlFbnRyeSkge1xuICAgICAgICAgIHZhciBjb21wcmVzc2VkRGF0YSA9IGJ1ZmZlckluLnNsaWNlKFxuICAgICAgICAgICAgICBUYWJsZURpcmVjdG9yeUVudHJ5Lm9mZnNldCxcbiAgICAgICAgICAgICAgVGFibGVEaXJlY3RvcnlFbnRyeS5vZmZzZXQgKyBUYWJsZURpcmVjdG9yeUVudHJ5LmNvbXBMZW5ndGhcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKFRhYmxlRGlyZWN0b3J5RW50cnkuY29tcExlbmd0aCAhPSBUYWJsZURpcmVjdG9yeUVudHJ5Lm9yaWdMZW5ndGgpIHtcbiAgICAgICAgICAgICAgdmFyIHVuY29tcHJlc3NlZERhdGEgPSBuZXcgVWludDhBcnJheShUYWJsZURpcmVjdG9yeUVudHJ5Lm9yaWdMZW5ndGgpO1xuICAgICAgICAgICAgICB0aW55SW5mbGF0ZShcbiAgICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShjb21wcmVzc2VkRGF0YSwgMiksIC8vc2tpcCBkZWZsYXRlIGhlYWRlclxuICAgICAgICAgICAgICAgIHVuY29tcHJlc3NlZERhdGFcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB1bmNvbXByZXNzZWREYXRhID0gbmV3IFVpbnQ4QXJyYXkoY29tcHJlc3NlZERhdGEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFycmF5T3V0LnNldCh1bmNvbXByZXNzZWREYXRhLCBUYWJsZURpcmVjdG9yeUVudHJ5Lm91dE9mZnNldCk7XG4gICAgICAgICAgb2Zmc2V0ID0gVGFibGVEaXJlY3RvcnlFbnRyeS5vdXRPZmZzZXQgKyBUYWJsZURpcmVjdG9yeUVudHJ5Lm9yaWdMZW5ndGg7XG5cbiAgICAgICAgICB2YXIgcGFkZGluZyA9IDA7XG4gICAgICAgICAgaWYgKChvZmZzZXQgJSA0KSAhPSAwKSB7XG4gICAgICAgICAgICAgIHBhZGRpbmcgPSA0IC0gKG9mZnNldCAlIDQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhcnJheU91dC5zZXQoXG4gICAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KHBhZGRpbmcpLmJ1ZmZlcixcbiAgICAgICAgICAgICAgVGFibGVEaXJlY3RvcnlFbnRyeS5vdXRPZmZzZXQgKyBUYWJsZURpcmVjdG9yeUVudHJ5Lm9yaWdMZW5ndGhcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgc2l6ZSA9IG9mZnNldCArIHBhZGRpbmc7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGJ1ZmZlck91dC5zbGljZSgwLCBzaXplKTtcbiAgfVxuXG4gIC8vIEVuZCB3b2ZmMm90Zi5qc1xuXG4gIHJldHVybiBmdW5jdGlvbihidWZmZXIpIHtcbiAgICByZXR1cm4gY29udmVydF9zdHJlYW1zKGJ1ZmZlciwgdGlueUluZmxhdGUpXG4gIH1cblxuICB9XG5cbiAgLyoqXG4gICAqIEFuIGFkYXB0ZXIgdGhhdCBhbGxvd3MgVHlwci5qcyB0byBiZSB1c2VkIGFzIGlmIGl0IHdlcmUgKGEgc3Vic2V0IG9mKSB0aGUgT3BlblR5cGUuanMgQVBJLlxuICAgKiBBbHNvIGFkZHMgc3VwcG9ydCBmb3IgV09GRiBmaWxlcyAobm90IFdPRkYyKS5cbiAgICovXG5cbiAgZnVuY3Rpb24gcGFyc2VyRmFjdG9yeShUeXByLCB3b2ZmMm90Zikge1xuICAgIHZhciBjbWRBcmdMZW5ndGhzID0ge1xuICAgICAgTTogMixcbiAgICAgIEw6IDIsXG4gICAgICBROiA0LFxuICAgICAgQzogNixcbiAgICAgIFo6IDBcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gd3JhcEZvbnRPYmoodHlwckZvbnQpIHtcbiAgICAgIHZhciBnbHlwaE1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgIHZhciBmb250T2JqID0ge1xuICAgICAgICB1bml0c1BlckVtOiB0eXByRm9udC5oZWFkLnVuaXRzUGVyRW0sXG4gICAgICAgIGFzY2VuZGVyOiB0eXByRm9udC5oaGVhLmFzY2VuZGVyLFxuICAgICAgICBkZXNjZW5kZXI6IHR5cHJGb250LmhoZWEuZGVzY2VuZGVyLFxuICAgICAgICBmb3JFYWNoR2x5cGg6IGZ1bmN0aW9uIGZvckVhY2hHbHlwaCh0ZXh0LCBmb250U2l6ZSwgbGV0dGVyU3BhY2luZywgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgZ2x5cGhYID0gMDtcbiAgICAgICAgICB2YXIgZm9udFNjYWxlID0gMSAvIGZvbnRPYmoudW5pdHNQZXJFbSAqIGZvbnRTaXplO1xuXG4gICAgICAgICAgdmFyIGdseXBoSW5kaWNlcyA9IFR5cHIuVS5zdHJpbmdUb0dseXBocyh0eXByRm9udCwgdGV4dCk7XG4gICAgICAgICAgdmFyIGNoYXJJbmRleCA9IDA7XG4gICAgICAgICAgZ2x5cGhJbmRpY2VzLmZvckVhY2goZnVuY3Rpb24gKGdseXBoSW5kZXgpIHtcbiAgICAgICAgICAgIC8vIFR5cHIgcmV0dXJucyBhIGdseXBoIGluZGV4IHBlciBzdHJpbmcgY29kZXBvaW50LCB3aXRoIC0xcyBpbiBwbGFjZSBvZiB0aG9zZSB0aGF0XG4gICAgICAgICAgICAvLyB3ZXJlIG9taXR0ZWQgZHVlIHRvIGxpZ2F0dXJlIHN1YnN0aXR1dGlvbi4gU28gd2UgY2FuIHRyYWNrIG9yaWdpbmFsIGluZGV4IGluIHRoZVxuICAgICAgICAgICAgLy8gc3RyaW5nIHZpYSBzaW1wbGUgaW5jcmVtZW50LCBhbmQgc2tpcCBldmVyeXRoaW5nIGVsc2Ugd2hlbiBzZWVpbmcgYSAtMS5cbiAgICAgICAgICAgIGlmIChnbHlwaEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICB2YXIgZ2x5cGhPYmogPSBnbHlwaE1hcFtnbHlwaEluZGV4XTtcbiAgICAgICAgICAgICAgaWYgKCFnbHlwaE9iaikge1xuICAgICAgICAgICAgICAgIHZhciByZWYgPSBUeXByLlUuZ2x5cGhUb1BhdGgodHlwckZvbnQsIGdseXBoSW5kZXgpO1xuICAgICAgICAgICAgICAgIHZhciBjbWRzID0gcmVmLmNtZHM7XG4gICAgICAgICAgICAgICAgdmFyIGNyZHMgPSByZWYuY3JkcztcblxuICAgICAgICAgICAgICAgIC8vIEZpbmQgZXh0ZW50cyAtIEdseWYgZ2l2ZXMgdGhpcyBpbiBtZXRhZGF0YSBidXQgbm90IENGRiwgYW5kIFR5cHIgZG9lc24ndFxuICAgICAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSB0aGUgdHdvLCBzbyBpdCdzIHNpbXBsZXN0IGp1c3QgdG8gaXRlcmF0ZSBvdXJzZWx2ZXMuXG4gICAgICAgICAgICAgICAgdmFyIHhNaW4sIHlNaW4sIHhNYXgsIHlNYXg7XG4gICAgICAgICAgICAgICAgaWYgKGNyZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICB4TWluID0geU1pbiA9IEluZmluaXR5O1xuICAgICAgICAgICAgICAgICAgeE1heCA9IHlNYXggPSAtSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY3Jkcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IGNyZHNbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciB5ID0gY3Jkc1tpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh4IDwgeE1pbikgeyB4TWluID0geDsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoeSA8IHlNaW4pIHsgeU1pbiA9IHk7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHggPiB4TWF4KSB7IHhNYXggPSB4OyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh5ID4geU1heCkgeyB5TWF4ID0geTsgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB4TWluID0geE1heCA9IHlNaW4gPSB5TWF4ID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBnbHlwaE9iaiA9IGdseXBoTWFwW2dseXBoSW5kZXhdID0ge1xuICAgICAgICAgICAgICAgICAgaW5kZXg6IGdseXBoSW5kZXgsXG4gICAgICAgICAgICAgICAgICBhZHZhbmNlV2lkdGg6IHR5cHJGb250LmhtdHguYVdpZHRoW2dseXBoSW5kZXhdLFxuICAgICAgICAgICAgICAgICAgeE1pbjogeE1pbixcbiAgICAgICAgICAgICAgICAgIHlNaW46IHlNaW4sXG4gICAgICAgICAgICAgICAgICB4TWF4OiB4TWF4LFxuICAgICAgICAgICAgICAgICAgeU1heDogeU1heCxcbiAgICAgICAgICAgICAgICAgIHBhdGhDb21tYW5kQ291bnQ6IGNtZHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgZm9yRWFjaFBhdGhDb21tYW5kOiBmdW5jdGlvbiBmb3JFYWNoUGF0aENvbW1hbmQoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3NJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzQXJyYXkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNtZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgbnVtQXJncyA9IGNtZEFyZ0xlbmd0aHNbY21kc1tpXV07XG4gICAgICAgICAgICAgICAgICAgICAgYXJnc0FycmF5Lmxlbmd0aCA9IDEgKyBudW1BcmdzO1xuICAgICAgICAgICAgICAgICAgICAgIGFyZ3NBcnJheVswXSA9IGNtZHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPD0gbnVtQXJnczsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzQXJyYXlbal0gPSBjcmRzW2FyZ3NJbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJnc0FycmF5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKG51bGwsIGdseXBoT2JqLCBnbHlwaFgsIGNoYXJJbmRleCk7XG5cbiAgICAgICAgICAgICAgaWYgKGdseXBoT2JqLmFkdmFuY2VXaWR0aCkge1xuICAgICAgICAgICAgICAgIGdseXBoWCArPSBnbHlwaE9iai5hZHZhbmNlV2lkdGggKiBmb250U2NhbGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGxldHRlclNwYWNpbmcpIHtcbiAgICAgICAgICAgICAgICBnbHlwaFggKz0gbGV0dGVyU3BhY2luZyAqIGZvbnRTaXplO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGFySW5kZXggKz0gKHRleHQuY29kZVBvaW50QXQoY2hhckluZGV4KSA+IDB4ZmZmZiA/IDIgOiAxKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gZ2x5cGhYXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBmb250T2JqXG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHBhcnNlKGJ1ZmZlcikge1xuICAgICAgLy8gTG9vayB0byBzZWUgaWYgd2UgaGF2ZSBhIFdPRkYgZmlsZSBhbmQgY29udmVydCBpdCBpZiBzbzpcbiAgICAgIHZhciBwZWVrID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCAwLCA0KTtcbiAgICAgIHZhciB0YWcgPSBUeXByLl9iaW4ucmVhZEFTQ0lJKHBlZWssIDAsIDQpO1xuICAgICAgaWYgKHRhZyA9PT0gJ3dPRkYnKSB7XG4gICAgICAgIGJ1ZmZlciA9IHdvZmYyb3RmKGJ1ZmZlcik7XG4gICAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3dPRjInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignd29mZjIgZm9udHMgbm90IHN1cHBvcnRlZCcpXG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcEZvbnRPYmooVHlwci5wYXJzZShidWZmZXIpWzBdKVxuICAgIH1cbiAgfVxuXG5cbiAgdmFyIHdvcmtlck1vZHVsZSA9IHRyb2lrYVdvcmtlclV0aWxzLmRlZmluZVdvcmtlck1vZHVsZSh7XG4gICAgbmFtZTogJ1R5cHIgRm9udCBQYXJzZXInLFxuICAgIGRlcGVuZGVuY2llczogW3R5cHJGYWN0b3J5LCB3b2ZmMm90ZkZhY3RvcnksIHBhcnNlckZhY3RvcnldLFxuICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQodHlwckZhY3RvcnksIHdvZmYyb3RmRmFjdG9yeSwgcGFyc2VyRmFjdG9yeSkge1xuICAgICAgdmFyIFR5cHIgPSB0eXByRmFjdG9yeSgpO1xuICAgICAgdmFyIHdvZmYyb3RmID0gd29mZjJvdGZGYWN0b3J5KCk7XG4gICAgICByZXR1cm4gcGFyc2VyRmFjdG9yeShUeXByLCB3b2ZmMm90ZilcbiAgICB9XG4gIH0pO1xuXG4gIC8vaW1wb3J0IGZvbnRQYXJzZXIgZnJvbSAnLi9Gb250UGFyc2VyX09wZW5UeXBlLmpzJ1xuXG5cbiAgdmFyIENPTkZJRyA9IHtcbiAgICBkZWZhdWx0Rm9udFVSTDogJ2h0dHBzOi8vZm9udHMuZ3N0YXRpYy5jb20vcy9yb2JvdG8vdjE4L0tGT21DbnFFdTkyRnIxTXU0bXhNLndvZmYnLCAvL1JvYm90byBSZWd1bGFyXG4gICAgc2RmR2x5cGhTaXplOiA2NCxcbiAgICB0ZXh0dXJlV2lkdGg6IDIwNDhcbiAgfTtcbiAgdmFyIHRlbXBDb2xvciA9IG5ldyB0aHJlZS5Db2xvcigpO1xuXG4gIC8qKlxuICAgKiBDdXN0b21pemVzIHRoZSB0ZXh0IGJ1aWxkZXIgY29uZmlndXJhdGlvbi4gVGhpcyBtdXN0IGJlIGNhbGxlZCBwcmlvciB0byB0aGUgZmlyc3QgZm9udCBwcm9jZXNzaW5nXG4gICAqIHJlcXVlc3QsIGFuZCBhcHBsaWVzIHRvIGFsbCBmb250cy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5kZWZhdWx0Rm9udFVSTCAtIFRoZSBVUkwgb2YgdGhlIGRlZmF1bHQgZm9udCB0byB1c2UgZm9yIHRleHQgcHJvY2Vzc2luZ1xuICAgKiAgICAgICAgICAgICAgICAgcmVxdWVzdHMsIGluIGNhc2Ugbm9uZSBpcyBzcGVjaWZpZWQgb3IgdGhlIHNwZWNpZmllZGUgZm9udCBmYWlscyB0byBsb2FkIG9yIHBhcnNlLlxuICAgKiAgICAgICAgICAgICAgICAgRGVmYXVsdHMgdG8gXCJSb2JvdG8gUmVndWxhclwiIGZyb20gR29vZ2xlIEZvbnRzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnNkZkdseXBoU2l6ZSAtIFRoZSBkZWZhdWx0IHNpemUgb2YgZWFjaCBnbHlwaCdzIFNERiAoc2lnbmVkIGRpc3RhbmNlIGZpZWxkKVxuICAgKiAgICAgICAgICAgICAgICAgdGV4dHVyZSB1c2VkIGZvciByZW5kZXJpbmcuIE11c3QgYmUgYSBwb3dlci1vZi10d28gbnVtYmVyLCBhbmQgYXBwbGllcyB0byBhbGwgZm9udHMsXG4gICAqICAgICAgICAgICAgICAgICBidXQgbm90ZSB0aGF0IHRoaXMgY2FuIGFsc28gYmUgb3ZlcnJpZGRlbiBwZXIgY2FsbCB0byBgZ2V0VGV4dFJlbmRlckluZm8oKWAuXG4gICAqICAgICAgICAgICAgICAgICBMYXJnZXIgc2l6ZXMgY2FuIGltcHJvdmUgdGhlIHF1YWxpdHkgb2YgZ2x5cGggcmVuZGVyaW5nIGJ5IGluY3JlYXNpbmcgdGhlIHNoYXJwbmVzc1xuICAgKiAgICAgICAgICAgICAgICAgb2YgY29ybmVycyBhbmQgcHJldmVudGluZyBsb3NzIG9mIHZlcnkgdGhpbiBsaW5lcywgYXQgdGhlIGV4cGVuc2Ugb2YgbWVtb3J5LiBEZWZhdWx0c1xuICAgKiAgICAgICAgICAgICAgICAgdG8gNjQgd2hpY2ggaXMgZ2VuZXJhbGx5IGEgZ29vZCBiYWxhbmNlIG9mIHNpemUgYW5kIHF1YWxpdHkuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcudGV4dHVyZVdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSBTREYgdGV4dHVyZTsgbXVzdCBiZSBhIHBvd2VyIG9mIDIuIERlZmF1bHRzIHRvXG4gICAqICAgICAgICAgICAgICAgICAyMDQ4IHdoaWNoIGlzIGEgc2FmZSBtYXhpbXVtIHRleHR1cmUgZGltZW5zaW9uIGFjY29yZGluZyB0byB0aGUgc3RhdHMgYXRcbiAgICogICAgICAgICAgICAgICAgIGh0dHBzOi8vd2ViZ2xzdGF0cy5jb20vd2ViZ2wvcGFyYW1ldGVyL01BWF9URVhUVVJFX1NJWkUgYW5kIHNob3VsZCBhbGxvdyBmb3IgYVxuICAgKiAgICAgICAgICAgICAgICAgcmVhc29uYWJseSBsYXJnZSBudW1iZXIgb2YgZ2x5cGhzIChkZWZhdWx0IGdseXBoIHNpemUgb2YgNjQgYW5kIHNhZmUgdGV4dHVyZSBzaXplIG9mXG4gICAqICAgICAgICAgICAgICAgICAyMDQ4XjIgYWxsb3dzIGZvciAxMDI0IGdseXBocy4pIFRoaXMgY2FuIGJlIGluY3JlYXNlZCBpZiB5b3UgbmVlZCB0byBpbmNyZWFzZSB0aGVcbiAgICogICAgICAgICAgICAgICAgIGdseXBoIHNpemUgYW5kL29yIGhhdmUgYW4gZXh0cmFvcmRpbmFyeSBudW1iZXIgb2YgZ2x5cGhzLlxuICAgKi9cbiAgZnVuY3Rpb24gY29uZmlndXJlVGV4dEJ1aWxkZXIoY29uZmlnKSB7XG4gICAge1xuICAgICAgYXNzaWduKENPTkZJRywgY29uZmlnKTtcbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBUaGUgcmFkaWFsIGRpc3RhbmNlIGZyb20gZ2x5cGggZWRnZXMgb3ZlciB3aGljaCB0aGUgU0RGIGFscGhhIHdpbGwgYmUgY2FsY3VsYXRlZDsgaWYgdGhlIGFscGhhXG4gICAqIGF0IGRpc3RhbmNlOjAgaXMgMC41LCB0aGVuIHRoZSBhbHBoYSBhdCB0aGlzIGRpc3RhbmNlIHdpbGwgYmUgemVyby4gVGhpcyBpcyBkZWZpbmVkIGFzIGEgcGVyY2VudGFnZVxuICAgKiBvZiBlYWNoIGdseXBoJ3MgbWF4aW11bSBkaW1lbnNpb24gaW4gZm9udCBzcGFjZSB1bml0cyBzbyB0aGF0IGl0IG1hcHMgdG8gdGhlIHNhbWUgbWluaW11bSBudW1iZXIgb2ZcbiAgICogU0RGIHRleGVscyByZWdhcmRsZXNzIG9mIHRoZSBnbHlwaCdzIHNpemUuIEEgbGFyZ2VyIHZhbHVlIHByb3ZpZGVzIGdyZWF0ZXIgYWxwaGEgZ3JhZGllbnQgcmVzb2x1dGlvblxuICAgKiBhbmQgaW1wcm92ZXMgcmVhZGFiaWxpdHkvYW50aWFsaWFzaW5nIHF1YWxpdHkgYXQgc21hbGwgZGlzcGxheSBzaXplcywgYnV0IGFsc28gZGVjcmVhc2VzIHRoZSBudW1iZXJcbiAgICogb2YgdGV4ZWxzIGF2YWlsYWJsZSBmb3IgZW5jb2RpbmcgcGF0aCBkZXRhaWxzLlxuICAgKi9cbiAgdmFyIFNERl9ESVNUQU5DRV9QRVJDRU5UID0gMSAvIDg7XG5cblxuICAvKipcbiAgICogUmVwb3NpdG9yeSBmb3IgYWxsIGZvbnQgU0RGIGF0bGFzIHRleHR1cmVzXG4gICAqXG4gICAqICAge1xuICAgKiAgICAgW2ZvbnRdOiB7XG4gICAqICAgICAgIHNkZlRleHR1cmU6IERhdGFUZXh0dXJlXG4gICAqICAgICB9XG4gICAqICAgfVxuICAgKi9cbiAgdmFyIGF0bGFzZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7b2JqZWN0fSBUcm9pa2FUZXh0UmVuZGVySW5mbyAtIEZvcm1hdCBvZiB0aGUgcmVzdWx0IGZyb20gYGdldFRleHRSZW5kZXJJbmZvYC5cbiAgICogQHByb3BlcnR5IHtvYmplY3R9IHBhcmFtZXRlcnMgLSBUaGUgbm9ybWFsaXplZCBpbnB1dCBhcmd1bWVudHMgdG8gdGhlIHJlbmRlciBjYWxsLlxuICAgKiBAcHJvcGVydHkge0RhdGFUZXh0dXJlfSBzZGZUZXh0dXJlIC0gVGhlIFNERiBhdGxhcyB0ZXh0dXJlLlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gc2RmR2x5cGhTaXplIC0gVGhlIHNpemUgb2YgZWFjaCBnbHlwaCdzIFNERi5cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHNkZk1pbkRpc3RhbmNlUGVyY2VudCAtIFNlZSBgU0RGX0RJU1RBTkNFX1BFUkNFTlRgXG4gICAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5fSBnbHlwaEJvdW5kcyAtIExpc3Qgb2YgW21pblgsIG1pblksIG1heFgsIG1heFldIHF1YWQgYm91bmRzIGZvciBlYWNoIGdseXBoLlxuICAgKiBAcHJvcGVydHkge0Zsb2F0MzJBcnJheX0gZ2x5cGhBdGxhc0luZGljZXMgLSBMaXN0IGhvbGRpbmcgZWFjaCBnbHlwaCdzIGluZGV4IGluIHRoZSBTREYgYXRsYXMuXG4gICAqIEBwcm9wZXJ0eSB7VWludDhBcnJheX0gW2dseXBoQ29sb3JzXSAtIExpc3QgaG9sZGluZyBlYWNoIGdseXBoJ3MgW3IsIGcsIGJdIGNvbG9yLCBpZiBgY29sb3JSYW5nZXNgIHdhcyBzdXBwbGllZC5cbiAgICogQHByb3BlcnR5IHtGbG9hdDMyQXJyYXl9IFtjYXJldFBvc2l0aW9uc10gLSBBIGxpc3Qgb2YgY2FyZXQgcG9zaXRpb25zIGZvciBhbGwgZ2x5cGhzOyB0aGlzIGlzXG4gICAqICAgICAgICAgICB0aGUgYm90dG9tIFt4LHldIG9mIHRoZSBjdXJzb3IgcG9zaXRpb24gYmVmb3JlIGVhY2ggY2hhciwgcGx1cyBvbmUgYWZ0ZXIgdGhlIGxhc3QgY2hhci5cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtjYXJldEhlaWdodF0gLSBBbiBhcHByb3ByaWF0ZSBoZWlnaHQgZm9yIGFsbCBzZWxlY3Rpb24gY2FyZXRzLlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gYXNjZW5kZXIgLSBUaGUgZm9udCdzIGFzY2VuZGVyIG1ldHJpYy5cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRlc2NlbmRlciAtIFRoZSBmb250J3MgZGVzY2VuZGVyIG1ldHJpYy5cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IGxpbmVIZWlnaHQgLSBUaGUgZmluYWwgY29tcHV0ZWQgbGluZUhlaWdodCBtZWFzdXJlbWVudC5cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHRvcEJhc2VsaW5lIC0gVGhlIHkgcG9zaXRpb24gb2YgdGhlIHRvcCBsaW5lJ3MgYmFzZWxpbmUuXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gdG90YWxCb3VuZHMgLSBUaGUgdG90YWwgW21pblgsIG1pblksIG1heFgsIG1heFldIHJlY3QgaW5jbHVkaW5nIGFsbCBnbHlwaFxuICAgKiAgICAgICAgICAgcXVhZCBib3VuZHM7IHRoaXMgd2lsbCBiZSBzbGlnaHRseSBsYXJnZXIgdGhhbiB0aGUgYWN0dWFsIGdseXBoIHBhdGggZWRnZXMgZHVlIHRvIFNERiBwYWRkaW5nLlxuICAgKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IHRvdGFsQmxvY2tTaXplIC0gVGhlIFt3aWR0aCwgaGVpZ2h0XSBvZiB0aGUgdGV4dCBibG9jazsgdGhpcyBkb2VzIG5vdCBpbmNsdWRlXG4gICAqICAgICAgICAgICBleHRyYSBTREYgcGFkZGluZyBzbyBpdCBpcyBhY2N1cmF0ZSB0byB1c2UgZm9yIG1lYXN1cmVtZW50LlxuICAgKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IGNodW5rZWRCb3VuZHMgLSBMaXN0IG9mIGJvdW5kaW5nIHJlY3RzIGZvciBlYWNoIGNvbnNlY3V0aXZlIHNldCBvZiBOIGdseXBocyxcbiAgICogICAgICAgICAgIGluIHRoZSBmb3JtYXQgYHtzdGFydDpOLCBlbmQ6TiwgcmVjdDpbbWluWCwgbWluWSwgbWF4WCwgbWF4WV19YC5cbiAgICogQHByb3BlcnR5IHtvYmplY3R9IHRpbWluZ3MgLSBUaW1pbmcgaW5mbyBmb3IgdmFyaW91cyBwYXJ0cyBvZiB0aGUgcmVuZGVyaW5nIGxvZ2ljIGluY2x1ZGluZyBTREZcbiAgICogICAgICAgICAgIGdlbmVyYXRpb24sIGxheW91dCwgZXRjLlxuICAgKiBAZnJvemVuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAY2FsbGJhY2sgZ2V0VGV4dFJlbmRlckluZm9+Y2FsbGJhY2tcbiAgICogQHBhcmFtIHtUcm9pa2FUZXh0UmVuZGVySW5mb30gdGV4dFJlbmRlckluZm9cbiAgICovXG5cbiAgLyoqXG4gICAqIE1haW4gZW50cnkgcG9pbnQgZm9yIHJlcXVlc3RpbmcgdGhlIGRhdGEgbmVlZGVkIHRvIHJlbmRlciBhIHRleHQgc3RyaW5nIHdpdGggZ2l2ZW4gZm9udCBwYXJhbWV0ZXJzLlxuICAgKiBUaGlzIGlzIGFuIGFzeW5jaHJvbm91cyBjYWxsLCBwZXJmb3JtaW5nIG1vc3Qgb2YgdGhlIGxvZ2ljIGluIGEgd2ViIHdvcmtlciB0aHJlYWQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gICAqIEBwYXJhbSB7Z2V0VGV4dFJlbmRlckluZm9+Y2FsbGJhY2t9IGNhbGxiYWNrXG4gICAqL1xuICBmdW5jdGlvbiBnZXRUZXh0UmVuZGVySW5mbyhhcmdzLCBjYWxsYmFjaykge1xuICAgIGFyZ3MgPSBhc3NpZ24oe30sIGFyZ3MpO1xuXG4gICAgLy8gQXBwbHkgZGVmYXVsdCBmb250IGhlcmUgdG8gYXZvaWQgYSAnbnVsbCcgYXRsYXMsIGFuZCBjb252ZXJ0IHJlbGF0aXZlXG4gICAgLy8gVVJMcyB0byBhYnNvbHV0ZSBzbyB0aGV5IGNhbiBiZSByZXNvbHZlZCBpbiB0aGUgd29ya2VyXG4gICAgYXJncy5mb250ID0gdG9BYnNvbHV0ZVVSTChhcmdzLmZvbnQgfHwgQ09ORklHLmRlZmF1bHRGb250VVJMKTtcblxuICAgIC8vIE5vcm1hbGl6ZSB0ZXh0IHRvIGEgc3RyaW5nXG4gICAgYXJncy50ZXh0ID0gJycgKyBhcmdzLnRleHQ7XG5cbiAgICBhcmdzLnNkZkdseXBoU2l6ZSA9IGFyZ3Muc2RmR2x5cGhTaXplIHx8IENPTkZJRy5zZGZHbHlwaFNpemU7XG5cbiAgICAvLyBOb3JtYWxpemUgY29sb3JzXG4gICAgaWYgKGFyZ3MuY29sb3JSYW5nZXMgIT0gbnVsbCkge1xuICAgICAgdmFyIGNvbG9ycyA9IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIGFyZ3MuY29sb3JSYW5nZXMpIHtcbiAgICAgICAgaWYgKGFyZ3MuY29sb3JSYW5nZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIHZhciB2YWwgPSBhcmdzLmNvbG9yUmFuZ2VzW2tleV07XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB2YWwgPSB0ZW1wQ29sb3Iuc2V0KHZhbCkuZ2V0SGV4KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbG9yc1trZXldID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcmdzLmNvbG9yUmFuZ2VzID0gY29sb3JzO1xuICAgIH1cblxuICAgIE9iamVjdC5mcmVlemUoYXJncyk7XG5cbiAgICAvLyBJbml0IHRoZSBhdGxhcyBmb3IgdGhpcyBmb250IGlmIG5lZWRlZFxuICAgIHZhciB0ZXh0dXJlV2lkdGggPSBDT05GSUcudGV4dHVyZVdpZHRoO1xuICAgIHZhciBzZGZHbHlwaFNpemUgPSBhcmdzLnNkZkdseXBoU2l6ZTtcbiAgICB2YXIgYXRsYXNLZXkgPSAoYXJncy5mb250KSArIFwiQFwiICsgc2RmR2x5cGhTaXplO1xuICAgIHZhciBhdGxhcyA9IGF0bGFzZXNbYXRsYXNLZXldO1xuICAgIGlmICghYXRsYXMpIHtcbiAgICAgIGF0bGFzID0gYXRsYXNlc1thdGxhc0tleV0gPSB7XG4gICAgICAgIHNkZlRleHR1cmU6IG5ldyB0aHJlZS5EYXRhVGV4dHVyZShcbiAgICAgICAgICBuZXcgVWludDhBcnJheShzZGZHbHlwaFNpemUgKiB0ZXh0dXJlV2lkdGgpLFxuICAgICAgICAgIHRleHR1cmVXaWR0aCxcbiAgICAgICAgICBzZGZHbHlwaFNpemUsXG4gICAgICAgICAgdGhyZWUuTHVtaW5hbmNlRm9ybWF0LFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICB0aHJlZS5MaW5lYXJGaWx0ZXIsXG4gICAgICAgICAgdGhyZWUuTGluZWFyRmlsdGVyXG4gICAgICAgIClcbiAgICAgIH07XG4gICAgICBhdGxhcy5zZGZUZXh0dXJlLmZvbnQgPSBhcmdzLmZvbnQ7XG4gICAgfVxuXG4gICAgLy8gSXNzdWUgcmVxdWVzdCB0byB0aGUgRm9udFByb2Nlc3NvciBpbiB0aGUgd29ya2VyXG4gICAgcHJvY2Vzc0luV29ya2VyKGFyZ3MpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgLy8gSWYgdGhlIHJlc3BvbnNlIGhhcyBuZXdHbHlwaHMsIGNvcHkgdGhlbSBpbnRvIHRoZSBhdGxhcyB0ZXh0dXJlIGF0IHRoZSBzcGVjaWZpZWQgaW5kaWNlc1xuICAgICAgaWYgKHJlc3VsdC5uZXdHbHlwaFNERnMpIHtcbiAgICAgICAgcmVzdWx0Lm5ld0dseXBoU0RGcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICB2YXIgdGV4dHVyZURhdGEgPSByZWYudGV4dHVyZURhdGE7XG4gICAgICAgICAgdmFyIGF0bGFzSW5kZXggPSByZWYuYXRsYXNJbmRleDtcblxuICAgICAgICAgIHZhciB0ZXhJbWcgPSBhdGxhcy5zZGZUZXh0dXJlLmltYWdlO1xuXG4gICAgICAgICAgLy8gR3JvdyB0aGUgdGV4dHVyZSBieSBwb3dlciBvZiAyIGlmIG5lZWRlZFxuICAgICAgICAgIHdoaWxlICh0ZXhJbWcuZGF0YS5sZW5ndGggPCAoYXRsYXNJbmRleCArIDEpICogc2RmR2x5cGhTaXplICogc2RmR2x5cGhTaXplKSB7XG4gICAgICAgICAgICB2YXIgYmlnZ2VyQXJyYXkgPSBuZXcgVWludDhBcnJheSh0ZXhJbWcuZGF0YS5sZW5ndGggKiAyKTtcbiAgICAgICAgICAgIGJpZ2dlckFycmF5LnNldCh0ZXhJbWcuZGF0YSk7XG4gICAgICAgICAgICB0ZXhJbWcuZGF0YSA9IGJpZ2dlckFycmF5O1xuICAgICAgICAgICAgdGV4SW1nLmhlaWdodCAqPSAyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEluc2VydCB0aGUgbmV3IGdseXBoJ3MgZGF0YSBpbnRvIHRoZSBmdWxsIHRleHR1cmUgaW1hZ2UgYXQgdGhlIGNvcnJlY3Qgb2Zmc2V0c1xuICAgICAgICAgIHZhciBjb2xzID0gdGV4SW1nLndpZHRoIC8gc2RmR2x5cGhTaXplO1xuICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgc2RmR2x5cGhTaXplOyB5KyspIHtcbiAgICAgICAgICAgIHZhciBzcmNTdGFydEluZGV4ID0geSAqIHNkZkdseXBoU2l6ZTtcbiAgICAgICAgICAgIHZhciB0Z3RTdGFydEluZGV4ID0gdGV4SW1nLndpZHRoICogc2RmR2x5cGhTaXplICogTWF0aC5mbG9vcihhdGxhc0luZGV4IC8gY29scykgLy9mdWxsIHJvd3NcbiAgICAgICAgICAgICAgKyAoYXRsYXNJbmRleCAlIGNvbHMpICogc2RmR2x5cGhTaXplIC8vcGFydGlhbCByb3dcbiAgICAgICAgICAgICAgKyAoeSAqIHRleEltZy53aWR0aCk7IC8vcm93IHdpdGhpbiBnbHlwaFxuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBzZGZHbHlwaFNpemU7IHgrKykge1xuICAgICAgICAgICAgICB0ZXhJbWcuZGF0YVt0Z3RTdGFydEluZGV4ICsgeF0gPSB0ZXh0dXJlRGF0YVtzcmNTdGFydEluZGV4ICsgeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYXRsYXMuc2RmVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIEludm9rZSBjYWxsYmFjayB3aXRoIHRoZSB0ZXh0IGxheW91dCBhcnJheXMgYW5kIHVwZGF0ZWQgdGV4dHVyZVxuICAgICAgY2FsbGJhY2soT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIHBhcmFtZXRlcnM6IGFyZ3MsXG4gICAgICAgIHNkZlRleHR1cmU6IGF0bGFzLnNkZlRleHR1cmUsXG4gICAgICAgIHNkZkdseXBoU2l6ZTogc2RmR2x5cGhTaXplLFxuICAgICAgICBzZGZNaW5EaXN0YW5jZVBlcmNlbnQ6IFNERl9ESVNUQU5DRV9QRVJDRU5ULFxuICAgICAgICBnbHlwaEJvdW5kczogcmVzdWx0LmdseXBoQm91bmRzLFxuICAgICAgICBnbHlwaEF0bGFzSW5kaWNlczogcmVzdWx0LmdseXBoQXRsYXNJbmRpY2VzLFxuICAgICAgICBnbHlwaENvbG9yczogcmVzdWx0LmdseXBoQ29sb3JzLFxuICAgICAgICBjYXJldFBvc2l0aW9uczogcmVzdWx0LmNhcmV0UG9zaXRpb25zLFxuICAgICAgICBjYXJldEhlaWdodDogcmVzdWx0LmNhcmV0SGVpZ2h0LFxuICAgICAgICBjaHVua2VkQm91bmRzOiByZXN1bHQuY2h1bmtlZEJvdW5kcyxcbiAgICAgICAgYXNjZW5kZXI6IHJlc3VsdC5hc2NlbmRlcixcbiAgICAgICAgZGVzY2VuZGVyOiByZXN1bHQuZGVzY2VuZGVyLFxuICAgICAgICBsaW5lSGVpZ2h0OiByZXN1bHQubGluZUhlaWdodCxcbiAgICAgICAgdG9wQmFzZWxpbmU6IHJlc3VsdC50b3BCYXNlbGluZSxcbiAgICAgICAgdG90YWxCb3VuZHM6IHJlc3VsdC50b3RhbEJvdW5kcyxcbiAgICAgICAgdG90YWxCbG9ja1NpemU6IHJlc3VsdC50b3RhbEJsb2NrU2l6ZSxcbiAgICAgICAgdGltaW5nczogcmVzdWx0LnRpbWluZ3NcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFByZWxvYWQgYSBnaXZlbiBmb250IGFuZCBvcHRpb25hbGx5IHByZS1nZW5lcmF0ZSBnbHlwaCBTREZzIGZvciBvbmUgb3IgbW9yZSBjaGFyYWN0ZXIgc2VxdWVuY2VzLlxuICAgKiBUaGlzIGNhbiBiZSB1c2VmdWwgdG8gYXZvaWQgbG9uZyBwYXVzZXMgd2hlbiBmaXJzdCBzaG93aW5nIHRleHQgaW4gYSBzY2VuZSwgYnkgcHJlbG9hZGluZyB0aGVcbiAgICogbmVlZGVkIGZvbnRzIGFuZCBnbHlwaHMgdXAgZnJvbnQgYWxvbmcgd2l0aCBvdGhlciBhc3NldHMuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmZvbnQgLSBVUkwgb2YgdGhlIGZvbnQgZmlsZSB0byBwcmVsb2FkLiBJZiBub3QgZ2l2ZW4sIHRoZSBkZWZhdWx0IGZvbnQgd2lsbFxuICAgKiAgICAgICAgYmUgbG9hZGVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gb3B0aW9ucy5jaGFyYWN0ZXJzIC0gT25lIG9yIG1vcmUgY2hhcmFjdGVyIHNlcXVlbmNlcyBmb3Igd2hpY2ggdG8gcHJlLVxuICAgKiAgICAgICAgZ2VuZXJhdGUgZ2x5cGggU0RGcy4gTm90ZSB0aGF0IHRoaXMgd2lsbCBob25vciBsaWdhdHVyZSBzdWJzdGl0dXRpb24sIHNvIHlvdSBtYXkgbmVlZFxuICAgKiAgICAgICAgdG8gc3BlY2lmeSBsaWdhdHVyZSBzZXF1ZW5jZXMgaW4gYWRkaXRpb24gdG8gdGhlaXIgaW5kaXZpZHVhbCBjaGFyYWN0ZXJzIHRvIGdldCBhbGxcbiAgICogICAgICAgIHBvc3NpYmxlIGdseXBocywgZS5nLiBgW1widFwiLCBcImhcIiwgXCJ0aFwiXWAgdG8gZ2V0IHRoZSBcInRcIiBhbmQgXCJoXCIgZ2x5cGhzIHBsdXMgdGhlIFwidGhcIiBsaWdhdHVyZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuc2RmR2x5cGhTaXplIC0gVGhlIHNpemUgYXQgd2hpY2ggdG8gcHJlcmVuZGVyIHRoZSBTREYgdGV4dHVyZXMgZm9yIHRoZVxuICAgKiAgICAgICAgc3BlY2lmaWVkIGBjaGFyYWN0ZXJzYC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgcHJlbG9hZGluZyBpcyBjb21wbGV0ZS5cbiAgICovXG4gIGZ1bmN0aW9uIHByZWxvYWRGb250KHJlZiwgY2FsbGJhY2spIHtcbiAgICB2YXIgZm9udCA9IHJlZi5mb250O1xuICAgIHZhciBjaGFyYWN0ZXJzID0gcmVmLmNoYXJhY3RlcnM7XG4gICAgdmFyIHNkZkdseXBoU2l6ZSA9IHJlZi5zZGZHbHlwaFNpemU7XG5cbiAgICB2YXIgdGV4dCA9IEFycmF5LmlzQXJyYXkoY2hhcmFjdGVycykgPyBjaGFyYWN0ZXJzLmpvaW4oJ1xcbicpIDogJycgKyBjaGFyYWN0ZXJzO1xuICAgIGdldFRleHRSZW5kZXJJbmZvKHsgZm9udDogZm9udCwgc2RmR2x5cGhTaXplOiBzZGZHbHlwaFNpemUsIHRleHQ6IHRleHQgfSwgY2FsbGJhY2spO1xuICB9XG5cblxuICAvLyBMb2NhbCBhc3NpZ24gaW1wbCBzbyB3ZSBkb24ndCBoYXZlIHRvIGltcG9ydCB0cm9pa2EtY29yZVxuICBmdW5jdGlvbiBhc3NpZ24odG9PYmosIGZyb21PYmopIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZnJvbU9iaikge1xuICAgICAgaWYgKGZyb21PYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB0b09ialtrZXldID0gZnJvbU9ialtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG9PYmpcbiAgfVxuXG4gIC8vIFV0aWxpdHkgZm9yIG1ha2luZyBVUkxzIGFic29sdXRlXG4gIHZhciBsaW5rRWw7XG4gIGZ1bmN0aW9uIHRvQWJzb2x1dGVVUkwocGF0aCkge1xuICAgIGlmICghbGlua0VsKSB7XG4gICAgICBsaW5rRWwgPSB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnID8ge30gOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgfVxuICAgIGxpbmtFbC5ocmVmID0gcGF0aDtcbiAgICByZXR1cm4gbGlua0VsLmhyZWZcbiAgfVxuXG5cbiAgdmFyIGZvbnRQcm9jZXNzb3JXb3JrZXJNb2R1bGUgPSB0cm9pa2FXb3JrZXJVdGlscy5kZWZpbmVXb3JrZXJNb2R1bGUoe1xuICAgIG5hbWU6ICdGb250UHJvY2Vzc29yJyxcbiAgICBkZXBlbmRlbmNpZXM6IFtcbiAgICAgIENPTkZJRyxcbiAgICAgIFNERl9ESVNUQU5DRV9QRVJDRU5ULFxuICAgICAgd29ya2VyTW9kdWxlLFxuICAgICAgY3JlYXRlR2x5cGhTZWdtZW50c1F1YWR0cmVlLFxuICAgICAgY3JlYXRlU0RGR2VuZXJhdG9yLFxuICAgICAgY3JlYXRlRm9udFByb2Nlc3NvclxuICAgIF0sXG4gICAgaW5pdDogZnVuY3Rpb24gaW5pdChjb25maWcsIHNkZkRpc3RhbmNlUGVyY2VudCwgZm9udFBhcnNlciwgY3JlYXRlR2x5cGhTZWdtZW50c1F1YWR0cmVlLCBjcmVhdGVTREZHZW5lcmF0b3IsIGNyZWF0ZUZvbnRQcm9jZXNzb3IpIHtcbiAgICAgIHZhciBzZGZHZW5lcmF0b3IgPSBjcmVhdGVTREZHZW5lcmF0b3IoXG4gICAgICAgIGNyZWF0ZUdseXBoU2VnbWVudHNRdWFkdHJlZSxcbiAgICAgICAge1xuICAgICAgICAgIHNkZkRpc3RhbmNlUGVyY2VudDogc2RmRGlzdGFuY2VQZXJjZW50XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gY3JlYXRlRm9udFByb2Nlc3Nvcihmb250UGFyc2VyLCBzZGZHZW5lcmF0b3IsIHtcbiAgICAgICAgZGVmYXVsdEZvbnRVcmw6IGNvbmZpZy5kZWZhdWx0Rm9udFVSTFxuICAgICAgfSlcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBwcm9jZXNzSW5Xb3JrZXIgPSB0cm9pa2FXb3JrZXJVdGlscy5kZWZpbmVXb3JrZXJNb2R1bGUoe1xuICAgIG5hbWU6ICdUZXh0QnVpbGRlcicsXG4gICAgZGVwZW5kZW5jaWVzOiBbZm9udFByb2Nlc3Nvcldvcmtlck1vZHVsZSwgdHJvaWthV29ya2VyVXRpbHMuVGhlbmFibGVXb3JrZXJNb2R1bGVdLFxuICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQoZm9udFByb2Nlc3NvciwgVGhlbmFibGUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciB0aGVuYWJsZSA9IG5ldyBUaGVuYWJsZSgpO1xuICAgICAgICBmb250UHJvY2Vzc29yLnByb2Nlc3MoYXJncywgdGhlbmFibGUucmVzb2x2ZSk7XG4gICAgICAgIHJldHVybiB0aGVuYWJsZVxuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0VHJhbnNmZXJhYmxlczogZnVuY3Rpb24gZ2V0VHJhbnNmZXJhYmxlcyhyZXN1bHQpIHtcbiAgICAgIC8vIE1hcmsgYXJyYXkgYnVmZmVycyBhcyB0cmFuc2ZlcmFibGUgdG8gYXZvaWQgY2xvbmluZyBkdXJpbmcgcG9zdE1lc3NhZ2VcbiAgICAgIHZhciB0cmFuc2ZlcmFibGVzID0gW1xuICAgICAgICByZXN1bHQuZ2x5cGhCb3VuZHMuYnVmZmVyLFxuICAgICAgICByZXN1bHQuZ2x5cGhBdGxhc0luZGljZXMuYnVmZmVyXG4gICAgICBdO1xuICAgICAgaWYgKHJlc3VsdC5jYXJldFBvc2l0aW9ucykge1xuICAgICAgICB0cmFuc2ZlcmFibGVzLnB1c2gocmVzdWx0LmNhcmV0UG9zaXRpb25zLmJ1ZmZlcik7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0Lm5ld0dseXBoU0RGcykge1xuICAgICAgICByZXN1bHQubmV3R2x5cGhTREZzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICB0cmFuc2ZlcmFibGVzLnB1c2goZC50ZXh0dXJlRGF0YS5idWZmZXIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cmFuc2ZlcmFibGVzXG4gICAgfVxuICB9KTtcblxuICB2YXIgdGVtcGxhdGVHZW9tZXRyaWVzID0ge307XG4gIGZ1bmN0aW9uIGdldFRlbXBsYXRlR2VvbWV0cnkoZGV0YWlsKSB7XG4gICAgdmFyIGdlb20gPSB0ZW1wbGF0ZUdlb21ldHJpZXNbZGV0YWlsXTtcbiAgICBpZiAoIWdlb20pIHtcbiAgICAgIGdlb20gPSB0ZW1wbGF0ZUdlb21ldHJpZXNbZGV0YWlsXSA9IG5ldyB0aHJlZS5QbGFuZUJ1ZmZlckdlb21ldHJ5KDEsIDEsIGRldGFpbCwgZGV0YWlsKS50cmFuc2xhdGUoMC41LCAwLjUsIDApO1xuICAgIH1cbiAgICByZXR1cm4gZ2VvbVxuICB9XG4gIHZhciB0ZW1wVmVjMyA9IG5ldyB0aHJlZS5WZWN0b3IzKCk7XG5cbiAgdmFyIGdseXBoQm91bmRzQXR0ck5hbWUgPSAnYVRyb2lrYUdseXBoQm91bmRzJztcbiAgdmFyIGdseXBoSW5kZXhBdHRyTmFtZSA9ICdhVHJvaWthR2x5cGhJbmRleCc7XG4gIHZhciBnbHlwaENvbG9yQXR0ck5hbWUgPSAnYVRyb2lrYUdseXBoQ29sb3InO1xuXG5cblxuICAvKipcbiAgQGNsYXNzIEdseXBoc0dlb21ldHJ5XG5cbiAgQSBzcGVjaWFsaXplZCBHZW9tZXRyeSBmb3IgcmVuZGVyaW5nIGEgc2V0IG9mIHRleHQgZ2x5cGhzLiBVc2VzIEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IHRvXG4gIHJlbmRlciB0aGUgZ2x5cGhzIHVzaW5nIEdQVSBpbnN0YW5jaW5nIG9mIGEgc2luZ2xlIHF1YWQsIHJhdGhlciB0aGFuIGNvbnN0cnVjdGluZyBhIHdob2xlXG4gIGdlb21ldHJ5IHdpdGggdmVydGljZXMsIGZvciBtdWNoIHNtYWxsZXIgYXR0cmlidXRlIGFycmF5YnVmZmVycyBhY2NvcmRpbmcgdG8gdGhpcyBtYXRoOlxuXG4gICAgV2hlcmUgTiA9IG51bWJlciBvZiBnbHlwaHMuLi5cblxuICAgIEluc3RhbmNlZDpcbiAgICAtIHBvc2l0aW9uOiA0ICogM1xuICAgIC0gaW5kZXg6IDIgKiAzXG4gICAgLSBub3JtYWw6IDQgKiAzXG4gICAgLSB1djogNCAqIDJcbiAgICAtIGdseXBoIHgveSBib3VuZHM6IE4gKiA0XG4gICAgLSBnbHlwaCBpbmRpY2VzOiBOICogMVxuICAgID0gNU4gKyAzOFxuXG4gICAgTm9uLWluc3RhbmNlZDpcbiAgICAtIHBvc2l0aW9uOiBOICogNCAqIDNcbiAgICAtIGluZGV4OiBOICogMiAqIDNcbiAgICAtIG5vcm1hbDogTiAqIDQgKiAzXG4gICAgLSB1djogTiAqIDQgKiAyXG4gICAgLSBnbHlwaCBpbmRpY2VzOiBOICogMVxuICAgID0gMzlOXG5cbiAgQSBkb3duc2lkZSBvZiB0aGlzIGlzIHRoZSByYXJlLWJ1dC1wb3NzaWJsZSBsYWNrIG9mIHRoZSBpbnN0YW5jZWQgYXJyYXlzIGV4dGVuc2lvbixcbiAgd2hpY2ggd2UgY291bGQgcG90ZW50aWFsbHkgd29yayBhcm91bmQgd2l0aCBhIGZhbGxiYWNrIG5vbi1pbnN0YW5jZWQgaW1wbGVtZW50YXRpb24uXG5cbiAgKi9cbiAgdmFyIEdseXBoc0dlb21ldHJ5ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkpIHtcbiAgICBmdW5jdGlvbiBHbHlwaHNHZW9tZXRyeSgpIHtcbiAgICAgIEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LmNhbGwodGhpcyk7XG5cbiAgICAgIHRoaXMuZGV0YWlsID0gMTtcblxuICAgICAgLy8gUHJlYWxsb2NhdGUgemVyby1yYWRpdXMgYm91bmRpbmcgc3BoZXJlXG4gICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IHRocmVlLlNwaGVyZSgpO1xuICAgIH1cblxuICAgIGlmICggSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgKSBHbHlwaHNHZW9tZXRyeS5fX3Byb3RvX18gPSBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeTtcbiAgICBHbHlwaHNHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSAmJiBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcbiAgICBHbHlwaHNHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHbHlwaHNHZW9tZXRyeTtcblxuICAgIHZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGRldGFpbDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4gICAgR2x5cGhzR2VvbWV0cnkucHJvdG90eXBlLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSA9IGZ1bmN0aW9uIGNvbXB1dGVCb3VuZGluZ1NwaGVyZSAoKSB7XG4gICAgICAvLyBOby1vcDsgd2UnbGwgc3luYyB0aGUgYm91bmRpbmdTcGhlcmUgcHJvYWN0aXZlbHkgaW4gYHVwZGF0ZUdseXBoc2AuXG4gICAgfTtcblxuICAgIHByb3RvdHlwZUFjY2Vzc29ycy5kZXRhaWwuc2V0ID0gZnVuY3Rpb24gKGRldGFpbCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIGlmIChkZXRhaWwgIT09IHRoaXMuX2RldGFpbCkge1xuICAgICAgICB0aGlzLl9kZXRhaWwgPSBkZXRhaWw7XG4gICAgICAgIGlmICh0eXBlb2YgZGV0YWlsICE9PSAnbnVtYmVyJyB8fCBkZXRhaWwgPCAxKSB7XG4gICAgICAgICAgZGV0YWlsID0gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHBsID0gZ2V0VGVtcGxhdGVHZW9tZXRyeShkZXRhaWwpXG4gICAgICAgIDtbJ3Bvc2l0aW9uJywgJ25vcm1hbCcsICd1diddLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICB0aGlzJDEuYXR0cmlidXRlc1thdHRyXSA9IHRwbC5hdHRyaWJ1dGVzW2F0dHJdLmNsb25lKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldEluZGV4KHRwbC5nZXRJbmRleCgpLmNsb25lKCkpO1xuICAgICAgfVxuICAgIH07XG4gICAgcHJvdG90eXBlQWNjZXNzb3JzLmRldGFpbC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGV0YWlsXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgZ2VvbWV0cnkgZm9yIGEgbmV3IHNldCBvZiBnbHlwaHMuXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGdseXBoQm91bmRzIC0gQW4gYXJyYXkgaG9sZGluZyB0aGUgcGxhbmFyIGJvdW5kcyBmb3IgYWxsIGdseXBoc1xuICAgICAqICAgICAgICB0byBiZSByZW5kZXJlZCwgNCBlbnRyaWVzIGZvciBlYWNoIGdseXBoOiB4MSx4Mix5MSx5MVxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBnbHlwaEF0bGFzSW5kaWNlcyAtIEFuIGFycmF5IGhvbGRpbmcgdGhlIGluZGV4IG9mIGVhY2ggZ2x5cGggd2l0aGluXG4gICAgICogICAgICAgIHRoZSBTREYgYXRsYXMgdGV4dHVyZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0b3RhbEJvdW5kcyAtIEFuIGFycmF5IGhvbGRpbmcgdGhlIFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSBhY3Jvc3MgYWxsIGdseXBoc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjaHVua2VkQm91bmRzXSAtIEFuIGFycmF5IG9mIG9iamVjdHMgZGVzY3JpYmluZyBib3VuZHMgZm9yIGVhY2ggY2h1bmsgb2YgTlxuICAgICAqICAgICAgICBjb25zZWN1dGl2ZSBnbHlwaHM6IGB7c3RhcnQ6TiwgZW5kOk4sIHJlY3Q6W21pblgsIG1pblksIG1heFgsIG1heFldfWAuIFRoaXMgY2FuIGJlXG4gICAgICogICAgICAgIHVzZWQgd2l0aCBgYXBwbHlDbGlwUmVjdGAgdG8gY2hvb3NlIGFuIG9wdGltaXplZCBgaW5zdGFuY2VDb3VudGAuXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBbZ2x5cGhDb2xvcnNdIC0gQW4gYXJyYXkgaG9sZGluZyByLGcsYiB2YWx1ZXMgZm9yIGVhY2ggZ2x5cGguXG4gICAgICovXG4gICAgR2x5cGhzR2VvbWV0cnkucHJvdG90eXBlLnVwZGF0ZUdseXBocyA9IGZ1bmN0aW9uIHVwZGF0ZUdseXBocyAoZ2x5cGhCb3VuZHMsIGdseXBoQXRsYXNJbmRpY2VzLCB0b3RhbEJvdW5kcywgY2h1bmtlZEJvdW5kcywgZ2x5cGhDb2xvcnMpIHtcbiAgICAgIC8vIFVwZGF0ZSB0aGUgaW5zdGFuY2UgYXR0cmlidXRlc1xuICAgICAgdXBkYXRlQnVmZmVyQXR0cih0aGlzLCBnbHlwaEJvdW5kc0F0dHJOYW1lLCBnbHlwaEJvdW5kcywgNCk7XG4gICAgICB1cGRhdGVCdWZmZXJBdHRyKHRoaXMsIGdseXBoSW5kZXhBdHRyTmFtZSwgZ2x5cGhBdGxhc0luZGljZXMsIDEpO1xuICAgICAgdXBkYXRlQnVmZmVyQXR0cih0aGlzLCBnbHlwaENvbG9yQXR0ck5hbWUsIGdseXBoQ29sb3JzLCAzKTtcbiAgICAgIHRoaXMuX2NodW5rZWRCb3VuZHMgPSBjaHVua2VkQm91bmRzO1xuICAgICAgc2V0SW5zdGFuY2VDb3VudCh0aGlzLCBnbHlwaEF0bGFzSW5kaWNlcy5sZW5ndGgpO1xuXG4gICAgICAvLyBVcGRhdGUgdGhlIGJvdW5kaW5nU3BoZXJlIGJhc2VkIG9uIHRoZSB0b3RhbCBib3VuZHNcbiAgICAgIHZhciBzcGhlcmUgPSB0aGlzLmJvdW5kaW5nU3BoZXJlO1xuICAgICAgc3BoZXJlLmNlbnRlci5zZXQoXG4gICAgICAgICh0b3RhbEJvdW5kc1swXSArIHRvdGFsQm91bmRzWzJdKSAvIDIsXG4gICAgICAgICh0b3RhbEJvdW5kc1sxXSArIHRvdGFsQm91bmRzWzNdKSAvIDIsXG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgICBzcGhlcmUucmFkaXVzID0gc3BoZXJlLmNlbnRlci5kaXN0YW5jZVRvKHRlbXBWZWMzLnNldCh0b3RhbEJvdW5kc1swXSwgdG90YWxCb3VuZHNbMV0sIDApKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBjbGlwcGluZyByZWN0LCBhbmQgdGhlIGNodW5rZWRCb3VuZHMgZnJvbSB0aGUgbGFzdCB1cGRhdGVHbHlwaHMgY2FsbCwgY2hvb3NlIHRoZSBsb3dlc3RcbiAgICAgKiBgaW5zdGFuY2VDb3VudGAgdGhhdCB3aWxsIHNob3cgYWxsIGdseXBocyB3aXRoaW4gdGhlIGNsaXBwZWQgdmlldy4gVGhpcyBpcyBhbiBvcHRpbWl6YXRpb25cbiAgICAgKiBmb3IgbG9uZyBibG9ja3Mgb2YgdGV4dCB0aGF0IGFyZSBjbGlwcGVkLCB0byBza2lwIHZlcnRleCBzaGFkZXIgZXZhbHVhdGlvbiBmb3IgZ2x5cGhzIHRoYXQgd291bGRcbiAgICAgKiBiZSBjbGlwcGVkIGFueXdheS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBzaW5jZSBgZHJhd0VsZW1lbnRzSW5zdGFuY2VkW0FOR0xFXWAgb25seSBhY2NlcHRzIGFuIGluc3RhbmNlIGNvdW50IGFuZCBub3QgYSBzdGFydGluZ1xuICAgICAqIG9mZnNldCwgdGhpcyBvcHRpbWl6YXRpb24gYmVjb21lcyBsZXNzIGVmZmVjdGl2ZSBhcyB0aGUgY2xpcFJlY3QgbW92ZXMgY2xvc2VyIHRvIHRoZSBlbmQgb2YgdGhlXG4gICAgICogdGV4dCBibG9jay4gV2UgY291bGQgZml4IHRoYXQgYnkgc3dpdGNoaW5nIGZyb20gaW5zdGFuY2luZyB0byBhIGZ1bGwgZ2VvbWV0cnkgd2l0aCBhIGRyYXdSYW5nZSxcbiAgICAgKiBidXQgYXQgdGhlIGV4cGVuc2Ugb2YgbXVjaCBsYXJnZXIgYXR0cmlidXRlIGJ1ZmZlcnMgKHNlZSBjbGFzc2RvYyBhYm92ZS4pXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1ZlY3RvcjR9IGNsaXBSZWN0XG4gICAgICovXG4gICAgR2x5cGhzR2VvbWV0cnkucHJvdG90eXBlLmFwcGx5Q2xpcFJlY3QgPSBmdW5jdGlvbiBhcHBseUNsaXBSZWN0IChjbGlwUmVjdCkge1xuICAgICAgdmFyIGNvdW50ID0gdGhpcy5nZXRBdHRyaWJ1dGUoZ2x5cGhJbmRleEF0dHJOYW1lKS5jb3VudDtcbiAgICAgIHZhciBjaHVua3MgPSB0aGlzLl9jaHVua2VkQm91bmRzO1xuICAgICAgaWYgKGNodW5rcykge1xuICAgICAgICBmb3IgKHZhciBpID0gY2h1bmtzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgIGNvdW50ID0gY2h1bmtzW2ldLmVuZDtcbiAgICAgICAgICB2YXIgcmVjdCA9IGNodW5rc1tpXS5yZWN0O1xuICAgICAgICAgIC8vIG5vdGU6IGJvdGggcmVjdHMgYXJlIGwtYi1yLXRcbiAgICAgICAgICBpZiAocmVjdFsxXSA8IGNsaXBSZWN0LncgJiYgcmVjdFszXSA+IGNsaXBSZWN0LnkgJiYgcmVjdFswXSA8IGNsaXBSZWN0LnogJiYgcmVjdFsyXSA+IGNsaXBSZWN0LngpIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZXRJbnN0YW5jZUNvdW50KHRoaXMsIGNvdW50KTtcbiAgICB9O1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEdseXBoc0dlb21ldHJ5LnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbiAgICByZXR1cm4gR2x5cGhzR2VvbWV0cnk7XG4gIH0odGhyZWUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkpKTtcblxuICAvLyBDb21wYXQgZm9yIHByZSByMTA5OlxuICBpZiAoIUdseXBoc0dlb21ldHJ5LnByb3RvdHlwZS5zZXRBdHRyaWJ1dGUpIHtcbiAgICBHbHlwaHNHZW9tZXRyeS5wcm90b3R5cGUuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24obmFtZSwgYXR0cmlidXRlKSB7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXSA9IGF0dHJpYnV0ZTtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gdXBkYXRlQnVmZmVyQXR0cihnZW9tLCBhdHRyTmFtZSwgbmV3QXJyYXksIGl0ZW1TaXplKSB7XG4gICAgdmFyIGF0dHIgPSBnZW9tLmdldEF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgaWYgKG5ld0FycmF5KSB7XG4gICAgICAvLyBJZiBsZW5ndGggaXNuJ3QgY2hhbmdpbmcsIGp1c3QgdXBkYXRlIHRoZSBhdHRyaWJ1dGUncyBhcnJheSBkYXRhXG4gICAgICBpZiAoYXR0ciAmJiBhdHRyLmFycmF5Lmxlbmd0aCA9PT0gbmV3QXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIGF0dHIuYXJyYXkuc2V0KG5ld0FycmF5KTtcbiAgICAgICAgYXR0ci5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW9tLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgbmV3IHRocmVlLkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZShuZXdBcnJheSwgaXRlbVNpemUpKTtcbiAgICAgICAgLy8gSWYgdGhlIG5ldyBhdHRyaWJ1dGUgaGFzIGEgZGlmZmVyZW50IHNpemUsIHdlIGFsc28gaGF2ZSB0byAoYXMgb2YgcjExNykgbWFudWFsbHkgY2xlYXIgdGhlXG4gICAgICAgIC8vIGludGVybmFsIGNhY2hlZCBtYXggaW5zdGFuY2UgY291bnQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2lzc3Vlcy8xOTcwNlxuICAgICAgICAvLyBJdCdzIHVuY2xlYXIgaWYgdGhpcyBpcyBhIHRocmVlanMgYnVnIG9yIGEgdHJ1bHkgdW5zdXBwb3J0ZWQgc2NlbmFyaW87IGRpc2N1c3Npb24gaW5cbiAgICAgICAgLy8gdGhhdCB0aWNrZXQgaXMgYW1iaWd1b3VzIGFzIHRvIHdoZXRoZXIgcmVwbGFjaW5nIGEgQnVmZmVyQXR0cmlidXRlIHdpdGggb25lIG9mIGFcbiAgICAgICAgLy8gZGlmZmVyZW50IHNpemUgaXMgc3VwcG9ydGVkLCBidXQgaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzE3NDE4IHN0cm9uZ2x5XG4gICAgICAgIC8vIGltcGxpZXMgaXQgc2hvdWxkIGJlIHN1cHBvcnRlZC4gSXQncyBwb3NzaWJsZSB3ZSBuZWVkIHRvXG4gICAgICAgIGRlbGV0ZSBnZW9tLl9tYXhJbnN0YW5jZUNvdW50OyAvL2ZvciByMTE3KywgY291bGQgYmUgZnJhZ2lsZVxuICAgICAgICBnZW9tLmRpc3Bvc2UoKTsgLy9mb3IgcjExOCssIG1vcmUgcm9idXN0IGZlZWxpbmcsIGJ1dCBtb3JlIGhlYXZ5LWhhbmRlZCB0aGFuIEknZCBsaWtlXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhdHRyKSB7XG4gICAgICBnZW9tLmRlbGV0ZUF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gSGFuZGxlIG1heEluc3RhbmNlZENvdW50IC0+IGluc3RhbmNlQ291bnQgcmVuYW1lIHRoYXQgaGFwcGVuZWQgaW4gdGhyZWUgcjExN1xuICBmdW5jdGlvbiBzZXRJbnN0YW5jZUNvdW50KGdlb20sIGNvdW50KSB7XG4gICAgZ2VvbVtnZW9tLmhhc093blByb3BlcnR5KCdpbnN0YW5jZUNvdW50JykgPyAnaW5zdGFuY2VDb3VudCcgOiAnbWF4SW5zdGFuY2VkQ291bnQnXSA9IGNvdW50O1xuICB9XG5cbiAgLy8gbGFuZ3VhZ2U9R0xTTFxuICB2YXIgVkVSVEVYX0RFRlMgPSBcIlxcbnVuaWZvcm0gdmVjMiB1VHJvaWthU0RGVGV4dHVyZVNpemU7XFxudW5pZm9ybSBmbG9hdCB1VHJvaWthU0RGR2x5cGhTaXplO1xcbnVuaWZvcm0gdmVjNCB1VHJvaWthVG90YWxCb3VuZHM7XFxudW5pZm9ybSB2ZWM0IHVUcm9pa2FDbGlwUmVjdDtcXG51bmlmb3JtIG1hdDMgdVRyb2lrYU9yaWVudDtcXG51bmlmb3JtIGJvb2wgdVRyb2lrYVVzZUdseXBoQ29sb3JzO1xcbmF0dHJpYnV0ZSB2ZWM0IGFUcm9pa2FHbHlwaEJvdW5kcztcXG5hdHRyaWJ1dGUgZmxvYXQgYVRyb2lrYUdseXBoSW5kZXg7XFxuYXR0cmlidXRlIHZlYzMgYVRyb2lrYUdseXBoQ29sb3I7XFxudmFyeWluZyB2ZWMyIHZUcm9pa2FTREZUZXh0dXJlVVY7XFxudmFyeWluZyB2ZWMyIHZUcm9pa2FHbHlwaFVWO1xcbnZhcnlpbmcgdmVjMyB2VHJvaWthR2x5cGhDb2xvcjtcXG5cIjtcblxuICAvLyBsYW5ndWFnZT1HTFNMIHByZWZpeD1cInZvaWQgbWFpbigpIHtcIiBzdWZmaXg9XCJ9XCJcbiAgdmFyIFZFUlRFWF9UUkFOU0ZPUk0gPSBcIlxcbnZlYzQgYm91bmRzID0gYVRyb2lrYUdseXBoQm91bmRzO1xcbnZlYzQgY2xpcHBlZEJvdW5kcyA9IHZlYzQoXFxuICBjbGFtcChib3VuZHMueHksIHVUcm9pa2FDbGlwUmVjdC54eSwgdVRyb2lrYUNsaXBSZWN0Lnp3KSxcXG4gIGNsYW1wKGJvdW5kcy56dywgdVRyb2lrYUNsaXBSZWN0Lnh5LCB1VHJvaWthQ2xpcFJlY3QuencpXFxuKTtcXG52ZWMyIGNsaXBwZWRYWSA9IChtaXgoY2xpcHBlZEJvdW5kcy54eSwgY2xpcHBlZEJvdW5kcy56dywgcG9zaXRpb24ueHkpIC0gYm91bmRzLnh5KSAvIChib3VuZHMuencgLSBib3VuZHMueHkpO1xcbnZUcm9pa2FHbHlwaFVWID0gY2xpcHBlZFhZLnh5O1xcblxcbmZsb2F0IGNvbHMgPSB1VHJvaWthU0RGVGV4dHVyZVNpemUueCAvIHVUcm9pa2FTREZHbHlwaFNpemU7XFxudlRyb2lrYVNERlRleHR1cmVVViA9IHZlYzIoXFxuICBtb2QoYVRyb2lrYUdseXBoSW5kZXgsIGNvbHMpICsgY2xpcHBlZFhZLngsXFxuICBmbG9vcihhVHJvaWthR2x5cGhJbmRleCAvIGNvbHMpICsgY2xpcHBlZFhZLnlcXG4pICogdVRyb2lrYVNERkdseXBoU2l6ZSAvIHVUcm9pa2FTREZUZXh0dXJlU2l6ZTtcXG5cXG5wb3NpdGlvbi54eSA9IG1peChib3VuZHMueHksIGJvdW5kcy56dywgY2xpcHBlZFhZKTtcXG5cXG51diA9IHZlYzIoXFxuICAocG9zaXRpb24ueCAtIHVUcm9pa2FUb3RhbEJvdW5kcy54KSAvICh1VHJvaWthVG90YWxCb3VuZHMueiAtIHVUcm9pa2FUb3RhbEJvdW5kcy54KSxcXG4gIChwb3NpdGlvbi55IC0gdVRyb2lrYVRvdGFsQm91bmRzLnkpIC8gKHVUcm9pa2FUb3RhbEJvdW5kcy53IC0gdVRyb2lrYVRvdGFsQm91bmRzLnkpXFxuKTtcXG5cXG5wb3NpdGlvbiA9IHVUcm9pa2FPcmllbnQgKiBwb3NpdGlvbjtcXG5ub3JtYWwgPSB1VHJvaWthT3JpZW50ICogbm9ybWFsO1xcblwiO1xuXG4gIC8vIGxhbmd1YWdlPUdMU0xcbiAgdmFyIEZSQUdNRU5UX0RFRlMgPSBcIlxcbnVuaWZvcm0gc2FtcGxlcjJEIHVUcm9pa2FTREZUZXh0dXJlO1xcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYVNERk1pbkRpc3RhbmNlUGN0O1xcbnVuaWZvcm0gYm9vbCB1VHJvaWthU0RGRGVidWc7XFxudmFyeWluZyB2ZWMyIHZUcm9pa2FTREZUZXh0dXJlVVY7XFxudmFyeWluZyB2ZWMyIHZUcm9pa2FHbHlwaFVWO1xcblxcbmZsb2F0IHRyb2lrYUdldFRleHRBbHBoYSgpIHtcXG4gIGZsb2F0IHRyb2lrYVNERlZhbHVlID0gdGV4dHVyZTJEKHVUcm9pa2FTREZUZXh0dXJlLCB2VHJvaWthU0RGVGV4dHVyZVVWKS5yO1xcbiAgXFxuICAjaWYgZGVmaW5lZChJU19ERVBUSF9NQVRFUklBTCkgfHwgZGVmaW5lZChJU19ESVNUQU5DRV9NQVRFUklBTClcXG4gIGZsb2F0IGFscGhhID0gc3RlcCgwLjUsIHRyb2lrYVNERlZhbHVlKTtcXG4gICNlbHNlXFxuICBcIiArICgnJykgKyBcIlxcbiAgI2lmIGRlZmluZWQoR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzKSB8fCBfX1ZFUlNJT05fXyA+PSAzMDBcXG4gIGZsb2F0IGFhRGlzdCA9IG1pbihcXG4gICAgMC41LFxcbiAgICAwLjUgKiBtaW4oXFxuICAgICAgZndpZHRoKHZUcm9pa2FHbHlwaFVWLngpLFxcbiAgICAgIGZ3aWR0aCh2VHJvaWthR2x5cGhVVi55KVxcbiAgICApXFxuICApIC8gdVRyb2lrYVNERk1pbkRpc3RhbmNlUGN0O1xcbiAgI2Vsc2VcXG4gIGZsb2F0IGFhRGlzdCA9IDAuMDE7XFxuICAjZW5kaWZcXG4gIFxcbiAgZmxvYXQgYWxwaGEgPSB1VHJvaWthU0RGRGVidWcgPyB0cm9pa2FTREZWYWx1ZSA6IHNtb290aHN0ZXAoXFxuICAgIDAuNSAtIGFhRGlzdCxcXG4gICAgMC41ICsgYWFEaXN0LFxcbiAgICB0cm9pa2FTREZWYWx1ZVxcbiAgKTtcXG4gICNlbmRpZlxcbiAgXFxuICByZXR1cm4gYWxwaGE7XFxufVxcblwiO1xuXG4gIC8vIGxhbmd1YWdlPUdMU0wgcHJlZml4PVwidm9pZCBtYWluKCkge1wiIHN1ZmZpeD1cIn1cIlxuICB2YXIgRlJBR01FTlRfVFJBTlNGT1JNID0gXCJcXG5mbG9hdCB0cm9pa2FBbHBoYU11bHQgPSB0cm9pa2FHZXRUZXh0QWxwaGEoKTtcXG5pZiAodHJvaWthQWxwaGFNdWx0ID09IDAuMCkge1xcbiAgZGlzY2FyZDtcXG59IGVsc2Uge1xcbiAgZ2xfRnJhZ0NvbG9yLmEgKj0gdHJvaWthQWxwaGFNdWx0O1xcbn1cXG5cIjtcblxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBtYXRlcmlhbCBmb3IgcmVuZGVyaW5nIHRleHQsIGRlcml2ZWQgZnJvbSBhIGJhc2VNYXRlcmlhbFxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlVGV4dERlcml2ZWRNYXRlcmlhbChiYXNlTWF0ZXJpYWwpIHtcbiAgICB2YXIgdGV4dE1hdGVyaWFsID0gdHJvaWthVGhyZWVVdGlscy5jcmVhdGVEZXJpdmVkTWF0ZXJpYWwoYmFzZU1hdGVyaWFsLCB7XG4gICAgICBleHRlbnNpb25zOiB7ZGVyaXZhdGl2ZXM6IHRydWV9LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgdVRyb2lrYVNERlRleHR1cmU6IHt2YWx1ZTogbnVsbH0sXG4gICAgICAgIHVUcm9pa2FTREZUZXh0dXJlU2l6ZToge3ZhbHVlOiBuZXcgdGhyZWUuVmVjdG9yMigpfSxcbiAgICAgICAgdVRyb2lrYVNERkdseXBoU2l6ZToge3ZhbHVlOiAwfSxcbiAgICAgICAgdVRyb2lrYVNERk1pbkRpc3RhbmNlUGN0OiB7dmFsdWU6IDB9LFxuICAgICAgICB1VHJvaWthVG90YWxCb3VuZHM6IHt2YWx1ZTogbmV3IHRocmVlLlZlY3RvcjQoMCwwLDAsMCl9LFxuICAgICAgICB1VHJvaWthQ2xpcFJlY3Q6IHt2YWx1ZTogbmV3IHRocmVlLlZlY3RvcjQoMCwwLDAsMCl9LFxuICAgICAgICB1VHJvaWthT3JpZW50OiB7dmFsdWU6IG5ldyB0aHJlZS5NYXRyaXgzKCl9LFxuICAgICAgICB1VHJvaWthVXNlR2x5cGhDb2xvcnM6IHt2YWx1ZTogdHJ1ZX0sXG4gICAgICAgIHVUcm9pa2FTREZEZWJ1Zzoge3ZhbHVlOiBmYWxzZX1cbiAgICAgIH0sXG4gICAgICB2ZXJ0ZXhEZWZzOiBWRVJURVhfREVGUyxcbiAgICAgIHZlcnRleFRyYW5zZm9ybTogVkVSVEVYX1RSQU5TRk9STSxcbiAgICAgIGZyYWdtZW50RGVmczogRlJBR01FTlRfREVGUyxcbiAgICAgIGZyYWdtZW50Q29sb3JUcmFuc2Zvcm06IEZSQUdNRU5UX1RSQU5TRk9STSxcbiAgICAgIGN1c3RvbVJld3JpdGVyOiBmdW5jdGlvbiBjdXN0b21SZXdyaXRlcihyZWYpIHtcbiAgICAgICAgdmFyIHZlcnRleFNoYWRlciA9IHJlZi52ZXJ0ZXhTaGFkZXI7XG4gICAgICAgIHZhciBmcmFnbWVudFNoYWRlciA9IHJlZi5mcmFnbWVudFNoYWRlcjtcblxuICAgICAgICB2YXIgdURpZmZ1c2VSRSA9IC9cXGJ1bmlmb3JtXFxzK3ZlYzNcXHMrZGlmZnVzZVxcYi87XG4gICAgICAgIGlmICh1RGlmZnVzZVJFLnRlc3QoZnJhZ21lbnRTaGFkZXIpKSB7XG4gICAgICAgICAgLy8gUmVwbGFjZSBhbGwgaW5zdGFuY2VzIG9mIGBkaWZmdXNlYCB3aXRoIG91ciB2YXJ5aW5nXG4gICAgICAgICAgZnJhZ21lbnRTaGFkZXIgPSBmcmFnbWVudFNoYWRlclxuICAgICAgICAgICAgLnJlcGxhY2UodURpZmZ1c2VSRSwgJ3ZhcnlpbmcgdmVjMyB2VHJvaWthR2x5cGhDb2xvcicpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxiZGlmZnVzZVxcYi9nLCAndlRyb2lrYUdseXBoQ29sb3InKTtcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHZlcnRleCBzaGFkZXIgZGVjbGFyZXMgdGhlIHVuaWZvcm0gc28gd2UgY2FuIGdyYWIgaXQgYXMgYSBmYWxsYmFja1xuICAgICAgICAgIGlmICghdURpZmZ1c2VSRS50ZXN0KHZlcnRleFNoYWRlcikpIHtcbiAgICAgICAgICAgIHZlcnRleFNoYWRlciA9IHZlcnRleFNoYWRlci5yZXBsYWNlKFxuICAgICAgICAgICAgICB0cm9pa2FUaHJlZVV0aWxzLnZvaWRNYWluUmVnRXhwLFxuICAgICAgICAgICAgICAndW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxuJCZcXG52VHJvaWthR2x5cGhDb2xvciA9IHVUcm9pa2FVc2VHbHlwaENvbG9ycyA/IGFUcm9pa2FHbHlwaENvbG9yIC8gMjU1LjAgOiBkaWZmdXNlO1xcbidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZlcnRleFNoYWRlcjogdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcjogZnJhZ21lbnRTaGFkZXIgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gRm9yY2UgdHJhbnNwYXJlbmN5IC0gVE9ETyBpcyB0aGlzIHJlYXNvbmFibGU/XG4gICAgdGV4dE1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRleHRNYXRlcmlhbCwge1xuICAgICAgaXNUcm9pa2FUZXh0TWF0ZXJpYWw6IHt2YWx1ZTogdHJ1ZX0sXG5cbiAgICAgIC8vIFdlYkdMU2hhZG93TWFwIHJldmVyc2VzIHRoZSBzaWRlIG9mIHRoZSBzaGFkb3cgbWF0ZXJpYWwgYnkgZGVmYXVsdCwgd2hpY2ggZmFpbHNcbiAgICAgIC8vIGZvciBwbGFuZXMsIHNvIGhlcmUgd2UgZm9yY2UgdGhlIGBzaGFkb3dTaWRlYCB0byBhbHdheXMgbWF0Y2ggdGhlIG1haW4gc2lkZS5cbiAgICAgIHNoYWRvd1NpZGU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2lkZVxuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCgpIHtcbiAgICAgICAgICAvL25vLW9wXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0ZXh0TWF0ZXJpYWxcbiAgfVxuXG4gIHZhciBkZWZhdWx0TWF0ZXJpYWwgPSBuZXcgdGhyZWUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICAgIGNvbG9yOiAweGZmZmZmZixcbiAgICBzaWRlOiB0aHJlZS5Eb3VibGVTaWRlLFxuICAgIHRyYW5zcGFyZW50OiB0cnVlXG4gIH0pO1xuXG4gIHZhciB0ZW1wTWF0NCA9IG5ldyB0aHJlZS5NYXRyaXg0KCk7XG4gIHZhciB0ZW1wVmVjM2EgPSBuZXcgdGhyZWUuVmVjdG9yMygpO1xuICB2YXIgdGVtcFZlYzNiID0gbmV3IHRocmVlLlZlY3RvcjMoKTtcbiAgdmFyIHRlbXBBcnJheSA9IFtdO1xuICB2YXIgb3JpZ2luID0gbmV3IHRocmVlLlZlY3RvcjMoKTtcbiAgdmFyIGRlZmF1bHRPcmllbnQgPSAnK3greSc7XG5cbiAgdmFyIHJheWNhc3RNZXNoID0gbmV3IHRocmVlLk1lc2goXG4gICAgbmV3IHRocmVlLlBsYW5lQnVmZmVyR2VvbWV0cnkoMSwgMSkudHJhbnNsYXRlKDAuNSwgMC41LCAwKSxcbiAgICBkZWZhdWx0TWF0ZXJpYWxcbiAgKTtcblxuICB2YXIgc3luY1N0YXJ0RXZlbnQgPSB7dHlwZTogJ3N5bmNzdGFydCd9O1xuICB2YXIgc3luY0NvbXBsZXRlRXZlbnQgPSB7dHlwZTogJ3N5bmNjb21wbGV0ZSd9O1xuXG4gIHZhciBTWU5DQUJMRV9QUk9QUyA9IFtcbiAgICAnZm9udCcsXG4gICAgJ2ZvbnRTaXplJyxcbiAgICAnbGV0dGVyU3BhY2luZycsXG4gICAgJ2xpbmVIZWlnaHQnLFxuICAgICdtYXhXaWR0aCcsXG4gICAgJ292ZXJmbG93V3JhcCcsXG4gICAgJ3RleHQnLFxuICAgICd0ZXh0QWxpZ24nLFxuICAgICd0ZXh0SW5kZW50JyxcbiAgICAnd2hpdGVTcGFjZScsXG4gICAgJ2FuY2hvclgnLFxuICAgICdhbmNob3JZJyxcbiAgICAnY29sb3JSYW5nZXMnLFxuICAgICdzZGZHbHlwaFNpemUnXG4gIF07XG5cbiAgdmFyIENPUFlBQkxFX1BST1BTID0gU1lOQ0FCTEVfUFJPUFMuY29uY2F0KFxuICAgICdtYXRlcmlhbCcsXG4gICAgJ2NvbG9yJyxcbiAgICAnZGVwdGhPZmZzZXQnLFxuICAgICdjbGlwUmVjdCcsXG4gICAgJ29yaWVudGF0aW9uJyxcbiAgICAnZ2x5cGhHZW9tZXRyeURldGFpbCdcbiAgKTtcblxuXG5cbiAgLyoqXG4gICAqIEBjbGFzcyBUZXh0XG4gICAqXG4gICAqIEEgVGhyZWVKUyBNZXNoIHRoYXQgcmVuZGVycyBhIHN0cmluZyBvZiB0ZXh0IG9uIGEgcGxhbmUgaW4gM0Qgc3BhY2UgdXNpbmcgc2lnbmVkIGRpc3RhbmNlXG4gICAqIGZpZWxkcyAoU0RGKS5cbiAgICovXG4gIHZhciBUZXh0ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoTWVzaCkge1xuICAgIGZ1bmN0aW9uIFRleHQoKSB7XG4gICAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgR2x5cGhzR2VvbWV0cnkoKTtcbiAgICAgIE1lc2guY2FsbCh0aGlzLCBnZW9tZXRyeSwgbnVsbCk7XG5cbiAgICAgIC8vID09PSBUZXh0IGxheW91dCBwcm9wZXJ0aWVzOiA9PT0gLy9cblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IHRleHRcbiAgICAgICAqIFRoZSBzdHJpbmcgb2YgdGV4dCB0byBiZSByZW5kZXJlZC5cbiAgICAgICAqL1xuICAgICAgdGhpcy50ZXh0ID0gJyc7XG5cbiAgICAgIC8qKlxuICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIGBhbmNob3JYYCBhbmQgYGFuY2hvcllgIGluc3RlYWRcbiAgICAgICAqIEBtZW1iZXIge0FycmF5PG51bWJlcj59IGFuY2hvclxuICAgICAgICogRGVmaW5lcyB3aGVyZSBpbiB0aGUgdGV4dCBibG9jayBzaG91bGQgY29ycmVzcG9uZCB0byB0aGUgbWVzaCdzIGxvY2FsIHBvc2l0aW9uLCBhcyBhIHNldFxuICAgICAgICogb2YgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgcGVyY2VudGFnZXMgZnJvbSAwIHRvIDEuIEEgdmFsdWUgb2YgYFswLCAwXWAgKHRoZSBkZWZhdWx0KVxuICAgICAgICogYW5jaG9ycyBhdCB0aGUgdG9wLWxlZnQsIGBbMSwgMV1gIGF0IHRoZSBib3R0b20tcmlnaHQsIGFuZCBgWzAuNSwgMC41XWAgY2VudGVycyB0aGVcbiAgICAgICAqIGJsb2NrIGF0IHRoZSBtZXNoJ3MgcG9zaXRpb24uXG4gICAgICAgKi9cbiAgICAgIC8vdGhpcy5hbmNob3IgPSBudWxsXG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7bnVtYmVyfHN0cmluZ30gYW5jaG9yWFxuICAgICAgICogRGVmaW5lcyB0aGUgaG9yaXpvbnRhbCBwb3NpdGlvbiBpbiB0aGUgdGV4dCBibG9jayB0aGF0IHNob3VsZCBsaW5lIHVwIHdpdGggdGhlIGxvY2FsIG9yaWdpbi5cbiAgICAgICAqIENhbiBiZSBzcGVjaWZpZWQgYXMgYSBudW1lcmljIHggcG9zaXRpb24gaW4gbG9jYWwgdW5pdHMsIGEgc3RyaW5nIHBlcmNlbnRhZ2Ugb2YgdGhlIHRvdGFsXG4gICAgICAgKiB0ZXh0IGJsb2NrIHdpZHRoIGUuZy4gYCcyNSUnYCwgb3Igb25lIG9mIHRoZSBmb2xsb3dpbmcga2V5d29yZCBzdHJpbmdzOiAnbGVmdCcsICdjZW50ZXInLFxuICAgICAgICogb3IgJ3JpZ2h0Jy5cbiAgICAgICAqL1xuICAgICAgdGhpcy5hbmNob3JYID0gMDtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ8c3RyaW5nfSBhbmNob3JYXG4gICAgICAgKiBEZWZpbmVzIHRoZSB2ZXJ0aWNhbCBwb3NpdGlvbiBpbiB0aGUgdGV4dCBibG9jayB0aGF0IHNob3VsZCBsaW5lIHVwIHdpdGggdGhlIGxvY2FsIG9yaWdpbi5cbiAgICAgICAqIENhbiBiZSBzcGVjaWZpZWQgYXMgYSBudW1lcmljIHkgcG9zaXRpb24gaW4gbG9jYWwgdW5pdHMgKG5vdGU6IGRvd24gaXMgbmVnYXRpdmUgeSksIGEgc3RyaW5nXG4gICAgICAgKiBwZXJjZW50YWdlIG9mIHRoZSB0b3RhbCB0ZXh0IGJsb2NrIGhlaWdodCBlLmcuIGAnMjUlJ2AsIG9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIGtleXdvcmQgc3RyaW5nczpcbiAgICAgICAqICd0b3AnLCAndG9wLWJhc2VsaW5lJywgJ21pZGRsZScsICdib3R0b20tYmFzZWxpbmUnLCBvciAnYm90dG9tJy5cbiAgICAgICAqL1xuICAgICAgdGhpcy5hbmNob3JZID0gMDtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGZvbnRcbiAgICAgICAqIFVSTCBvZiBhIGN1c3RvbSBmb250IHRvIGJlIHVzZWQuIEZvbnQgZmlsZXMgY2FuIGJlIGFueSBvZiB0aGUgZm9ybWF0cyBzdXBwb3J0ZWQgYnlcbiAgICAgICAqIE9wZW5UeXBlIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL29wZW50eXBlanMvb3BlbnR5cGUuanMpLlxuICAgICAgICogRGVmYXVsdHMgdG8gdGhlIFJvYm90byBmb250IGxvYWRlZCBmcm9tIEdvb2dsZSBGb250cy5cbiAgICAgICAqL1xuICAgICAgdGhpcy5mb250ID0gbnVsbDsgLy93aWxsIHVzZSBkZWZhdWx0IGZyb20gVGV4dEJ1aWxkZXJcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGZvbnRTaXplXG4gICAgICAgKiBUaGUgc2l6ZSBhdCB3aGljaCB0byByZW5kZXIgdGhlIGZvbnQgaW4gbG9jYWwgdW5pdHM7IGNvcnJlc3BvbmRzIHRvIHRoZSBlbS1ib3ggaGVpZ2h0XG4gICAgICAgKiBvZiB0aGUgY2hvc2VuIGBmb250YC5cbiAgICAgICAqL1xuICAgICAgdGhpcy5mb250U2l6ZSA9IDAuMTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGxldHRlclNwYWNpbmdcbiAgICAgICAqIFNldHMgYSB1bmlmb3JtIGFkanVzdG1lbnQgdG8gc3BhY2luZyBiZXR3ZWVuIGxldHRlcnMgYWZ0ZXIga2VybmluZyBpcyBhcHBsaWVkLiBQb3NpdGl2ZVxuICAgICAgICogbnVtYmVycyBpbmNyZWFzZSBzcGFjaW5nIGFuZCBuZWdhdGl2ZSBudW1iZXJzIGRlY3JlYXNlIGl0LlxuICAgICAgICovXG4gICAgICB0aGlzLmxldHRlclNwYWNpbmcgPSAwO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge251bWJlcnxzdHJpbmd9IGxpbmVIZWlnaHRcbiAgICAgICAqIFNldHMgdGhlIGhlaWdodCBvZiBlYWNoIGxpbmUgb2YgdGV4dCwgYXMgYSBtdWx0aXBsZSBvZiB0aGUgYGZvbnRTaXplYC4gRGVmYXVsdHMgdG8gJ25vcm1hbCdcbiAgICAgICAqIHdoaWNoIGNob29zZXMgYSByZWFzb25hYmxlIGhlaWdodCBiYXNlZCBvbiB0aGUgY2hvc2VuIGZvbnQncyBhc2NlbmRlci9kZXNjZW5kZXIgbWV0cmljcy5cbiAgICAgICAqL1xuICAgICAgdGhpcy5saW5lSGVpZ2h0ID0gJ25vcm1hbCc7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBtYXhXaWR0aFxuICAgICAgICogVGhlIG1heGltdW0gd2lkdGggb2YgdGhlIHRleHQgYmxvY2ssIGFib3ZlIHdoaWNoIHRleHQgbWF5IHN0YXJ0IHdyYXBwaW5nIGFjY29yZGluZyB0byB0aGVcbiAgICAgICAqIGB3aGl0ZVNwYWNlYCBhbmQgYG92ZXJmbG93V3JhcGAgcHJvcGVydGllcy5cbiAgICAgICAqL1xuICAgICAgdGhpcy5tYXhXaWR0aCA9IEluZmluaXR5O1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gb3ZlcmZsb3dXcmFwXG4gICAgICAgKiBEZWZpbmVzIGhvdyB0ZXh0IHdyYXBzIGlmIHRoZSBgd2hpdGVTcGFjZWAgcHJvcGVydHkgaXMgYG5vcm1hbGAuIENhbiBiZSBlaXRoZXIgYCdub3JtYWwnYFxuICAgICAgICogdG8gYnJlYWsgYXQgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzLCBvciBgJ2JyZWFrLXdvcmQnYCB0byBhbGxvdyBicmVha2luZyB3aXRoaW4gd29yZHMuXG4gICAgICAgKiBEZWZhdWx0cyB0byBgJ25vcm1hbCdgLlxuICAgICAgICovXG4gICAgICB0aGlzLm92ZXJmbG93V3JhcCA9ICdub3JtYWwnO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gdGV4dEFsaWduXG4gICAgICAgKiBUaGUgaG9yaXpvbnRhbCBhbGlnbm1lbnQgb2YgZWFjaCBsaW5lIG9mIHRleHQgd2l0aGluIHRoZSBvdmVyYWxsIHRleHQgYm91bmRpbmcgYm94LlxuICAgICAgICovXG4gICAgICB0aGlzLnRleHRBbGlnbiA9ICdsZWZ0JztcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IHRleHRJbmRlbnRcbiAgICAgICAqIEluZGVudGF0aW9uIGZvciB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgbGluZTsgc2VlIENTUyBgdGV4dC1pbmRlbnRgLlxuICAgICAgICovXG4gICAgICB0aGlzLnRleHRJbmRlbnQgPSAwO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gd2hpdGVTcGFjZVxuICAgICAgICogRGVmaW5lcyB3aGV0aGVyIHRleHQgc2hvdWxkIHdyYXAgd2hlbiBhIGxpbmUgcmVhY2hlcyB0aGUgYG1heFdpZHRoYC4gQ2FuXG4gICAgICAgKiBiZSBlaXRoZXIgYCdub3JtYWwnYCAodGhlIGRlZmF1bHQpLCB0byBhbGxvdyB3cmFwcGluZyBhY2NvcmRpbmcgdG8gdGhlIGBvdmVyZmxvd1dyYXBgIHByb3BlcnR5LFxuICAgICAgICogb3IgYCdub3dyYXAnYCB0byBwcmV2ZW50IHdyYXBwaW5nLiBOb3RlIHRoYXQgYCdub3JtYWwnYCBoZXJlIGhvbm9ycyBuZXdsaW5lIGNoYXJhY3RlcnMgdG9cbiAgICAgICAqIG1hbnVhbGx5IGJyZWFrIGxpbmVzLCBtYWtpbmcgaXQgYmVoYXZlIG1vcmUgbGlrZSBgJ3ByZS13cmFwJ2AgZG9lcyBpbiBDU1MuXG4gICAgICAgKi9cbiAgICAgIHRoaXMud2hpdGVTcGFjZSA9ICdub3JtYWwnO1xuXG5cbiAgICAgIC8vID09PSBQcmVzZW50YXRpb24gcHJvcGVydGllczogPT09IC8vXG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7VEhSRUUuTWF0ZXJpYWx9IG1hdGVyaWFsXG4gICAgICAgKiBEZWZpbmVzIGEgX2Jhc2VfIG1hdGVyaWFsIHRvIGJlIHVzZWQgd2hlbiByZW5kZXJpbmcgdGhlIHRleHQuIFRoaXMgbWF0ZXJpYWwgd2lsbCBiZVxuICAgICAgICogYXV0b21hdGljYWxseSByZXBsYWNlZCB3aXRoIGEgbWF0ZXJpYWwgZGVyaXZlZCBmcm9tIGl0LCB0aGF0IGFkZHMgc2hhZGVyIGNvZGUgdG9cbiAgICAgICAqIGRlY3JlYXNlIHRoZSBhbHBoYSBmb3IgZWFjaCBmcmFnbWVudCAocGl4ZWwpIG91dHNpZGUgdGhlIHRleHQgZ2x5cGhzLCB3aXRoIGFudGlhbGlhc2luZy5cbiAgICAgICAqIEJ5IGRlZmF1bHQgaXQgd2lsbCBkZXJpdmUgZnJvbSBhIHNpbXBsZSB3aGl0ZSBNZXNoQmFzaWNNYXRlcmlhbCwgYnV0IHlvdSBjYW4gdXNlIGFueVxuICAgICAgICogb2YgdGhlIG90aGVyIG1lc2ggbWF0ZXJpYWxzIHRvIGdhaW4gb3RoZXIgZmVhdHVyZXMgbGlrZSBsaWdodGluZywgdGV4dHVyZSBtYXBzLCBldGMuXG4gICAgICAgKlxuICAgICAgICogQWxzbyBzZWUgdGhlIGBjb2xvcmAgc2hvcnRjdXQgcHJvcGVydHkuXG4gICAgICAgKi9cbiAgICAgIHRoaXMubWF0ZXJpYWwgPSBudWxsO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge3N0cmluZ3xudW1iZXJ8VEhSRUUuQ29sb3J9IGNvbG9yXG4gICAgICAgKiBUaGlzIGlzIGEgc2hvcnRjdXQgZm9yIHNldHRpbmcgdGhlIGBjb2xvcmAgb2YgdGhlIHRleHQncyBtYXRlcmlhbC4gWW91IGNhbiB1c2UgdGhpc1xuICAgICAgICogaWYgeW91IGRvbid0IHdhbnQgdG8gc3BlY2lmeSBhIHdob2xlIGN1c3RvbSBgbWF0ZXJpYWxgLlxuICAgICAgICovXG4gICAgICB0aGlzLmNvbG9yID0gbnVsbDtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtvYmplY3R8bnVsbH0gY29sb3JSYW5nZXNcbiAgICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgICAqIFRoaXMgYWxsb3dzIG1vcmUgZmluZS1ncmFpbmVkIGNvbnRyb2wgb2YgY29sb3JzIGZvciBpbmRpdmlkdWFsIG9yIHJhbmdlcyBvZiBjaGFyYWN0ZXJzLFxuICAgICAgICogdGFraW5nIHByZWNlZGVuY2Ugb3ZlciB0aGUgbWF0ZXJpYWwncyBgY29sb3JgLiBJdHMgZm9ybWF0IGlzIGFuIE9iamVjdCB3aG9zZSBrZXlzIGVhY2hcbiAgICAgICAqIGRlZmluZSBhIHN0YXJ0aW5nIGNoYXJhY3RlciBpbmRleCBmb3IgYSByYW5nZSwgYW5kIHdob3NlIHZhbHVlcyBhcmUgdGhlIGNvbG9yIGZvciBlYWNoXG4gICAgICAgKiByYW5nZS4gVGhlIGNvbG9yIHZhbHVlIGNhbiBiZSBhIG51bWVyaWMgaGV4IGNvbG9yIHZhbHVlLCBhIGBUSFJFRS5Db2xvcmAgb2JqZWN0LCBvclxuICAgICAgICogYW55IG9mIHRoZSBzdHJpbmdzIGFjY2VwdGVkIGJ5IGBUSFJFRS5Db2xvcmAuXG4gICAgICAgKi9cbiAgICAgIHRoaXMuY29sb3JSYW5nZXMgPSBudWxsO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge251bWJlcn0gZGVwdGhPZmZzZXRcbiAgICAgICAqIFRoaXMgaXMgYSBzaG9ydGN1dCBmb3Igc2V0dGluZyB0aGUgbWF0ZXJpYWwncyBgcG9seWdvbk9mZnNldGAgYW5kIHJlbGF0ZWQgcHJvcGVydGllcyxcbiAgICAgICAqIHdoaWNoIGNhbiBiZSB1c2VmdWwgaW4gcHJldmVudGluZyB6LWZpZ2h0aW5nIHdoZW4gdGhpcyB0ZXh0IGlzIGxhaWQgb24gdG9wIG9mIGFub3RoZXJcbiAgICAgICAqIHBsYW5lIGluIHRoZSBzY2VuZS4gUG9zaXRpdmUgbnVtYmVycyBhcmUgZnVydGhlciBmcm9tIHRoZSBjYW1lcmEsIG5lZ2F0aXZlcyBjbG9zZXIuXG4gICAgICAgKi9cbiAgICAgIHRoaXMuZGVwdGhPZmZzZXQgPSAwO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge0FycmF5PG51bWJlcj59IGNsaXBSZWN0XG4gICAgICAgKiBJZiBzcGVjaWZpZWQsIGRlZmluZXMgYSBgW21pblgsIG1pblksIG1heFgsIG1heFldYCBvZiBhIHJlY3RhbmdsZSBvdXRzaWRlIG9mIHdoaWNoIGFsbFxuICAgICAgICogcGl4ZWxzIHdpbGwgYmUgZGlzY2FyZGVkLiBUaGlzIGNhbiBiZSB1c2VkIGZvciBleGFtcGxlIHRvIGNsaXAgb3ZlcmZsb3dpbmcgdGV4dCB3aGVuXG4gICAgICAgKiBgd2hpdGVTcGFjZT0nbm93cmFwJ2AuXG4gICAgICAgKi9cbiAgICAgIHRoaXMuY2xpcFJlY3QgPSBudWxsO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gb3JpZW50YXRpb25cbiAgICAgICAqIERlZmluZXMgdGhlIGF4aXMgcGxhbmUgb24gd2hpY2ggdGhlIHRleHQgc2hvdWxkIGJlIGxhaWQgb3V0IHdoZW4gdGhlIG1lc2ggaGFzIG5vIGV4dHJhXG4gICAgICAgKiByb3RhdGlvbiB0cmFuc2Zvcm0uIEl0IGlzIHNwZWNpZmllZCBhcyBhIHN0cmluZyB3aXRoIHR3byBheGVzOiB0aGUgaG9yaXpvbnRhbCBheGlzIHdpdGhcbiAgICAgICAqIHBvc2l0aXZlIHBvaW50aW5nIHJpZ2h0LCBhbmQgdGhlIHZlcnRpY2FsIGF4aXMgd2l0aCBwb3NpdGl2ZSBwb2ludGluZyB1cC4gQnkgZGVmYXVsdCB0aGlzXG4gICAgICAgKiBpcyAnK3greScsIG1lYW5pbmcgdGhlIHRleHQgc2l0cyBvbiB0aGUgeHkgcGxhbmUgd2l0aCB0aGUgdGV4dCdzIHRvcCB0b3dhcmQgcG9zaXRpdmUgeVxuICAgICAgICogYW5kIGZhY2luZyBwb3NpdGl2ZSB6LiBBIHZhbHVlIG9mICcreC16JyB3b3VsZCBwbGFjZSBpdCBvbiB0aGUgeHogcGxhbmUgd2l0aCB0aGUgdGV4dCdzXG4gICAgICAgKiB0b3AgdG93YXJkIG5lZ2F0aXZlIHogYW5kIGZhY2luZyBwb3NpdGl2ZSB5LlxuICAgICAgICovXG4gICAgICB0aGlzLm9yaWVudGF0aW9uID0gZGVmYXVsdE9yaWVudDtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGdseXBoR2VvbWV0cnlEZXRhaWxcbiAgICAgICAqIENvbnRyb2xzIG51bWJlciBvZiB2ZXJ0aWNhbC9ob3Jpem9udGFsIHNlZ21lbnRzIHRoYXQgbWFrZSB1cCBlYWNoIGdseXBoJ3MgcmVjdGFuZ3VsYXJcbiAgICAgICAqIHBsYW5lLiBEZWZhdWx0cyB0byAxLiBUaGlzIGNhbiBiZSBpbmNyZWFzZWQgdG8gcHJvdmlkZSBtb3JlIGdlb21ldHJpY2FsIGRldGFpbCBmb3IgY3VzdG9tXG4gICAgICAgKiB2ZXJ0ZXggc2hhZGVyIGVmZmVjdHMsIGZvciBleGFtcGxlLlxuICAgICAgICovXG4gICAgICB0aGlzLmdseXBoR2VvbWV0cnlEZXRhaWwgPSAxO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge251bWJlcnxudWxsfSBzZGZHbHlwaFNpemVcbiAgICAgICAqIFRoZSBzaXplIG9mIGVhY2ggZ2x5cGgncyBTREYgKHNpZ25lZCBkaXN0YW5jZSBmaWVsZCkgdXNlZCBmb3IgcmVuZGVyaW5nLiBUaGlzIG11c3QgYmUgYVxuICAgICAgICogcG93ZXItb2YtdHdvIG51bWJlci4gRGVmYXVsdHMgdG8gNjQgd2hpY2ggaXMgZ2VuZXJhbGx5IGEgZ29vZCBiYWxhbmNlIG9mIHNpemUgYW5kIHF1YWxpdHlcbiAgICAgICAqIGZvciBtb3N0IGZvbnRzLiBMYXJnZXIgc2l6ZXMgY2FuIGltcHJvdmUgdGhlIHF1YWxpdHkgb2YgZ2x5cGggcmVuZGVyaW5nIGJ5IGluY3JlYXNpbmdcbiAgICAgICAqIHRoZSBzaGFycG5lc3Mgb2YgY29ybmVycyBhbmQgcHJldmVudGluZyBsb3NzIG9mIHZlcnkgdGhpbiBsaW5lcywgYXQgdGhlIGV4cGVuc2Ugb2ZcbiAgICAgICAqIGluY3JlYXNlZCBtZW1vcnkgZm9vdHByaW50IGFuZCBsb25nZXIgU0RGIGdlbmVyYXRpb24gdGltZS5cbiAgICAgICAqL1xuICAgICAgdGhpcy5zZGZHbHlwaFNpemUgPSBudWxsO1xuXG4gICAgICB0aGlzLmRlYnVnU0RGID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCBNZXNoICkgVGV4dC5fX3Byb3RvX18gPSBNZXNoO1xuICAgIFRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWVzaCAmJiBNZXNoLnByb3RvdHlwZSApO1xuICAgIFRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGV4dDtcblxuICAgIHZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IHRleHRSZW5kZXJJbmZvOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LG1hdGVyaWFsOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGdseXBoR2VvbWV0cnlEZXRhaWw6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sY3VzdG9tRGVwdGhNYXRlcmlhbDogeyBjb25maWd1cmFibGU6IHRydWUgfSxjdXN0b21EaXN0YW5jZU1hdGVyaWFsOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB0ZXh0IHJlbmRlcmluZyBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgdGV4dC1yZWxhdGVkIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcy5cbiAgICAgKiBUaGlzIGlzIGFuIGFzeW5jIHByb2Nlc3MsIHNvIHlvdSBjYW4gcGFzcyBpbiBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIHdoZW4gaXRcbiAgICAgKiBmaW5pc2hlcy5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdXG4gICAgICovXG4gICAgVGV4dC5wcm90b3R5cGUuc3luYyA9IGZ1bmN0aW9uIHN5bmMgKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuX25lZWRzU3luYykge1xuICAgICAgICB0aGlzLl9uZWVkc1N5bmMgPSBmYWxzZTtcblxuICAgICAgICAvLyBJZiB0aGVyZSdzIGFub3RoZXIgc3luYyBzdGlsbCBpbiBwcm9ncmVzcywgcXVldWVcbiAgICAgICAgaWYgKHRoaXMuX2lzU3luY2luZykge1xuICAgICAgICAgICh0aGlzLl9xdWV1ZWRTeW5jcyB8fCAodGhpcy5fcXVldWVkU3luY3MgPSBbXSkpLnB1c2goY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2lzU3luY2luZyA9IHRydWU7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHN5bmNTdGFydEV2ZW50KTtcblxuICAgICAgICAgIGdldFRleHRSZW5kZXJJbmZvKHtcbiAgICAgICAgICAgIHRleHQ6IHRoaXMudGV4dCxcbiAgICAgICAgICAgIGZvbnQ6IHRoaXMuZm9udCxcbiAgICAgICAgICAgIGZvbnRTaXplOiB0aGlzLmZvbnRTaXplIHx8IDAuMSxcbiAgICAgICAgICAgIGxldHRlclNwYWNpbmc6IHRoaXMubGV0dGVyU3BhY2luZyB8fCAwLFxuICAgICAgICAgICAgbGluZUhlaWdodDogdGhpcy5saW5lSGVpZ2h0IHx8ICdub3JtYWwnLFxuICAgICAgICAgICAgbWF4V2lkdGg6IHRoaXMubWF4V2lkdGgsXG4gICAgICAgICAgICB0ZXh0QWxpZ246IHRoaXMudGV4dEFsaWduLFxuICAgICAgICAgICAgdGV4dEluZGVudDogdGhpcy50ZXh0SW5kZW50LFxuICAgICAgICAgICAgd2hpdGVTcGFjZTogdGhpcy53aGl0ZVNwYWNlLFxuICAgICAgICAgICAgb3ZlcmZsb3dXcmFwOiB0aGlzLm92ZXJmbG93V3JhcCxcbiAgICAgICAgICAgIGFuY2hvclg6IHRoaXMuYW5jaG9yWCxcbiAgICAgICAgICAgIGFuY2hvclk6IHRoaXMuYW5jaG9yWSxcbiAgICAgICAgICAgIGNvbG9yUmFuZ2VzOiB0aGlzLmNvbG9yUmFuZ2VzLFxuICAgICAgICAgICAgaW5jbHVkZUNhcmV0UG9zaXRpb25zOiB0cnVlLCAvL1RPRE8gcGFyYW1ldGVyaXplXG4gICAgICAgICAgICBzZGZHbHlwaFNpemU6IHRoaXMuc2RmR2x5cGhTaXplXG4gICAgICAgICAgfSwgZnVuY3Rpb24gKHRleHRSZW5kZXJJbmZvKSB7XG4gICAgICAgICAgICB0aGlzJDEuX2lzU3luY2luZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBTYXZlIHJlc3VsdCBmb3IgbGF0ZXIgdXNlIGluIG9uQmVmb3JlUmVuZGVyXG4gICAgICAgICAgICB0aGlzJDEuX3RleHRSZW5kZXJJbmZvID0gdGV4dFJlbmRlckluZm87XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZ2VvbWV0cnkgYXR0cmlidXRlc1xuICAgICAgICAgICAgdGhpcyQxLmdlb21ldHJ5LnVwZGF0ZUdseXBocyhcbiAgICAgICAgICAgICAgdGV4dFJlbmRlckluZm8uZ2x5cGhCb3VuZHMsXG4gICAgICAgICAgICAgIHRleHRSZW5kZXJJbmZvLmdseXBoQXRsYXNJbmRpY2VzLFxuICAgICAgICAgICAgICB0ZXh0UmVuZGVySW5mby50b3RhbEJvdW5kcyxcbiAgICAgICAgICAgICAgdGV4dFJlbmRlckluZm8uY2h1bmtlZEJvdW5kcyxcbiAgICAgICAgICAgICAgdGV4dFJlbmRlckluZm8uZ2x5cGhDb2xvcnNcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIElmIHdlIGhhZCBleHRyYSBzeW5jIHJlcXVlc3RzIHF1ZXVlZCB1cCwga2ljayBpdCBvZmZcbiAgICAgICAgICAgIHZhciBxdWV1ZWQgPSB0aGlzJDEuX3F1ZXVlZFN5bmNzO1xuICAgICAgICAgICAgaWYgKHF1ZXVlZCkge1xuICAgICAgICAgICAgICB0aGlzJDEuX3F1ZXVlZFN5bmNzID0gbnVsbDtcbiAgICAgICAgICAgICAgdGhpcyQxLl9uZWVkc1N5bmMgPSB0cnVlO1xuICAgICAgICAgICAgICB0aGlzJDEuc3luYyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcXVldWVkLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbiAmJiBmbigpOyB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMkMS5kaXNwYXRjaEV2ZW50KHN5bmNDb21wbGV0ZUV2ZW50KTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYXRlIGEgc3luYyBpZiBuZWVkZWQgLSBub3RlIGl0IHdvbid0IGNvbXBsZXRlIHVudGlsIG5leHQgZnJhbWUgYXQgdGhlXG4gICAgICogZWFybGllc3Qgc28gaWYgcG9zc2libGUgaXQncyBhIGdvb2QgaWRlYSB0byBjYWxsIHN5bmMoKSBtYW51YWxseSBhcyBzb29uIGFzXG4gICAgICogYWxsIHRoZSBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBzZXQuXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgVGV4dC5wcm90b3R5cGUub25CZWZvcmVSZW5kZXIgPSBmdW5jdGlvbiBvbkJlZm9yZVJlbmRlciAoKSB7XG4gICAgICB0aGlzLnN5bmMoKTtcbiAgICAgIHRoaXMuX3ByZXBhcmVGb3JSZW5kZXIoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2hvcnRjdXQgdG8gZGlzcG9zZSB0aGUgZ2VvbWV0cnkgc3BlY2lmaWMgdG8gdGhpcyBpbnN0YW5jZS5cbiAgICAgKiBOb3RlOiB3ZSBkb24ndCBhbHNvIGRpc3Bvc2UgdGhlIGRlcml2ZWQgbWF0ZXJpYWwgaGVyZSBiZWNhdXNlIGlmIGFueXRoaW5nIGVsc2UgaXNcbiAgICAgKiBzaGFyaW5nIHRoZSBzYW1lIGJhc2UgbWF0ZXJpYWwgaXQgd2lsbCByZXN1bHQgaW4gYSBwYXVzZSBuZXh0IGZyYW1lIGFzIHRoZSBwcm9ncmFtXG4gICAgICogaXMgcmVjb21waWxlZC4gSW5zdGVhZCB1c2VycyBjYW4gZGlzcG9zZSB0aGUgYmFzZSBtYXRlcmlhbCBtYW51YWxseSwgbGlrZSBub3JtYWwsXG4gICAgICogYW5kIHdlJ2xsIGFsc28gZGlzcG9zZSB0aGUgZGVyaXZlZCBtYXRlcmlhbCBhdCB0aGF0IHRpbWUuXG4gICAgICovXG4gICAgVGV4dC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UgKCkge1xuICAgICAgdGhpcy5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7VHJvaWthVGV4dFJlbmRlckluZm98bnVsbH0gdGV4dFJlbmRlckluZm9cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBUaGUgY3VycmVudCBwcm9jZXNzZWQgcmVuZGVyaW5nIGRhdGEgZm9yIHRoaXMgVGV4dE1lc2gsIHJldHVybmVkIGJ5IHRoZSBUZXh0QnVpbGRlciBhZnRlclxuICAgICAqIGEgYHN5bmMoKWAgY2FsbC4gVGhpcyB3aWxsIGJlIGBudWxsYCBpbml0aWFsbHksIGFuZCBtYXkgYmUgc3RhbGUgZm9yIGEgc2hvcnQgcGVyaW9kIHVudGlsXG4gICAgICogdGhlIGFzeW5jaHJvdXMgYHN5bmMoKWAgcHJvY2VzcyBjb21wbGV0ZXMuXG4gICAgICovXG4gICAgcHJvdG90eXBlQWNjZXNzb3JzLnRleHRSZW5kZXJJbmZvLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90ZXh0UmVuZGVySW5mbyB8fCBudWxsXG4gICAgfTtcblxuICAgIC8vIEhhbmRsZXIgZm9yIGF1dG9tYXRpY2FsbHkgd3JhcHBpbmcgdGhlIGJhc2UgbWF0ZXJpYWwgd2l0aCBvdXIgdXBncmFkZXMuIFdlIGRvIHRoZSB3cmFwcGluZ1xuICAgIC8vIGxhemlseSBvbiBfcmVhZF8gcmF0aGVyIHRoYW4gd3JpdGUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd3JhcHBpbmcgb24gdHJhbnNpZW50IHZhbHVlcy5cbiAgICBwcm90b3R5cGVBY2Nlc3NvcnMubWF0ZXJpYWwuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGRlcml2ZWRNYXRlcmlhbCA9IHRoaXMuX2Rlcml2ZWRNYXRlcmlhbDtcbiAgICAgIHZhciBiYXNlTWF0ZXJpYWwgPSB0aGlzLl9iYXNlTWF0ZXJpYWwgfHwgZGVmYXVsdE1hdGVyaWFsO1xuICAgICAgaWYgKCFkZXJpdmVkTWF0ZXJpYWwgfHwgZGVyaXZlZE1hdGVyaWFsLmJhc2VNYXRlcmlhbCAhPT0gYmFzZU1hdGVyaWFsKSB7XG4gICAgICAgIGRlcml2ZWRNYXRlcmlhbCA9IHRoaXMuX2Rlcml2ZWRNYXRlcmlhbCA9IGNyZWF0ZVRleHREZXJpdmVkTWF0ZXJpYWwoYmFzZU1hdGVyaWFsKTtcbiAgICAgICAgLy8gZGlzcG9zZSB0aGUgZGVyaXZlZCBtYXRlcmlhbCB3aGVuIGl0cyBiYXNlIG1hdGVyaWFsIGlzIGRpc3Bvc2VkOlxuICAgICAgICBiYXNlTWF0ZXJpYWwuYWRkRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIGZ1bmN0aW9uIG9uRGlzcG9zZSgpIHtcbiAgICAgICAgICBiYXNlTWF0ZXJpYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uRGlzcG9zZSk7XG4gICAgICAgICAgZGVyaXZlZE1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVyaXZlZE1hdGVyaWFsXG4gICAgfTtcbiAgICBwcm90b3R5cGVBY2Nlc3NvcnMubWF0ZXJpYWwuc2V0ID0gZnVuY3Rpb24gKGJhc2VNYXRlcmlhbCkge1xuICAgICAgaWYgKGJhc2VNYXRlcmlhbCAmJiBiYXNlTWF0ZXJpYWwuaXNUcm9pa2FUZXh0TWF0ZXJpYWwpIHsgLy9wcmV2ZW50IGRvdWJsZS1kZXJpdmF0aW9uXG4gICAgICAgIHRoaXMuX2Rlcml2ZWRNYXRlcmlhbCA9IGJhc2VNYXRlcmlhbDtcbiAgICAgICAgdGhpcy5fYmFzZU1hdGVyaWFsID0gYmFzZU1hdGVyaWFsLmJhc2VNYXRlcmlhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2Jhc2VNYXRlcmlhbCA9IGJhc2VNYXRlcmlhbDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJvdG90eXBlQWNjZXNzb3JzLmdseXBoR2VvbWV0cnlEZXRhaWwuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnkuZGV0YWlsXG4gICAgfTtcbiAgICBwcm90b3R5cGVBY2Nlc3NvcnMuZ2x5cGhHZW9tZXRyeURldGFpbC5zZXQgPSBmdW5jdGlvbiAoZGV0YWlsKSB7XG4gICAgICB0aGlzLmdlb21ldHJ5LmRldGFpbCA9IGRldGFpbDtcbiAgICB9O1xuXG4gICAgLy8gQ3JlYXRlIGFuZCB1cGRhdGUgbWF0ZXJpYWwgZm9yIHNoYWRvd3MgdXBvbiByZXF1ZXN0OlxuICAgIHByb3RvdHlwZUFjY2Vzc29ycy5jdXN0b21EZXB0aE1hdGVyaWFsLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hdGVyaWFsLmdldERlcHRoTWF0ZXJpYWwoKVxuICAgIH07XG4gICAgcHJvdG90eXBlQWNjZXNzb3JzLmN1c3RvbURpc3RhbmNlTWF0ZXJpYWwuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWF0ZXJpYWwuZ2V0RGlzdGFuY2VNYXRlcmlhbCgpXG4gICAgfTtcblxuICAgIFRleHQucHJvdG90eXBlLl9wcmVwYXJlRm9yUmVuZGVyID0gZnVuY3Rpb24gX3ByZXBhcmVGb3JSZW5kZXIgKCkge1xuICAgICAgdmFyIG1hdGVyaWFsID0gdGhpcy5fZGVyaXZlZE1hdGVyaWFsO1xuICAgICAgdmFyIHVuaWZvcm1zID0gbWF0ZXJpYWwudW5pZm9ybXM7XG4gICAgICB2YXIgdGV4dEluZm8gPSB0aGlzLnRleHRSZW5kZXJJbmZvO1xuICAgICAgaWYgKHRleHRJbmZvKSB7XG4gICAgICAgIHZhciBzZGZUZXh0dXJlID0gdGV4dEluZm8uc2RmVGV4dHVyZTtcbiAgICAgICAgdmFyIHRvdGFsQm91bmRzID0gdGV4dEluZm8udG90YWxCb3VuZHM7XG4gICAgICAgIHVuaWZvcm1zLnVUcm9pa2FTREZUZXh0dXJlLnZhbHVlID0gc2RmVGV4dHVyZTtcbiAgICAgICAgdW5pZm9ybXMudVRyb2lrYVNERlRleHR1cmVTaXplLnZhbHVlLnNldChzZGZUZXh0dXJlLmltYWdlLndpZHRoLCBzZGZUZXh0dXJlLmltYWdlLmhlaWdodCk7XG4gICAgICAgIHVuaWZvcm1zLnVUcm9pa2FTREZHbHlwaFNpemUudmFsdWUgPSB0ZXh0SW5mby5zZGZHbHlwaFNpemU7XG4gICAgICAgIHVuaWZvcm1zLnVUcm9pa2FTREZNaW5EaXN0YW5jZVBjdC52YWx1ZSA9IHRleHRJbmZvLnNkZk1pbkRpc3RhbmNlUGVyY2VudDtcbiAgICAgICAgdW5pZm9ybXMudVRyb2lrYVRvdGFsQm91bmRzLnZhbHVlLmZyb21BcnJheSh0b3RhbEJvdW5kcyk7XG4gICAgICAgIHVuaWZvcm1zLnVUcm9pa2FVc2VHbHlwaENvbG9ycy52YWx1ZSA9ICEhdGV4dEluZm8uZ2x5cGhDb2xvcnM7XG5cbiAgICAgICAgdmFyIGNsaXBSZWN0ID0gdGhpcy5jbGlwUmVjdDtcbiAgICAgICAgaWYgKCEoY2xpcFJlY3QgJiYgQXJyYXkuaXNBcnJheShjbGlwUmVjdCkgJiYgY2xpcFJlY3QubGVuZ3RoID09PSA0KSkge1xuICAgICAgICAgIHVuaWZvcm1zLnVUcm9pa2FDbGlwUmVjdC52YWx1ZS5mcm9tQXJyYXkodG90YWxCb3VuZHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVuaWZvcm1zLnVUcm9pa2FDbGlwUmVjdC52YWx1ZS5zZXQoXG4gICAgICAgICAgICBNYXRoLm1heCh0b3RhbEJvdW5kc1swXSwgY2xpcFJlY3RbMF0pLFxuICAgICAgICAgICAgTWF0aC5tYXgodG90YWxCb3VuZHNbMV0sIGNsaXBSZWN0WzFdKSxcbiAgICAgICAgICAgIE1hdGgubWluKHRvdGFsQm91bmRzWzJdLCBjbGlwUmVjdFsyXSksXG4gICAgICAgICAgICBNYXRoLm1pbih0b3RhbEJvdW5kc1szXSwgY2xpcFJlY3RbM10pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdlb21ldHJ5LmFwcGx5Q2xpcFJlY3QodW5pZm9ybXMudVRyb2lrYUNsaXBSZWN0LnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHVuaWZvcm1zLnVUcm9pa2FTREZEZWJ1Zy52YWx1ZSA9ICEhdGhpcy5kZWJ1Z1NERjtcbiAgICAgIG1hdGVyaWFsLnBvbHlnb25PZmZzZXQgPSAhIXRoaXMuZGVwdGhPZmZzZXQ7XG4gICAgICBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0RmFjdG9yID0gbWF0ZXJpYWwucG9seWdvbk9mZnNldFVuaXRzID0gdGhpcy5kZXB0aE9mZnNldCB8fCAwO1xuXG4gICAgICAvLyBzaG9ydGN1dCBmb3Igc2V0dGluZyBtYXRlcmlhbCBjb2xvciB2aWEgYGNvbG9yYCBwcm9wIG9uIHRoZSBtZXNoOlxuICAgICAgdmFyIGNvbG9yID0gdGhpcy5jb2xvcjtcbiAgICAgIGlmIChjb2xvciAhPSBudWxsICYmIG1hdGVyaWFsLmNvbG9yICYmIG1hdGVyaWFsLmNvbG9yLmlzQ29sb3IgJiYgY29sb3IgIT09IG1hdGVyaWFsLl90cm9pa2FDb2xvcikge1xuICAgICAgICBtYXRlcmlhbC5jb2xvci5zZXQobWF0ZXJpYWwuX3Ryb2lrYUNvbG9yID0gY29sb3IpO1xuICAgICAgfVxuXG4gICAgICAvLyBiYXNlIG9yaWVudGF0aW9uXG4gICAgICB2YXIgb3JpZW50ID0gdGhpcy5vcmllbnRhdGlvbiB8fCBkZWZhdWx0T3JpZW50O1xuICAgICAgaWYgKG9yaWVudCAhPT0gbWF0ZXJpYWwuX29yaWVudGF0aW9uKSB7XG4gICAgICAgIHZhciByb3RNYXQgPSB1bmlmb3Jtcy51VHJvaWthT3JpZW50LnZhbHVlO1xuICAgICAgICBvcmllbnQgPSBvcmllbnQucmVwbGFjZSgvW14tK3h5el0vZywgJycpO1xuICAgICAgICB2YXIgbWF0Y2ggPSBvcmllbnQgIT09IGRlZmF1bHRPcmllbnQgJiYgb3JpZW50Lm1hdGNoKC9eKFstK10pKFt4eXpdKShbLStdKShbeHl6XSkkLyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIHZhciBoU2lnbiA9IG1hdGNoWzFdO1xuICAgICAgICAgIHZhciBoQXhpcyA9IG1hdGNoWzJdO1xuICAgICAgICAgIHZhciB2U2lnbiA9IG1hdGNoWzNdO1xuICAgICAgICAgIHZhciB2QXhpcyA9IG1hdGNoWzRdO1xuICAgICAgICAgIHRlbXBWZWMzYS5zZXQoMCwgMCwgMClbaEF4aXNdID0gaFNpZ24gPT09ICctJyA/IDEgOiAtMTtcbiAgICAgICAgICB0ZW1wVmVjM2Iuc2V0KDAsIDAsIDApW3ZBeGlzXSA9IHZTaWduID09PSAnLScgPyAtMSA6IDE7XG4gICAgICAgICAgdGVtcE1hdDQubG9va0F0KG9yaWdpbiwgdGVtcFZlYzNhLmNyb3NzKHRlbXBWZWMzYiksIHRlbXBWZWMzYik7XG4gICAgICAgICAgcm90TWF0LnNldEZyb21NYXRyaXg0KHRlbXBNYXQ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb3RNYXQuaWRlbnRpdHkoKTtcbiAgICAgICAgfVxuICAgICAgICBtYXRlcmlhbC5fb3JpZW50YXRpb24gPSBvcmllbnQ7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZSBDdXN0b20gcmF5Y2FzdGluZyB0byB0ZXN0IGFnYWluc3QgdGhlIHdob2xlIHRleHQgYmxvY2sncyBtYXggcmVjdGFuZ3VsYXIgYm91bmRzXG4gICAgICogVE9ETyBpcyB0aGVyZSBhbnkgcmVhc29uIHRvIG1ha2UgdGhpcyBtb3JlIGdyYW51bGFyLCBsaWtlIHdpdGhpbiBpbmRpdmlkdWFsIGxpbmUgb3IgZ2x5cGggcmVjdHM/XG4gICAgICovXG4gICAgVGV4dC5wcm90b3R5cGUucmF5Y2FzdCA9IGZ1bmN0aW9uIHJheWNhc3QgKHJheWNhc3RlciwgaW50ZXJzZWN0cykge1xuICAgICAgdmFyIHRleHRJbmZvID0gdGhpcy50ZXh0UmVuZGVySW5mbztcbiAgICAgIGlmICh0ZXh0SW5mbykge1xuICAgICAgICB2YXIgYm91bmRzID0gdGV4dEluZm8udG90YWxCb3VuZHM7XG4gICAgICAgIHJheWNhc3RNZXNoLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXMoXG4gICAgICAgICAgdGhpcy5tYXRyaXhXb3JsZCxcbiAgICAgICAgICB0ZW1wTWF0NC5zZXQoXG4gICAgICAgICAgICBib3VuZHNbMl0gLSBib3VuZHNbMF0sIDAsIDAsIGJvdW5kc1swXSxcbiAgICAgICAgICAgIDAsIGJvdW5kc1szXSAtIGJvdW5kc1sxXSwgMCwgYm91bmRzWzFdLFxuICAgICAgICAgICAgMCwgMCwgMSwgMCxcbiAgICAgICAgICAgIDAsIDAsIDAsIDFcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIHRlbXBBcnJheS5sZW5ndGggPSAwO1xuICAgICAgICByYXljYXN0TWVzaC5yYXljYXN0KHJheWNhc3RlciwgdGVtcEFycmF5KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZW1wQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0ZW1wQXJyYXlbaV0ub2JqZWN0ID0gdGhpcztcbiAgICAgICAgICBpbnRlcnNlY3RzLnB1c2godGVtcEFycmF5W2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBUZXh0LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAoc291cmNlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgTWVzaC5wcm90b3R5cGUuY29weS5jYWxsKHRoaXMsIHNvdXJjZSk7XG4gICAgICBDT1BZQUJMRV9QUk9QUy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIHRoaXMkMVtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9O1xuXG4gICAgVGV4dC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpXG4gICAgfTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBUZXh0LnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbiAgICByZXR1cm4gVGV4dDtcbiAgfSh0aHJlZS5NZXNoKSk7XG5cblxuICAvLyBDcmVhdGUgc2V0dGVycyBmb3IgcHJvcGVydGllcyB0aGF0IGFmZmVjdCB0ZXh0IGxheW91dDpcbiAgU1lOQ0FCTEVfUFJPUFMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIHZhciBwcml2YXRlS2V5ID0gJ19wcml2YXRlXycgKyBwcm9wO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZXh0LnByb3RvdHlwZSwgcHJvcCwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW3ByaXZhdGVLZXldXG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzW3ByaXZhdGVLZXldKSB7XG4gICAgICAgICAgdGhpc1twcml2YXRlS2V5XSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuX25lZWRzU3luYyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cblxuICAvLyBEZXByZWNhdGlvbiBoYW5kbGVyIGZvciBgYW5jaG9yYCBhcnJheTpcbiAgdmFyIGRlcHJNc2dTaG93biA9IGZhbHNlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGV4dC5wcm90b3R5cGUsICdhbmNob3InLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVwcmVjYXRlZF9hbmNob3JcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbCkge1xuICAgICAgdGhpcy5fZGVwcmVjYXRlZF9hbmNob3IgPSB2YWw7XG4gICAgICBpZiAoIWRlcHJNc2dTaG93bikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RleHRNZXNoOiBgYW5jaG9yYCBoYXMgYmVlbiBkZXByZWNhdGVkOyB1c2UgYGFuY2hvclhgIGFuZCBgYW5jaG9yWWAgaW5zdGVhZC4nKTtcbiAgICAgICAgZGVwck1zZ1Nob3duID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgdGhpcy5hbmNob3JYID0gKCgrdmFsWzBdIHx8IDApICogMTAwKSArIFwiJVwiO1xuICAgICAgICB0aGlzLmFuY2hvclkgPSAoKCt2YWxbMV0gfHwgMCkgKiAxMDApICsgXCIlXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFuY2hvclggPSB0aGlzLmFuY2hvclkgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLy89PT0gVXRpbGl0eSBmdW5jdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBjYXJldHMgYW5kIHNlbGVjdGlvbiByYW5nZXMgPT09Ly9cblxuICAvKipcbiAgICogQHR5cGVkZWYge29iamVjdH0gVGV4dENhcmV0XG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4IC0geCBwb3NpdGlvbiBvZiB0aGUgY2FyZXRcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHkgLSB5IHBvc2l0aW9uIG9mIHRoZSBjYXJldCdzIGJvdHRvbVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0IC0gaGVpZ2h0IG9mIHRoZSBjYXJldFxuICAgKiBAcHJvcGVydHkge251bWJlcn0gY2hhckluZGV4IC0gdGhlIGluZGV4IGluIHRoZSBvcmlnaW5hbCBpbnB1dCBzdHJpbmcgb2YgdGhpcyBjYXJldCdzIHRhcmdldFxuICAgKiAgIGNoYXJhY3RlcjsgdGhlIGNhcmV0IHdpbGwgYmUgZm9yIHRoZSBwb3NpdGlvbiBfYmVmb3JlXyB0aGF0IGNoYXJhY3Rlci5cbiAgICovXG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgbG9jYWwgeC95IGNvb3JkaW5hdGUgaW4gdGhlIHRleHQgYmxvY2sgcGxhbmUsIGZpbmQgdGhlIG5lYXJlc3QgY2FyZXQgcG9zaXRpb24uXG4gICAqIEBwYXJhbSB7VHJvaWthVGV4dFJlbmRlckluZm99IHRleHRSZW5kZXJJbmZvIC0gYSByZXN1bHQgb2JqZWN0IGZyb20gVGV4dEJ1aWxkZXIjZ2V0VGV4dFJlbmRlckluZm9cbiAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICogQHJldHVybiB7VGV4dENhcmV0IHwgbnVsbH1cbiAgICovXG4gIGZ1bmN0aW9uIGdldENhcmV0QXRQb2ludCh0ZXh0UmVuZGVySW5mbywgeCwgeSkge1xuICAgIHZhciBjbG9zZXN0Q2FyZXQgPSBudWxsO1xuICAgIHZhciBjYXJldEhlaWdodCA9IHRleHRSZW5kZXJJbmZvLmNhcmV0SGVpZ2h0O1xuICAgIHZhciBjYXJldHNCeVJvdyA9IGdyb3VwQ2FyZXRzQnlSb3codGV4dFJlbmRlckluZm8pO1xuXG4gICAgLy8gRmluZCBuZWFyZXN0IHJvdyBieSB5IGZpcnN0XG4gICAgdmFyIGNsb3Nlc3RSb3dZID0gSW5maW5pdHk7XG4gICAgY2FyZXRzQnlSb3cuZm9yRWFjaChmdW5jdGlvbiAoY2FyZXRzLCByb3dZKSB7XG4gICAgICBpZiAoTWF0aC5hYnMoeSAtIChyb3dZICsgY2FyZXRIZWlnaHQgLyAyKSkgPCBNYXRoLmFicyh5IC0gKGNsb3Nlc3RSb3dZICsgY2FyZXRIZWlnaHQgLyAyKSkpIHtcbiAgICAgICAgY2xvc2VzdFJvd1kgPSByb3dZO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gVGhlbiBmaW5kIGNsb3Nlc3QgY2FyZXQgYnkgeCB3aXRoaW4gdGhhdCByb3dcbiAgICBjYXJldHNCeVJvdy5nZXQoY2xvc2VzdFJvd1kpLmZvckVhY2goZnVuY3Rpb24gKGNhcmV0KSB7XG4gICAgICBpZiAoIWNsb3Nlc3RDYXJldCB8fCBNYXRoLmFicyh4IC0gY2FyZXQueCkgPCBNYXRoLmFicyh4IC0gY2xvc2VzdENhcmV0LngpKSB7XG4gICAgICAgIGNsb3Nlc3RDYXJldCA9IGNhcmV0O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjbG9zZXN0Q2FyZXRcbiAgfVxuXG5cbiAgdmFyIF9yZWN0c0NhY2hlID0gbmV3IFdlYWtNYXAoKTtcblxuICAvKipcbiAgICogR2l2ZW4gc3RhcnQgYW5kIGVuZCBjaGFyYWN0ZXIgaW5kZXhlcywgcmV0dXJuIGEgbGlzdCBvZiByZWN0YW5nbGVzIGNvdmVyaW5nIGFsbCB0aGVcbiAgICogY2hhcmFjdGVycyB3aXRoaW4gdGhhdCBzZWxlY3Rpb24uXG4gICAqIEBwYXJhbSB7VHJvaWthVGV4dFJlbmRlckluZm99IHRleHRSZW5kZXJJbmZvXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIGluZGV4IG9mIHRoZSBmaXJzdCBjaGFyIGluIHRoZSBzZWxlY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCAtIGluZGV4IG9mIHRoZSBmaXJzdCBjaGFyIGFmdGVyIHRoZSBzZWxlY3Rpb25cbiAgICogQHJldHVybiB7QXJyYXk8e2xlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbX0+IHwgbnVsbH1cbiAgICovXG4gIGZ1bmN0aW9uIGdldFNlbGVjdGlvblJlY3RzKHRleHRSZW5kZXJJbmZvLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHJlY3RzO1xuICAgIGlmICh0ZXh0UmVuZGVySW5mbykge1xuICAgICAgLy8gQ2hlY2sgY2FjaGUgLSB0ZXh0UmVuZGVySW5mbyBpcyBmcm96ZW4gc28gaXQncyBzYWZlIHRvIGNhY2hlIGJhc2VkIG9uIGl0XG4gICAgICB2YXIgcHJldlJlc3VsdCA9IF9yZWN0c0NhY2hlLmdldCh0ZXh0UmVuZGVySW5mbyk7XG4gICAgICBpZiAocHJldlJlc3VsdCAmJiBwcmV2UmVzdWx0LnN0YXJ0ID09PSBzdGFydCAmJiBwcmV2UmVzdWx0LmVuZCA9PT0gZW5kKSB7XG4gICAgICAgIHJldHVybiBwcmV2UmVzdWx0LnJlY3RzXG4gICAgICB9XG5cbiAgICAgIHZhciBjYXJldFBvc2l0aW9ucyA9IHRleHRSZW5kZXJJbmZvLmNhcmV0UG9zaXRpb25zO1xuICAgICAgdmFyIGNhcmV0SGVpZ2h0ID0gdGV4dFJlbmRlckluZm8uY2FyZXRIZWlnaHQ7XG4gICAgICB2YXIgdG90YWxCb3VuZHMgPSB0ZXh0UmVuZGVySW5mby50b3RhbEJvdW5kcztcblxuICAgICAgLy8gTm9ybWFsaXplXG4gICAgICBpZiAoZW5kIDwgc3RhcnQpIHtcbiAgICAgICAgdmFyIHMgPSBzdGFydDtcbiAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICAgIGVuZCA9IHM7XG4gICAgICB9XG4gICAgICBzdGFydCA9IE1hdGgubWF4KHN0YXJ0LCAwKTtcbiAgICAgIGVuZCA9IE1hdGgubWluKGVuZCwgY2FyZXRQb3NpdGlvbnMubGVuZ3RoICsgMSk7XG5cbiAgICAgIC8vIENvbGxlY3QgaW50byBvbmUgcmVjdCBwZXIgcm93XG4gICAgICB2YXIgcm93cyA9IG5ldyBNYXAoKTtcbiAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgIHZhciB4MSA9IGNhcmV0UG9zaXRpb25zW2kgKiAzXTtcbiAgICAgICAgdmFyIHgyID0gY2FyZXRQb3NpdGlvbnNbaSAqIDMgKyAxXTtcbiAgICAgICAgdmFyIHkgPSBjYXJldFBvc2l0aW9uc1tpICogMyArIDJdO1xuICAgICAgICB2YXIgcm93ID0gcm93cy5nZXQoeSk7XG4gICAgICAgIGlmICghcm93KSB7XG4gICAgICAgICAgcm93ID0ge2xlZnQ6IHgxLCByaWdodDogeDIsIGJvdHRvbTogeSwgdG9wOiB5ICsgY2FyZXRIZWlnaHR9O1xuICAgICAgICAgIHJvd3Muc2V0KHksIHJvdyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm93LmxlZnQgPSBNYXRoLm1heChNYXRoLm1pbihyb3cubGVmdCwgeDEpLCB0b3RhbEJvdW5kc1swXSk7XG4gICAgICAgICAgcm93LnJpZ2h0ID0gTWF0aC5taW4oTWF0aC5tYXgocm93LnJpZ2h0LCB4MiksIHRvdGFsQm91bmRzWzJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVjdHMgPSBbXTtcbiAgICAgIHJvd3MuZm9yRWFjaChmdW5jdGlvbiAocmVjdCkge1xuICAgICAgICByZWN0cy5wdXNoKHJlY3QpO1xuICAgICAgfSk7XG5cbiAgICAgIF9yZWN0c0NhY2hlLnNldCh0ZXh0UmVuZGVySW5mbywge3N0YXJ0OiBzdGFydCwgZW5kOiBlbmQsIHJlY3RzOiByZWN0c30pO1xuICAgIH1cbiAgICByZXR1cm4gcmVjdHNcbiAgfVxuXG4gIHZhciBfY2FyZXRzQnlSb3dDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5cbiAgZnVuY3Rpb24gZ3JvdXBDYXJldHNCeVJvdyh0ZXh0UmVuZGVySW5mbykge1xuICAgIC8vIHRleHRSZW5kZXJJbmZvIGlzIGZyb3plbiBzbyBpdCdzIHNhZmUgdG8gY2FjaGUgYmFzZWQgb24gaXRcbiAgICB2YXIgY2FyZXRzQnlSb3cgPSBfY2FyZXRzQnlSb3dDYWNoZS5nZXQodGV4dFJlbmRlckluZm8pO1xuICAgIGlmICghY2FyZXRzQnlSb3cpIHtcbiAgICAgIHZhciBjYXJldFBvc2l0aW9ucyA9IHRleHRSZW5kZXJJbmZvLmNhcmV0UG9zaXRpb25zO1xuICAgICAgdmFyIGNhcmV0SGVpZ2h0ID0gdGV4dFJlbmRlckluZm8uY2FyZXRIZWlnaHQ7XG4gICAgICBjYXJldHNCeVJvdyA9IG5ldyBNYXAoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FyZXRQb3NpdGlvbnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdmFyIHJvd1kgPSBjYXJldFBvc2l0aW9uc1tpICsgMl07XG4gICAgICAgIHZhciByb3dDYXJldHMgPSBjYXJldHNCeVJvdy5nZXQocm93WSk7XG4gICAgICAgIGlmICghcm93Q2FyZXRzKSB7XG4gICAgICAgICAgY2FyZXRzQnlSb3cuc2V0KHJvd1ksIHJvd0NhcmV0cyA9IFtdKTtcbiAgICAgICAgfVxuICAgICAgICByb3dDYXJldHMucHVzaCh7XG4gICAgICAgICAgeDogY2FyZXRQb3NpdGlvbnNbaV0sXG4gICAgICAgICAgeTogcm93WSxcbiAgICAgICAgICBoZWlnaHQ6IGNhcmV0SGVpZ2h0LFxuICAgICAgICAgIGNoYXJJbmRleDogaSAvIDNcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEFkZCBvbmUgbW9yZSBjYXJldCBhZnRlciB0aGUgZmluYWwgY2hhclxuICAgICAgICBpZiAoaSArIDMgPj0gY2FyZXRQb3NpdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgcm93Q2FyZXRzLnB1c2goe1xuICAgICAgICAgICAgeDogY2FyZXRQb3NpdGlvbnNbaSArIDFdLFxuICAgICAgICAgICAgeTogcm93WSxcbiAgICAgICAgICAgIGhlaWdodDogY2FyZXRIZWlnaHQsXG4gICAgICAgICAgICBjaGFySW5kZXg6IGkgLyAzICsgMVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIF9jYXJldHNCeVJvd0NhY2hlLnNldCh0ZXh0UmVuZGVySW5mbywgY2FyZXRzQnlSb3cpO1xuICAgIHJldHVybiBjYXJldHNCeVJvd1xuICB9XG5cbiAgZXhwb3J0cy5HbHlwaHNHZW9tZXRyeSA9IEdseXBoc0dlb21ldHJ5O1xuICBleHBvcnRzLlRleHQgPSBUZXh0O1xuICBleHBvcnRzLmNvbmZpZ3VyZVRleHRCdWlsZGVyID0gY29uZmlndXJlVGV4dEJ1aWxkZXI7XG4gIGV4cG9ydHMuY3JlYXRlVGV4dERlcml2ZWRNYXRlcmlhbCA9IGNyZWF0ZVRleHREZXJpdmVkTWF0ZXJpYWw7XG4gIGV4cG9ydHMuZm9udFByb2Nlc3Nvcldvcmtlck1vZHVsZSA9IGZvbnRQcm9jZXNzb3JXb3JrZXJNb2R1bGU7XG4gIGV4cG9ydHMuZ2V0Q2FyZXRBdFBvaW50ID0gZ2V0Q2FyZXRBdFBvaW50O1xuICBleHBvcnRzLmdldFNlbGVjdGlvblJlY3RzID0gZ2V0U2VsZWN0aW9uUmVjdHM7XG4gIGV4cG9ydHMucHJlbG9hZEZvbnQgPSBwcmVsb2FkRm9udDtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/troika-three-text/dist/troika-three-text.umd.js\n'
      );

      /***/
    },
};
