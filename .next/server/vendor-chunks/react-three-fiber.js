"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-three-fiber";
exports.ids = ["vendor-chunks/react-three-fiber"];
exports.modules = {
  /***/ "(ssr)/./node_modules/react-three-fiber/web.cjs.js":
    /*!***************************************************!*\
  !*** ./node_modules/react-three-fiber/web.cjs.js ***!
  \***************************************************/
    /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      eval(
        '\nObject.defineProperty(exports, "__esModule", ({\n    value: true\n}));\nfunction _interopDefault(ex) {\n    return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;\n}\nvar _extends = _interopDefault(__webpack_require__(/*! @babel/runtime/helpers/extends */ "(ssr)/./node_modules/@babel/runtime/helpers/extends.js"));\nvar _objectWithoutPropertiesLoose = _interopDefault(__webpack_require__(/*! @babel/runtime/helpers/objectWithoutPropertiesLoose */ "(ssr)/./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js"));\nvar _construct = _interopDefault(__webpack_require__(/*! @babel/runtime/helpers/construct */ "(ssr)/./node_modules/@babel/runtime/helpers/construct.js"));\nvar THREE = __webpack_require__(/*! three */ "(ssr)/./node_modules/three/build/three.js");\nvar React = __webpack_require__(/*! react */ "(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js");\nvar React__default = _interopDefault(React);\nvar Reconciler = _interopDefault(__webpack_require__(/*! react-reconciler */ "(ssr)/./node_modules/react-reconciler/index.js"));\nvar scheduler = __webpack_require__(/*! scheduler */ "(ssr)/./node_modules/scheduler/index.js");\nvar tinyEmitter = __webpack_require__(/*! tiny-emitter */ "(ssr)/./node_modules/tiny-emitter/index.js");\nvar usePromise = _interopDefault(__webpack_require__(/*! react-promise-suspense */ "(ssr)/./node_modules/react-promise-suspense/build/index.js"));\nvar useMeasure = _interopDefault(__webpack_require__(/*! react-use-measure */ "(ssr)/./node_modules/react-use-measure/dist/index.cjs"));\nvar resizeObserver = __webpack_require__(/*! @juggle/resize-observer */ "(ssr)/./node_modules/@juggle/resize-observer/lib/exports/resize-observer.umd.js");\nvar mergeRefs = _interopDefault(__webpack_require__(/*! react-merge-refs */ "(ssr)/./node_modules/react-merge-refs/dist/index.js"));\nfunction _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, "string");\n    return typeof key === "symbol" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n    if (typeof input !== "object" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n        var res = prim.call(input, hint || "default");\n        if (typeof res !== "object") return res;\n        throw new TypeError("@@toPrimitive must return a primitive value.");\n    }\n    return (hint === "string" ? String : Number)(input);\n}\nvar roots = new Map();\nvar emptyObject = {};\nvar is = {\n    obj: function obj(a) {\n        return a === Object(a) && !is.arr(a);\n    },\n    fun: function fun(a) {\n        return typeof a === "function";\n    },\n    str: function str(a) {\n        return typeof a === "string";\n    },\n    num: function num(a) {\n        return typeof a === "number";\n    },\n    und: function und(a) {\n        return a === void 0;\n    },\n    arr: function arr(a) {\n        return Array.isArray(a);\n    },\n    equ: function equ(a, b) {\n        // Wrong type or one of the two undefined, doesn\'t match\n        if (typeof a !== typeof b || !!a !== !!b) return false; // Atomic, just compare a against b\n        if (is.str(a) || is.num(a) || is.obj(a)) return a === b; // Array, shallow compare first to see if it\'s a match\n        if (is.arr(a) && a == b) return true; // Last resort, go through keys\n        var i;\n        for(i in a){\n            if (!(i in b)) return false;\n        }\n        for(i in b){\n            if (a[i] !== b[i]) return false;\n        }\n        return is.und(i) ? a === b : true;\n    }\n};\nfunction createSubs(callback, subs) {\n    var index = subs.length;\n    subs.push(callback);\n    return function() {\n        return void subs.splice(index, 1);\n    };\n}\nvar globalEffects = [];\nvar globalAfterEffects = [];\nvar globalTailEffects = [];\nvar addEffect = function addEffect(callback) {\n    return createSubs(callback, globalEffects);\n};\nvar addAfterEffect = function addAfterEffect(callback) {\n    return createSubs(callback, globalAfterEffects);\n};\nvar addTail = function addTail(callback) {\n    return createSubs(callback, globalTailEffects);\n};\nfunction renderGl(state, timestamp, repeat, runGlobalEffects) {\n    if (repeat === void 0) {\n        repeat = 0;\n    }\n    if (runGlobalEffects === void 0) {\n        runGlobalEffects = false;\n    }\n    // Run global effects\n    if (runGlobalEffects) globalEffects.forEach(function(effect) {\n        return effect(timestamp) && repeat++;\n    }); // Run local effects\n    var delta = state.current.clock.getDelta();\n    state.current.subscribers.forEach(function(sub) {\n        return sub.ref.current(state.current, delta);\n    }); // Decrease frame count\n    state.current.frames = Math.max(0, state.current.frames - 1);\n    repeat += !state.current.invalidateFrameloop ? 1 : state.current.frames; // Render content\n    if (!state.current.manual) state.current.gl.render(state.current.scene, state.current.camera); // Run global effects\n    if (runGlobalEffects) globalAfterEffects.forEach(function(effect) {\n        return effect(timestamp);\n    });\n    return repeat;\n}\nvar running = false;\nfunction renderLoop(timestamp) {\n    running = true;\n    var repeat = 0; // Run global effects\n    globalEffects.forEach(function(effect) {\n        return effect(timestamp) && repeat++;\n    });\n    roots.forEach(function(root) {\n        var state = root.containerInfo.__state; // If the frameloop is invalidated, do not run another frame\n        if (state.current.active && state.current.ready && (!state.current.invalidateFrameloop || state.current.frames > 0)) repeat = renderGl(state, timestamp, repeat);\n    }); // Run global after-effects\n    globalAfterEffects.forEach(function(effect) {\n        return effect(timestamp);\n    });\n    if (repeat !== 0) return requestAnimationFrame(renderLoop);\n    else {\n        // Tail call effects, they are called when rendering stops\n        globalTailEffects.forEach(function(effect) {\n            return effect(timestamp);\n        });\n    } // Flag end of operation\n    running = false;\n}\nfunction invalidate(state, frames) {\n    if (state === void 0) {\n        state = true;\n    }\n    if (frames === void 0) {\n        frames = 2;\n    }\n    if (state === true) roots.forEach(function(root) {\n        return root.containerInfo.__state.current.frames = frames;\n    });\n    else if (state && state.current) {\n        if (state.current.vr) return;\n        state.current.frames = frames;\n    }\n    if (!running) {\n        running = true;\n        requestAnimationFrame(renderLoop);\n    }\n}\nfunction forceResize() {\n    roots.forEach(function(root) {\n        return root.containerInfo.__state.current.forceResize();\n    });\n}\nvar catalogue = {};\nvar extend = function extend(objects) {\n    return void (catalogue = _extends({}, catalogue, objects));\n};\nfunction applyProps(instance, newProps, oldProps, accumulative) {\n    if (oldProps === void 0) {\n        oldProps = {};\n    }\n    if (accumulative === void 0) {\n        accumulative = false;\n    }\n    // Filter equals, events and reserved props\n    var container = instance.__container;\n    var sameProps = Object.keys(newProps).filter(function(key) {\n        return is.equ(newProps[key], oldProps[key]);\n    });\n    var handlers = Object.keys(newProps).filter(function(key) {\n        // Event-handlers ...\n        //   are functions, that\n        //   start with "on", and\n        //   contain the name "Pointer", "Click", "ContextMenu", or "Wheel"\n        if (is.fun(newProps[key]) && key.startsWith("on")) {\n            return key.includes("Pointer") || key.includes("Click") || key.includes("ContextMenu") || key.includes("Wheel");\n        }\n    });\n    var leftOvers = accumulative ? Object.keys(oldProps).filter(function(key) {\n        return newProps[key] === void 0;\n    }) : [];\n    var filteredProps = [].concat(sameProps, [\n        "children",\n        "key",\n        "ref"\n    ]).reduce(function(acc, prop) {\n        var _ = acc[prop], rest = _objectWithoutPropertiesLoose(acc, [\n            prop\n        ].map(_toPropertyKey));\n        return rest;\n    }, newProps); // Add left-overs as undefined props so they can be removed\n    leftOvers.forEach(function(key) {\n        return key !== "children" && (filteredProps[key] = undefined);\n    });\n    if (Object.keys(filteredProps).length > 0) {\n        Object.entries(filteredProps).forEach(function(_ref) {\n            var key = _ref[0], value = _ref[1];\n            if (!handlers.includes(key)) {\n                var _instance$__container;\n                var root = instance;\n                var target = root[key];\n                if (key.includes("-")) {\n                    var entries = key.split("-");\n                    target = entries.reduce(function(acc, key) {\n                        return acc[key];\n                    }, instance); // If the target is atomic, it forces us to switch the root\n                    if (!(target && target.set)) {\n                        var _entries$reverse = entries.reverse(), _name = _entries$reverse[0], reverseEntries = _entries$reverse.slice(1);\n                        root = reverseEntries.reverse().reduce(function(acc, key) {\n                            return acc[key];\n                        }, instance);\n                        key = _name;\n                    }\n                } // Special treatment for objects with support for set/copy\n                var isColorManagement = (_instance$__container = instance.__container) == null ? void 0 : _instance$__container.__state.current.colorManagement;\n                if (target && target.set && (target.copy || target instanceof THREE.Layers)) {\n                    var _target;\n                    // If value is an array it has got to be the set function\n                    if (Array.isArray(value)) (_target = target).set.apply(_target, value); // Test again target.copy(class) next ...\n                    else if (target.copy && value && value.constructor && target.constructor.name === value.constructor.name) target.copy(value); // If nothing else fits, just set the single value, ignore undefined\n                    else if (value !== undefined) {\n                        target.set(value); // Auto-convert sRGB colors, for now ...\n                        // https://github.com/react-spring/react-three-fiber/issues/344\n                        if (isColorManagement && target instanceof THREE.Color) {\n                            target.convertSRGBToLinear();\n                        }\n                    } // Else, just overwrite the value\n                } else {\n                    root[key] = value; // Auto-convert sRGB textures, for now ...\n                    // https://github.com/react-spring/react-three-fiber/issues/344\n                    if (isColorManagement && root[key] instanceof THREE.Texture) {\n                        root[key].encoding = THREE.sRGBEncoding;\n                    }\n                }\n                invalidateInstance(instance);\n            }\n        }); // Preemptively delete the instance from the containers interaction\n        if (accumulative && container && instance.raycast && instance.__handlers) {\n            instance.__handlers = undefined;\n            var index = container.__interaction.indexOf(instance);\n            if (index > -1) container.__interaction.splice(index, 1);\n        } // Prep interaction handlers\n        if (handlers.length) {\n            // Add interactive object to central container\n            if (container && instance.raycast) container.__interaction.push(instance); // Add handlers to the instances handler-map\n            instance.__handlers = handlers.reduce(function(acc, key) {\n                var _extends2;\n                return _extends({}, acc, (_extends2 = {}, _extends2[key.charAt(2).toLowerCase() + key.substr(3)] = newProps[key], _extends2));\n            }, {});\n        } // Call the update lifecycle when it is being updated, but only when it is part of the scene\n        if (instance.parent) updateInstance(instance);\n    }\n}\nfunction invalidateInstance(instance) {\n    if (instance.__container && instance.__container.__state) invalidate(instance.__container.__state);\n}\nfunction updateInstance(instance) {\n    if (instance.onUpdate) instance.onUpdate(instance);\n}\nfunction createInstance(type, _ref2, container, hostContext, internalInstanceHandle) {\n    var _ref2$args = _ref2.args, args = _ref2$args === void 0 ? [] : _ref2$args, props = _objectWithoutPropertiesLoose(_ref2, [\n        "args"\n    ]);\n    var name = "" + type[0].toUpperCase() + type.slice(1);\n    var instance;\n    if (type === "primitive") {\n        // Switch off dispose for primitive objects\n        props = _extends({\n            dispose: null\n        }, props);\n        instance = props.object;\n        instance.__instance = true;\n    } else if (type === "new") {\n        instance = new props.object(args);\n    } else {\n        var target = catalogue[name] || THREE[name];\n        if (!target) {\n            throw \'"\' + name + \'" is not part of the THREE namespace! Did you forget to extend it? See: https://github.com/react-spring/react-three-fiber/blob/master/api.md#putting-already-existing-objects-into-the-scene-graph\';\n        }\n        instance = is.arr(args) ? _construct(target, args) : new target(args);\n    } // Bind to the root container in case portals are being used\n    // This is perhaps better for event management as we can keep them on a single instance\n    while(container.__container){\n        container = container.__container;\n    } // TODO: https://github.com/facebook/react/issues/17147\n    // If it\'s still not there it means the portal was created on a virtual node outside of react\n    if (!roots.has(container)) {\n        var fn = function fn(node) {\n            if (!node["return"]) return node.stateNode && node.stateNode.containerInfo;\n            else return fn(node["return"]);\n        };\n        container = fn(internalInstanceHandle);\n    } // Apply initial props\n    instance.__objects = [];\n    instance.__container = container; // Auto-attach geometries and materials\n    if (name.endsWith("Geometry")) {\n        props = _extends({\n            attach: "geometry"\n        }, props);\n    } else if (name.endsWith("Material")) {\n        props = _extends({\n            attach: "material"\n        }, props);\n    } // It should NOT call onUpdate on object instanciation, because it hasn\'t been added to the\n    // view yet. If the callback relies on references for instance, they won\'t be ready yet, this is\n    // why it passes "false" here\n    applyProps(instance, props, {});\n    return instance;\n}\nfunction appendChild(parentInstance, child) {\n    if (child) {\n        if (child.isObject3D) parentInstance.add(child);\n        else {\n            parentInstance.__objects.push(child);\n            child.parent = parentInstance; // The attach attribute implies that the object attaches itself on the parent\n            if (child.attachArray) {\n                if (!is.arr(parentInstance[child.attachArray])) parentInstance[child.attachArray] = [];\n                parentInstance[child.attachArray].push(child);\n            } else if (child.attachObject) {\n                if (!is.obj(parentInstance[child.attachObject[0]])) parentInstance[child.attachObject[0]] = {};\n                parentInstance[child.attachObject[0]][child.attachObject[1]] = child;\n            } else if (child.attach) parentInstance[child.attach] = child;\n        }\n        updateInstance(child);\n        invalidateInstance(child);\n    }\n}\nfunction insertBefore(parentInstance, child, beforeChild) {\n    if (child) {\n        if (child.isObject3D) {\n            child.parent = parentInstance;\n            child.dispatchEvent({\n                type: "added"\n            });\n            var restSiblings = parentInstance.children.filter(function(sibling) {\n                return sibling !== child;\n            }); // TODO: the order is out of whack if data objects are present, has to be recalculated\n            var index = restSiblings.indexOf(beforeChild);\n            parentInstance.children = [].concat(restSiblings.slice(0, index), [\n                child\n            ], restSiblings.slice(index));\n            updateInstance(child);\n        } else appendChild(parentInstance, child); // TODO: order!!!\n        invalidateInstance(child);\n    }\n}\nfunction removeRecursive(array, parent, clone) {\n    if (clone === void 0) {\n        clone = false;\n    }\n    if (array) {\n        // Three uses splice op\'s internally we may have to shallow-clone the array in order to safely remove items\n        var target = clone ? [].concat(array) : array;\n        target.forEach(function(child) {\n            return removeChild(parent, child);\n        });\n    }\n}\nfunction removeChild(parentInstance, child) {\n    if (child) {\n        if (child.isObject3D) {\n            parentInstance.remove(child);\n        } else {\n            child.parent = null;\n            if (parentInstance.__objects) parentInstance.__objects = parentInstance.__objects.filter(function(x) {\n                return x !== child;\n            }); // Remove attachment\n            if (child.attachArray) parentInstance[child.attachArray] = parentInstance[child.attachArray].filter(function(x) {\n                return x !== child;\n            });\n            else if (child.attachObject) delete parentInstance[child.attachObject[0]][child.attachObject[1]];\n            else if (child.attach) parentInstance[child.attach] = null;\n        }\n        invalidateInstance(child); // Allow objects to bail out of recursive dispose alltogether by passing dispose={null}\n        if (child.dispose !== null) {\n            scheduler.unstable_runWithPriority(scheduler.unstable_IdlePriority, function() {\n                // Remove interactivity\n                if (child.__container) child.__container.__interaction = child.__container.__interaction.filter(function(x) {\n                    return x !== child;\n                }); // Remove nested child objects\n                removeRecursive(child.__objects, child);\n                removeRecursive(child.children, child, true); // Dispose item\n                if (child.dispose) child.dispose(); // Remove references\n                delete child.__container;\n                delete child.__objects;\n            });\n        }\n    }\n}\nfunction switchInstance(instance, type, newProps, fiber) {\n    var parent = instance.parent;\n    var newInstance = createInstance(type, newProps, instance.__container, null, fiber);\n    removeChild(parent, instance);\n    appendChild(parent, newInstance) // This evil hack switches the react-internal fiber node\n    ;\n    [\n        fiber,\n        fiber.alternate\n    ].forEach(function(fiber) {\n        if (fiber !== null) {\n            fiber.stateNode = newInstance;\n            if (fiber.ref) {\n                if (is.fun(fiber.ref)) fiber.ref(newInstance);\n                else fiber.ref.current = newInstance;\n            }\n        }\n    });\n}\nvar Renderer = Reconciler({\n    now: scheduler.unstable_now,\n    createInstance: createInstance,\n    removeChild: removeChild,\n    appendChild: appendChild,\n    insertBefore: insertBefore,\n    // @ts-ignore\n    warnsIfNotActing: true,\n    supportsMutation: true,\n    isPrimaryRenderer: false,\n    scheduleTimeout: is.fun(setTimeout) ? setTimeout : undefined,\n    cancelTimeout: is.fun(clearTimeout) ? clearTimeout : undefined,\n    // @ts-ignore\n    setTimeout: is.fun(setTimeout) ? setTimeout : undefined,\n    // @ts-ignore\n    clearTimeout: is.fun(clearTimeout) ? clearTimeout : undefined,\n    noTimeout: -1,\n    appendInitialChild: appendChild,\n    appendChildToContainer: appendChild,\n    removeChildFromContainer: removeChild,\n    insertInContainerBefore: insertBefore,\n    commitUpdate: function commitUpdate(instance, updatePayload, type, oldProps, newProps, fiber) {\n        if (instance.__instance && newProps.object && newProps.object !== instance) {\n            // <instance object={...} /> where the object reference has changed\n            switchInstance(instance, type, newProps, fiber);\n        } else {\n            // This is a data object, let\'s extract critical information about it\n            var _newProps$args = newProps.args, argsNew = _newProps$args === void 0 ? [] : _newProps$args, restNew = _objectWithoutPropertiesLoose(newProps, [\n                "args"\n            ]);\n            var _oldProps$args = oldProps.args, argsOld = _oldProps$args === void 0 ? [] : _oldProps$args, restOld = _objectWithoutPropertiesLoose(oldProps, [\n                "args"\n            ]); // If it has new props or arguments, then it needs to be re-instanciated\n            var hasNewArgs = argsNew.some(function(value, index) {\n                return is.obj(value) ? Object.entries(value).some(function(_ref3) {\n                    var key = _ref3[0], val = _ref3[1];\n                    return val !== argsOld[index][key];\n                }) : value !== argsOld[index];\n            });\n            if (hasNewArgs) {\n                // Next we create a new instance and append it again\n                switchInstance(instance, type, newProps, fiber);\n            } else {\n                // Otherwise just overwrite props\n                applyProps(instance, restNew, restOld, true);\n            }\n        }\n    },\n    hideInstance: function hideInstance(instance) {\n        if (instance.isObject3D) {\n            instance.visible = false;\n            invalidateInstance(instance);\n        }\n    },\n    unhideInstance: function unhideInstance(instance, props) {\n        if (instance.isObject3D && props.visible == null || props.visible) {\n            instance.visible = true;\n            invalidateInstance(instance);\n        }\n    },\n    hideTextInstance: function hideTextInstance() {\n        throw new Error("Text is not allowed in the react-three-fibre tree. You may have extraneous whitespace between components.");\n    },\n    getPublicInstance: function getPublicInstance(instance) {\n        return instance;\n    },\n    getRootHostContext: function getRootHostContext() {\n        return emptyObject;\n    },\n    getChildHostContext: function getChildHostContext() {\n        return emptyObject;\n    },\n    createTextInstance: function createTextInstance() {},\n    finalizeInitialChildren: function finalizeInitialChildren() {\n        return false;\n    },\n    prepareUpdate: function prepareUpdate() {\n        return emptyObject;\n    },\n    shouldDeprioritizeSubtree: function shouldDeprioritizeSubtree() {\n        return false;\n    },\n    prepareForCommit: function prepareForCommit() {},\n    resetAfterCommit: function resetAfterCommit() {},\n    shouldSetTextContent: function shouldSetTextContent() {\n        return false;\n    }\n});\nvar hasSymbol = is.fun(Symbol) && Symbol["for"];\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol["for"]("react.portal") : 0xeaca;\nfunction render(element, container, state) {\n    var root = roots.get(container);\n    if (!root) {\n        container.__state = state; // @ts-ignore\n        var newRoot = root = Renderer.createContainer(container, state !== undefined && state.current.concurrent ? 2 : 0, false, null);\n        roots.set(container, newRoot);\n    }\n    Renderer.updateContainer(element, root, null, function() {\n        return undefined;\n    });\n    return Renderer.getPublicRootInstance(root);\n}\nfunction unmountComponentAtNode(container, callback) {\n    var root = roots.get(container);\n    if (root) Renderer.updateContainer(null, root, null, function() {\n        roots["delete"](container);\n        if (callback) callback(container);\n    });\n}\nfunction createPortal(children, containerInfo, implementation, key) {\n    if (key === void 0) {\n        key = null;\n    }\n    if (!containerInfo.__objects) containerInfo.__objects = [];\n    return {\n        $$typeof: REACT_PORTAL_TYPE,\n        key: key == null ? null : "" + key,\n        children: children,\n        containerInfo: containerInfo,\n        implementation: implementation\n    };\n}\nRenderer.injectIntoDevTools({\n    bundleType:  false ? 0 : 1,\n    //@ts-ignore\n    findHostInstanceByFiber: function findHostInstanceByFiber() {\n        return null;\n    },\n    version: React__default.version,\n    rendererPackageName: "react-three-fiber"\n});\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n    var it;\n    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {\n        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {\n            if (it) o = it;\n            var i = 0;\n            return function() {\n                if (i >= o.length) return {\n                    done: true\n                };\n                return {\n                    done: false,\n                    value: o[i++]\n                };\n            };\n        }\n        throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");\n    }\n    it = o[Symbol.iterator]();\n    return it.next.bind(it);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === "string") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === "Object" && o.constructor) n = o.constructor.name;\n    if (n === "Map" || n === "Set") return Array.from(o);\n    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++){\n        arr2[i] = arr[i];\n    }\n    return arr2;\n}\nfunction isOrthographicCamera(def) {\n    return def.isOrthographicCamera;\n}\nfunction makeId(event) {\n    return (event.eventObject || event.object).uuid + "/" + event.index;\n}\nvar stateContext = /*#__PURE__*/ React.createContext({});\nvar useCanvas = function useCanvas(props) {\n    var children = props.children, gl = props.gl, camera = props.camera, orthographic = props.orthographic, raycaster = props.raycaster, size = props.size, pixelRatio = props.pixelRatio, _props$vr = props.vr, vr = _props$vr === void 0 ? false : _props$vr, _props$concurrent = props.concurrent, concurrent = _props$concurrent === void 0 ? false : _props$concurrent, _props$shadowMap = props.shadowMap, shadowMap = _props$shadowMap === void 0 ? false : _props$shadowMap, _props$colorManagemen = props.colorManagement, colorManagement = _props$colorManagemen === void 0 ? true : _props$colorManagemen, _props$invalidateFram = props.invalidateFrameloop, invalidateFrameloop = _props$invalidateFram === void 0 ? false : _props$invalidateFram, _props$updateDefaultC = props.updateDefaultCamera, updateDefaultCamera = _props$updateDefaultC === void 0 ? true : _props$updateDefaultC, _props$noEvents = props.noEvents, noEvents = _props$noEvents === void 0 ? false : _props$noEvents, onCreated = props.onCreated, onPointerMissed = props.onPointerMissed, forceResize = props.forceResize; // Local, reactive state\n    var _useState = React.useState(false), ready = _useState[0], setReady = _useState[1];\n    var _useState2 = React.useState(function() {\n        return new THREE.Vector2();\n    }), mouse = _useState2[0];\n    var _useState3 = React.useState(function() {\n        var ray = new THREE.Raycaster();\n        if (raycaster) {\n            var filter = raycaster.filter, raycasterProps = _objectWithoutPropertiesLoose(raycaster, [\n                "filter"\n            ]);\n            applyProps(ray, raycasterProps, {});\n        }\n        return ray;\n    }), defaultRaycaster = _useState3[0];\n    var _useState4 = React.useState(function() {\n        var scene = new THREE.Scene();\n        scene.__interaction = [];\n        scene.__objects = [];\n        return scene;\n    }), defaultScene = _useState4[0];\n    var _useState5 = React.useState(function() {\n        var cam = orthographic ? new THREE.OrthographicCamera(0, 0, 0, 0, 0.1, 1000) : new THREE.PerspectiveCamera(75, 0, 0.1, 1000);\n        cam.position.z = 5;\n        if (camera) applyProps(cam, camera, {}); // Always look at [0, 0, 0]\n        cam.lookAt(0, 0, 0);\n        return cam;\n    }), defaultCam = _useState5[0], _setDefaultCamera = _useState5[1];\n    var _useState6 = React.useState(function() {\n        return new THREE.Clock();\n    }), clock = _useState6[0]; // Public state\n    var state = React.useRef({\n        ready: false,\n        active: true,\n        manual: 0,\n        colorManagement: colorManagement,\n        vr: vr,\n        concurrent: concurrent,\n        noEvents: noEvents,\n        invalidateFrameloop: false,\n        frames: 0,\n        aspect: 0,\n        subscribers: [],\n        camera: defaultCam,\n        scene: defaultScene,\n        raycaster: defaultRaycaster,\n        mouse: mouse,\n        clock: clock,\n        gl: gl,\n        size: size,\n        viewport: null,\n        initialClick: [\n            0,\n            0\n        ],\n        initialHits: [],\n        pointer: new tinyEmitter.TinyEmitter(),\n        captured: undefined,\n        events: undefined,\n        subscribe: function subscribe(ref, priority) {\n            if (priority === void 0) {\n                priority = 0;\n            }\n            // If this subscription was given a priority, it takes rendering into its own hands\n            // For that reason we switch off automatic rendering and increase the manual flag\n            // As long as this flag is positive (there could be multiple render subscription)\n            // ..there can be no internal rendering at all\n            if (priority) state.current.manual++;\n            state.current.subscribers.push({\n                ref: ref,\n                priority: priority\n            }); // Sort layers from lowest to highest, meaning, highest priority renders last (on top of the other frames)\n            state.current.subscribers = state.current.subscribers.sort(function(a, b) {\n                return a.priority - b.priority;\n            });\n            return function() {\n                // Decrease manual flag if this subscription had a priority\n                if (priority) state.current.manual--;\n                state.current.subscribers = state.current.subscribers.filter(function(s) {\n                    return s.ref !== ref;\n                });\n            };\n        },\n        setDefaultCamera: function setDefaultCamera(camera) {\n            return _setDefaultCamera(camera);\n        },\n        invalidate: function invalidate$1() {\n            return invalidate(state);\n        },\n        intersect: function intersect(event, prepare) {\n            if (event === void 0) {\n                event = {};\n            }\n            if (prepare === void 0) {\n                prepare = true;\n            }\n            return handlePointerMove(event, prepare);\n        },\n        forceResize: forceResize\n    });\n    var getCurrentViewport = React.useCallback(function(camera, target) {\n        if (camera === void 0) {\n            camera = state.current.camera;\n        }\n        if (target === void 0) {\n            target = new THREE.Vector3(0, 0, 0);\n        }\n        var _state$current$size = state.current.size, width = _state$current$size.width, height = _state$current$size.height;\n        var distance = camera.position.distanceTo(target);\n        if (isOrthographicCamera(camera)) {\n            return {\n                width: width / camera.zoom,\n                height: height / camera.zoom,\n                factor: 1,\n                distance: distance\n            };\n        } else {\n            var fov = camera.fov * Math.PI / 180; // convert vertical fov to radians\n            var h = 2 * Math.tan(fov / 2) * distance; // visible height\n            var w = h * (width / height);\n            return {\n                width: w,\n                height: h,\n                factor: width / w,\n                distance: distance\n            };\n        }\n    }, []); // Writes locals into public state for distribution among subscribers, context, etc\n    React.useMemo(function() {\n        state.current.ready = ready;\n        state.current.size = size;\n        state.current.camera = defaultCam;\n        state.current.invalidateFrameloop = invalidateFrameloop;\n        state.current.vr = vr;\n        state.current.gl = gl;\n        state.current.concurrent = concurrent;\n        state.current.noEvents = noEvents; // Make viewport backwards compatible\n        state.current.viewport = getCurrentViewport;\n    }, [\n        invalidateFrameloop,\n        vr,\n        concurrent,\n        noEvents,\n        ready,\n        size,\n        defaultCam,\n        gl\n    ]); // Adjusts default camera\n    React.useMemo(function() {\n        state.current.aspect = size.width / size.height; // Assign viewport props to the function\n        Object.assign(state.current.viewport, getCurrentViewport()); // #92 (https://github.com/drcmda/react-three-fiber/issues/92)\n        // Sometimes automatic default camera adjustment isn\'t wanted behaviour\n        if (updateDefaultCamera) {\n            if (isOrthographicCamera(defaultCam)) {\n                defaultCam.left = size.width / -2;\n                defaultCam.right = size.width / 2;\n                defaultCam.top = size.height / 2;\n                defaultCam.bottom = size.height / -2;\n            } else {\n                defaultCam.aspect = state.current.aspect;\n            }\n            defaultCam.updateProjectionMatrix(); // #178: https://github.com/react-spring/react-three-fiber/issues/178\n            // Update matrix world since the renderer is a frame late\n            defaultCam.updateMatrixWorld();\n        }\n        gl.setSize(size.width, size.height);\n        if (ready) invalidate(state);\n    }, [\n        defaultCam,\n        size,\n        updateDefaultCamera\n    ]);\n    /** Events ------------------------------------------------------------------------------------------------ */ /** Sets up defaultRaycaster */ var prepareRay = React.useCallback(function(_ref) {\n        var clientX = _ref.clientX, clientY = _ref.clientY;\n        if (clientX !== void 0) {\n            var _state$current$size2 = state.current.size, left = _state$current$size2.left, right = _state$current$size2.right, top = _state$current$size2.top, bottom = _state$current$size2.bottom;\n            mouse.set((clientX - left) / (right - left) * 2 - 1, -((clientY - top) / (bottom - top)) * 2 + 1);\n            defaultRaycaster.setFromCamera(mouse, state.current.camera);\n        }\n    }, []);\n    /** Intersects interaction objects using the event input */ var intersect = React.useCallback(function(event, filter) {\n        // Skip event handling when noEvents is set\n        if (state.current.noEvents) return [];\n        var seen = new Set();\n        var hits = []; // Allow callers to eliminate event objects\n        var eventsObjects = filter ? filter(state.current.scene.__interaction) : state.current.scene.__interaction; // Intersect known handler objects and filter against duplicates\n        var intersects = defaultRaycaster.intersectObjects(eventsObjects, true).filter(function(item) {\n            var id = makeId(item);\n            if (seen.has(id)) return false;\n            seen.add(id);\n            return true;\n        }); // #16031: (https://github.com/mrdoob/three.js/issues/16031)\n        // Allow custom userland intersect sort order\n        if (raycaster && raycaster.filter && sharedState.current) intersects = raycaster.filter(intersects, sharedState.current);\n        for(var _iterator = _createForOfIteratorHelperLoose(intersects), _step; !(_step = _iterator()).done;){\n            var _intersect = _step.value;\n            var eventObject = _intersect.object; // Bubble event up\n            while(eventObject){\n                var handlers = eventObject.__handlers;\n                if (handlers) hits.push(_extends({}, _intersect, {\n                    eventObject: eventObject\n                }));\n                eventObject = eventObject.parent;\n            }\n        }\n        return hits;\n    }, []);\n    /**  Calculates click deltas */ var calculateDistance = React.useCallback(function(event) {\n        var dx = event.clientX - state.current.initialClick[0];\n        var dy = event.clientY - state.current.initialClick[1];\n        return Math.round(Math.sqrt(dx * dx + dy * dy));\n    }, []);\n    var hovered = React.useMemo(function() {\n        return new Map();\n    }, []);\n    /**  Handles intersections by forwarding them to handlers */ var temp = new THREE.Vector3();\n    var handleIntersects = React.useCallback(function(event, fn, filter) {\n        // Get fresh intersects\n        var intersections = intersect(event, filter); // If the interaction is captured take that into account, the captured event has to be part of the intersects\n        if (state.current.captured && event.type !== "click" && event.type !== "wheel") {\n            state.current.captured.forEach(function(captured) {\n                if (!intersections.find(function(hit) {\n                    return hit.eventObject === captured.eventObject;\n                })) intersections.push(captured);\n            });\n        } // If anything has been found, forward it to the event listeners\n        if (intersections.length) {\n            (function() {\n                var unprojectedPoint = temp.set(mouse.x, mouse.y, 0).unproject(state.current.camera);\n                var delta = event.type === "click" ? calculateDistance(event) : 0;\n                var releasePointerCapture = function releasePointerCapture(id) {\n                    return event.target.releasePointerCapture(id);\n                };\n                var localState = {\n                    stopped: false,\n                    captured: false\n                };\n                var _loop = function _loop() {\n                    var hit = _step2.value;\n                    var setPointerCapture = function setPointerCapture(id) {\n                        // If the hit is going to be captured flag that we\'re in captured state\n                        if (!localState.captured) {\n                            localState.captured = true; // The captured hit array is reset to collect hits\n                            state.current.captured = [];\n                        } // Push hits to the array\n                        if (state.current.captured) state.current.captured.push(hit) // Call the original event now\n                        ;\n                        event.target.setPointerCapture(id);\n                    };\n                    var raycastEvent = _extends({}, event, hit, {\n                        intersections: intersections,\n                        stopped: localState.stopped,\n                        delta: delta,\n                        unprojectedPoint: unprojectedPoint,\n                        ray: defaultRaycaster.ray,\n                        camera: state.current.camera,\n                        // Hijack stopPropagation, which just sets a flag\n                        stopPropagation: function stopPropagation() {\n                            return raycastEvent.stopped = localState.stopped = true;\n                        },\n                        // Pointer-capture needs the hit, on which the user may call stopPropagation()\n                        // This makes it harder to use the actual event, because then we loose the connection\n                        // to the actual hit, which would mean it\'s picking up all intersects ...\n                        target: _extends({}, event.target, {\n                            setPointerCapture: setPointerCapture,\n                            releasePointerCapture: releasePointerCapture\n                        }),\n                        currentTarget: _extends({}, event.currentTarget, {\n                            setPointerCapture: setPointerCapture,\n                            releasePointerCapture: releasePointerCapture\n                        }),\n                        sourceEvent: event\n                    });\n                    fn(raycastEvent); // Event bubbling may me interrupted by stopPropagation, but that should only include\n                    // events that aren\'t capturing, since these are in the middle of a gesture and should not\n                    // be disturbed until they resolve.\n                    if (localState.stopped === true && localState.captured == false) {\n                        // Propagation is stopped, remove all other hover records\n                        // An event handler is only allowed to flush other handlers if it is hovered itself\n                        if (hovered.size && Array.from(hovered.values()).find(function(i) {\n                            return i.object === hit.object;\n                        })) {\n                            handlePointerCancel(raycastEvent, [\n                                hit\n                            ]);\n                        }\n                        return "break";\n                    }\n                };\n                for(var _iterator2 = _createForOfIteratorHelperLoose(intersections), _step2; !(_step2 = _iterator2()).done;){\n                    var _ret = _loop();\n                    if (_ret === "break") break;\n                }\n            })();\n        }\n        return intersections;\n    }, []);\n    var handlePointerMove = React.useCallback(function(event, prepare) {\n        if (prepare === void 0) {\n            prepare = true;\n        }\n        state.current.pointer.emit("pointerMove", event);\n        if (prepare) prepareRay(event);\n        var hits = handleIntersects(event, function(data) {\n            var eventObject = data.eventObject;\n            var handlers = eventObject.__handlers; // Check presence of handlers\n            if (!handlers) return; // Call mouse move\n            if (handlers.pointerMove) handlers.pointerMove(data); // Check if mouse enter or out is present\n            if (handlers.pointerOver || handlers.pointerEnter || handlers.pointerOut || handlers.pointerLeave) {\n                var id = makeId(data);\n                var hoveredItem = hovered.get(id);\n                if (!hoveredItem) {\n                    // If the object wasn\'t previously hovered, book it and call its handler\n                    hovered.set(id, data);\n                    if (handlers.pointerOver) handlers.pointerOver(_extends({}, data, {\n                        type: "pointerover"\n                    }));\n                    if (handlers.pointerEnter) handlers.pointerEnter(_extends({}, data, {\n                        type: "pointerenter"\n                    }));\n                } else if (hoveredItem.stopped) {\n                    // If the object was previously hovered and stopped, we shouldn\'t allow other items to proceed\n                    data.stopPropagation();\n                }\n            }\n        }, function(objects) {\n            return objects.filter(function(obj) {\n                return [\n                    "Move",\n                    "Over",\n                    "Enter",\n                    "Out",\n                    "Leave"\n                ].some(function(name) {\n                    return obj.__handlers["pointer" + name];\n                });\n            });\n        }); // Take care of unhover\n        handlePointerCancel(event, hits, prepare);\n        return hits;\n    }, []);\n    var handlePointerCancel = React.useCallback(function(event, hits, prepare) {\n        if (prepare === void 0) {\n            prepare = true;\n        }\n        state.current.pointer.emit("pointerCancel", event);\n        if (prepare) prepareRay(event);\n        if (!hits) hits = handleIntersects(event, function() {\n            return null;\n        });\n        Array.from(hovered.values()).forEach(function(data) {\n            // When no objects were hit or the the hovered object wasn\'t found underneath the cursor\n            // we call onPointerOut and delete the object from the hovered-elements map\n            if (hits && (!hits.length || !hits.find(function(i) {\n                return i.eventObject === data.eventObject;\n            }))) {\n                var eventObject = data.eventObject;\n                var handlers = eventObject.__handlers;\n                if (handlers) {\n                    if (handlers.pointerOut) handlers.pointerOut(_extends({}, data, {\n                        type: "pointerout"\n                    }));\n                    if (handlers.pointerLeave) handlers.pointerLeave(_extends({}, data, {\n                        type: "pointerleave"\n                    }));\n                }\n                hovered["delete"](makeId(data));\n            }\n        });\n    }, []);\n    var handlePointer = React.useCallback(function(name) {\n        return function(event, prepare) {\n            if (prepare === void 0) {\n                prepare = true;\n            }\n            state.current.pointer.emit(name, event);\n            if (prepare) prepareRay(event);\n            var hits = handleIntersects(event, function(data) {\n                var eventObject = data.eventObject;\n                var handlers = eventObject.__handlers;\n                if (handlers && handlers[name]) {\n                    // Forward all events back to their respective handlers with the exception of click events,\n                    // which must use the initial target\n                    if (name !== "click" && name !== "contextMenu" && name !== "doubleClick" || state.current.initialHits.includes(eventObject)) {\n                        handlers[name](data);\n                    }\n                }\n            }); // If a click yields no results, pass it back to the user as a miss\n            if (name === "pointerDown") {\n                state.current.initialClick = [\n                    event.clientX,\n                    event.clientY\n                ];\n                state.current.initialHits = hits.map(function(hit) {\n                    return hit.eventObject;\n                });\n            }\n            if ((name === "click" || name === "contextMenu" || name === "doubleClick") && !hits.length && onPointerMissed) {\n                if (calculateDistance(event) <= 2) onPointerMissed();\n            }\n        };\n    }, [\n        onPointerMissed\n    ]);\n    React.useMemo(function() {\n        state.current.events = {\n            onClick: handlePointer("click"),\n            onContextMenu: handlePointer("contextMenu"),\n            onDoubleClick: handlePointer("doubleClick"),\n            onWheel: handlePointer("wheel"),\n            onPointerDown: handlePointer("pointerDown"),\n            onPointerUp: handlePointer("pointerUp"),\n            onPointerLeave: function onPointerLeave(e) {\n                return handlePointerCancel(e, []);\n            },\n            onPointerMove: handlePointerMove,\n            // onGotPointerCapture is not needed any longer because the behaviour is hacked into\n            // the event itself (see handleIntersects). But in order for non-web targets to simulate\n            // it we keep the legacy event, which simply flags all current intersects as captured\n            onGotPointerCaptureLegacy: function onGotPointerCaptureLegacy(e) {\n                return state.current.captured = intersect(e);\n            },\n            onLostPointerCapture: function onLostPointerCapture(e) {\n                return state.current.captured = undefined, handlePointerCancel(e);\n            }\n        };\n    }, [\n        onPointerMissed\n    ]);\n    /** Events ------------------------------------------------------------------------------------------------- */ // Only trigger the context provider when necessary\n    var sharedState = React.useRef();\n    React.useMemo(function() {\n        var _state$current = state.current, ready = _state$current.ready, manual = _state$current.manual, vr = _state$current.vr, noEvents = _state$current.noEvents, invalidateFrameloop = _state$current.invalidateFrameloop, frames = _state$current.frames, subscribers = _state$current.subscribers, captured = _state$current.captured, initialClick = _state$current.initialClick, initialHits = _state$current.initialHits, props = _objectWithoutPropertiesLoose(_state$current, [\n            "ready",\n            "manual",\n            "vr",\n            "noEvents",\n            "invalidateFrameloop",\n            "frames",\n            "subscribers",\n            "captured",\n            "initialClick",\n            "initialHits"\n        ]);\n        sharedState.current = props;\n    }, [\n        size,\n        defaultCam\n    ]); // Update pixel ratio\n    React.useLayoutEffect(function() {\n        return void (pixelRatio && gl.setPixelRatio(pixelRatio));\n    }, [\n        pixelRatio\n    ]); // Update shadow map\n    React.useLayoutEffect(function() {\n        if (shadowMap) {\n            gl.shadowMap.enabled = true;\n            if (typeof shadowMap === "object") Object.assign(gl, shadowMap);\n            else gl.shadowMap.type = THREE.PCFSoftShadowMap;\n        }\n        if (colorManagement) {\n            gl.toneMapping = THREE.ACESFilmicToneMapping;\n            gl.outputEncoding = THREE.sRGBEncoding;\n        }\n    }, [\n        shadowMap,\n        colorManagement\n    ]); // This component is a bridge into the three render context, when it gets rendered\n    // we know we are ready to compile shaders, call subscribers, etc\n    var Canvas = React.useCallback(function Canvas(props) {\n        var activate = function activate() {\n            return setReady(true);\n        }; // eslint-disable-next-line react-hooks/rules-of-hooks\n        React.useEffect(function() {\n            var result = onCreated && onCreated(state.current);\n            return void (result && result.then ? result.then(activate) : activate());\n        }, []);\n        return props.children;\n    }, []); // Render v-dom into scene\n    React.useLayoutEffect(function() {\n        render(/*#__PURE__*/ React.createElement(Canvas, null, /*#__PURE__*/ React.createElement(stateContext.Provider, {\n            value: sharedState.current\n        }, typeof children === "function" ? children(state.current) : children)), defaultScene, state);\n    }, [\n        ready,\n        children,\n        sharedState.current\n    ]);\n    React.useLayoutEffect(function() {\n        if (ready) {\n            // Start render-loop, either via RAF or setAnimationLoop for VR\n            if (!state.current.vr) {\n                invalidate(state);\n            } else if ((gl.xr || gl.vr) && gl.setAnimationLoop) {\n                (gl.xr || gl.vr).enabled = true;\n                gl.setAnimationLoop(function(t) {\n                    return renderGl(state, t, 0, true);\n                });\n            } else console.warn("the gl instance does not support VR!");\n        }\n    }, [\n        ready,\n        invalidateFrameloop\n    ]); // Dispose renderer on unmount\n    React.useEffect(function() {\n        return function() {\n            if (state.current.gl) {\n                state.current.gl.renderLists.dispose();\n                if (state.current.gl.forceContextLoss) state.current.gl.forceContextLoss();\n                dispose(state.current.gl);\n            }\n            unmountComponentAtNode(state.current.scene, function() {\n                dispose(state.current.scene);\n                dispose(state.current.raycaster);\n                dispose(state.current.camera);\n                dispose(state.current);\n            });\n        };\n    }, []);\n    return state.current.events;\n};\nfunction dispose(obj) {\n    if (obj.dispose) obj.dispose();\n    for(var p in obj){\n        if (typeof p === "object" && p.dispose) p.dispose();\n        delete obj[p];\n    }\n}\nfunction useContext(context) {\n    var result = React.useContext(context);\n    if (!result) {\n        console.warn("hooks can only be used within the canvas! https://github.com/react-spring/react-three-fiber#hooks");\n    }\n    return result;\n}\nfunction useFrame(callback, renderPriority) {\n    if (renderPriority === void 0) {\n        renderPriority = 0;\n    }\n    var _useContext = useContext(stateContext), subscribe = _useContext.subscribe; // Update ref\n    var ref = React.useRef(callback);\n    React.useLayoutEffect(function() {\n        return void (ref.current = callback);\n    }, [\n        callback\n    ]); // Subscribe/unsub\n    React.useEffect(function() {\n        var unsubscribe = subscribe(ref, renderPriority);\n        return function() {\n            return unsubscribe();\n        };\n    }, [\n        renderPriority\n    ]);\n    return null;\n}\nfunction useThree() {\n    return useContext(stateContext);\n}\nfunction useUpdate(callback, dependents, optionalRef) {\n    var _useContext2 = useContext(stateContext), invalidate = _useContext2.invalidate;\n    var localRef = React.useRef();\n    var ref = optionalRef ? optionalRef : localRef;\n    React.useLayoutEffect(function() {\n        if (ref.current) {\n            callback(ref.current);\n            invalidate();\n        }\n    }, dependents);\n    return ref;\n}\nfunction useResource(optionalRef) {\n    var _useState = React.useState(false), _ = _useState[0], forceUpdate = _useState[1];\n    var localRef = React.useRef(undefined);\n    var ref = optionalRef ? optionalRef : localRef;\n    React.useLayoutEffect(function() {\n        return void forceUpdate(function(i) {\n            return !i;\n        });\n    }, [\n        ref.current\n    ]);\n    return [\n        ref,\n        ref.current\n    ];\n}\nfunction useLoader(Proto, url, extensions, onProgress) {\n    var loader = React.useMemo(function() {\n        // Construct new loader\n        var temp = new Proto(); // Run loader extensions\n        if (extensions) extensions(temp);\n        return temp;\n    }, [\n        Proto\n    ]); // Use suspense to load async assets\n    var results = usePromise(function(Proto, url) {\n        var urlArray = Array.isArray(url) ? url : [\n            url\n        ];\n        return Promise.all(urlArray.map(function(url) {\n            return new Promise(function(res, reject) {\n                return loader.load(url, function(data) {\n                    if (data.scene) {\n                        data.nodes = {};\n                        data.materials = {};\n                        data.scene.traverse(function(obj) {\n                            var _extends2;\n                            if (obj.name) data.nodes = _extends({}, data.nodes, (_extends2 = {}, _extends2[obj.name] = obj, _extends2));\n                            if (obj.material && !data.materials[obj.material.name]) data.materials[obj.material.name] = obj.material;\n                        });\n                    }\n                    res(data);\n                }, onProgress, function(error) {\n                    return reject(error.message);\n                });\n            });\n        }));\n    }, [\n        Proto,\n        url\n    ]); // Return the object/s\n    return Array.isArray(url) ? results : results[0];\n}\nvar defaultStyles = {\n    position: "relative",\n    width: "100%",\n    height: "100%",\n    overflow: "hidden"\n};\nfunction Content(_ref) {\n    var children = _ref.children, setEvents = _ref.setEvents, container = _ref.container, renderer = _ref.renderer, effects = _ref.effects, props = _objectWithoutPropertiesLoose(_ref, [\n        "children",\n        "setEvents",\n        "container",\n        "renderer",\n        "effects"\n    ]);\n    // Create renderer\n    var _useState = React.useState(renderer), gl = _useState[0];\n    if (!gl) console.warn("No renderer created!"); // Mount and unmount management\n    React.useEffect(function() {\n        return effects && effects(gl, container);\n    }, []); // Init canvas, fetch events, hand them back to the wrapping div\n    var events = useCanvas(_extends({}, props, {\n        children: children,\n        gl: gl\n    }));\n    React.useEffect(function() {\n        return void setEvents(events);\n    }, [\n        events\n    ]);\n    return null;\n}\nvar ResizeContainer = /*#__PURE__*/ React__default.memo(function ResizeContainer(props) {\n    var renderer = props.renderer, effects = props.effects, children = props.children, vr = props.vr, gl2 = props.gl2, concurrent = props.concurrent, shadowMap = props.shadowMap, colorManagement = props.colorManagement, orthographic = props.orthographic, invalidateFrameloop = props.invalidateFrameloop, updateDefaultCamera = props.updateDefaultCamera, noEvents = props.noEvents, gl = props.gl, camera = props.camera, raycaster = props.raycaster, pixelRatio = props.pixelRatio, onCreated = props.onCreated, onPointerMissed = props.onPointerMissed, preRender = props.preRender, resize = props.resize, style = props.style, restSpread = _objectWithoutPropertiesLoose(props, [\n        "renderer",\n        "effects",\n        "children",\n        "vr",\n        "gl2",\n        "concurrent",\n        "shadowMap",\n        "colorManagement",\n        "orthographic",\n        "invalidateFrameloop",\n        "updateDefaultCamera",\n        "noEvents",\n        "gl",\n        "camera",\n        "raycaster",\n        "pixelRatio",\n        "onCreated",\n        "onPointerMissed",\n        "preRender",\n        "resize",\n        "style"\n    ]);\n    var containerRef = React.useRef(); // onGotPointerCaptureLegacy is a fake event used by non-web targets to simulate poinzter capture\n    var _useState2 = React.useState({}), _useState2$ = _useState2[0], onGotPointerCaptureLegacy = _useState2$.onGotPointerCaptureLegacy, events = _objectWithoutPropertiesLoose(_useState2$, [\n        "onGotPointerCaptureLegacy"\n    ]), setEvents = _useState2[1];\n    var _useMeasure = useMeasure(resize || {\n        scroll: true,\n        debounce: {\n            scroll: 50,\n            resize: 0\n        },\n        polyfill:  true ? resizeObserver.ResizeObserver : 0\n    }), bind = _useMeasure[0], size = _useMeasure[1], forceResize = _useMeasure[2]; // Flag view ready once it\'s been measured out\n    var readyFlag = React.useRef(false);\n    var ready = React.useMemo(function() {\n        return readyFlag.current = readyFlag.current || !!size.width && !!size.height;\n    }, [\n        size\n    ]);\n    var state = React.useMemo(function() {\n        return {\n            size: size,\n            forceResize: forceResize,\n            setEvents: setEvents,\n            container: containerRef.current\n        };\n    }, [\n        size\n    ]); // Allow Gatsby, Next and other server side apps to run. Will output styles to reduce flickering.\n    if (true) return /*#__PURE__*/ React__default.createElement("div", _extends({\n        style: _extends({}, defaultStyles, style)\n    }, restSpread), preRender); // Render the canvas into the dom\n    return /*#__PURE__*/ React__default.createElement("div", _extends({\n        ref: mergeRefs([\n            bind,\n            containerRef\n        ]),\n        style: _extends({}, defaultStyles, style)\n    }, events, restSpread), preRender, ready && /*#__PURE__*/ React__default.createElement(Content, _extends({}, props, state)));\n});\nvar Canvas = /*#__PURE__*/ React__default.memo(function Canvas(_ref) {\n    var children = _ref.children, props = _objectWithoutPropertiesLoose(_ref, [\n        "children"\n    ]);\n    var canvasRef = React.useRef();\n    return /*#__PURE__*/ React__default.createElement(ResizeContainer, _extends({}, props, {\n        renderer: function renderer() {\n            if (canvasRef.current) {\n                var params = _extends({\n                    antialias: true,\n                    alpha: true\n                }, props.gl);\n                var temp = new THREE.WebGLRenderer(_extends({\n                    powerPreference: "high-performance",\n                    //stencil: false,\n                    //depth: false,\n                    canvas: canvasRef.current,\n                    context: props.gl2 ? canvasRef.current.getContext("webgl2", params) : undefined\n                }, params));\n                return temp;\n            }\n        },\n        preRender: /*#__PURE__*/ React__default.createElement("canvas", {\n            ref: canvasRef,\n            style: {\n                display: "block"\n            }\n        })\n    }), children);\n});\nexports.Canvas = Canvas;\nexports.Renderer = Renderer;\nexports.addAfterEffect = addAfterEffect;\nexports.addEffect = addEffect;\nexports.addTail = addTail;\nexports.applyProps = applyProps;\nexports.createPortal = createPortal;\nexports.extend = extend;\nexports.forceResize = forceResize;\nexports.invalidate = invalidate;\nexports.isOrthographicCamera = isOrthographicCamera;\nexports.render = render;\nexports.renderGl = renderGl;\nexports.stateContext = stateContext;\nexports.unmountComponentAtNode = unmountComponentAtNode;\nexports.useCanvas = useCanvas;\nexports.useFrame = useFrame;\nexports.useLoader = useLoader;\nexports.useResource = useResource;\nexports.useThree = useThree;\nexports.useUpdate = useUpdate;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtdGhyZWUtZmliZXIvd2ViLmNqcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUU3RCxTQUFTQyxnQkFBaUJDLEVBQUU7SUFBSSxPQUFPLE1BQVEsT0FBT0EsT0FBTyxZQUFhLGFBQWFBLEtBQU1BLEVBQUUsQ0FBQyxVQUFVLEdBQUdBO0FBQUk7QUFFakgsSUFBSUMsV0FBV0YsZ0JBQWdCRyxtQkFBT0EsQ0FBQztBQUN2QyxJQUFJQyxnQ0FBZ0NKLGdCQUFnQkcsbUJBQU9BLENBQUM7QUFDNUQsSUFBSUUsYUFBYUwsZ0JBQWdCRyxtQkFBT0EsQ0FBQztBQUN6QyxJQUFJRyxRQUFRSCxtQkFBT0EsQ0FBQztBQUNwQixJQUFJSSxRQUFRSixtQkFBT0EsQ0FBQztBQUNwQixJQUFJSyxpQkFBaUJSLGdCQUFnQk87QUFDckMsSUFBSUUsYUFBYVQsZ0JBQWdCRyxtQkFBT0EsQ0FBQztBQUN6QyxJQUFJTyxZQUFZUCxtQkFBT0EsQ0FBQztBQUN4QixJQUFJUSxjQUFjUixtQkFBT0EsQ0FBQztBQUMxQixJQUFJUyxhQUFhWixnQkFBZ0JHLG1CQUFPQSxDQUFDO0FBQ3pDLElBQUlVLGFBQWFiLGdCQUFnQkcsbUJBQU9BLENBQUM7QUFDekMsSUFBSVcsaUJBQWlCWCxtQkFBT0EsQ0FBQztBQUM3QixJQUFJWSxZQUFZZixnQkFBZ0JHLG1CQUFPQSxDQUFDO0FBRXhDLFNBQVNhLGVBQWVDLEdBQUc7SUFBSSxJQUFJQyxNQUFNQyxhQUFhRixLQUFLO0lBQVcsT0FBTyxPQUFPQyxRQUFRLFdBQVdBLE1BQU1FLE9BQU9GO0FBQU07QUFFMUgsU0FBU0MsYUFBYUUsS0FBSyxFQUFFQyxJQUFJO0lBQUksSUFBSSxPQUFPRCxVQUFVLFlBQVlBLFVBQVUsTUFBTSxPQUFPQTtJQUFPLElBQUlFLE9BQU9GLEtBQUssQ0FBQ0csT0FBT0MsV0FBVyxDQUFDO0lBQUUsSUFBSUYsU0FBU0csV0FBVztRQUFFLElBQUlDLE1BQU1KLEtBQUtLLElBQUksQ0FBQ1AsT0FBT0MsUUFBUTtRQUFZLElBQUksT0FBT0ssUUFBUSxVQUFVLE9BQU9BO1FBQUssTUFBTSxJQUFJRSxVQUFVO0lBQWlEO0lBQUUsT0FBTyxDQUFDUCxTQUFTLFdBQVdGLFNBQVNVLE1BQUssRUFBR1Q7QUFBUTtBQUN4WCxJQUFJVSxRQUFRLElBQUlDO0FBQ2hCLElBQUlDLGNBQWMsQ0FBQztBQUNuQixJQUFJQyxLQUFLO0lBQ1BDLEtBQUssU0FBU0EsSUFBSUMsQ0FBQztRQUNqQixPQUFPQSxNQUFNeEMsT0FBT3dDLE1BQU0sQ0FBQ0YsR0FBR0csR0FBRyxDQUFDRDtJQUNwQztJQUNBRSxLQUFLLFNBQVNBLElBQUlGLENBQUM7UUFDakIsT0FBTyxPQUFPQSxNQUFNO0lBQ3RCO0lBQ0FHLEtBQUssU0FBU0EsSUFBSUgsQ0FBQztRQUNqQixPQUFPLE9BQU9BLE1BQU07SUFDdEI7SUFDQUksS0FBSyxTQUFTQSxJQUFJSixDQUFDO1FBQ2pCLE9BQU8sT0FBT0EsTUFBTTtJQUN0QjtJQUNBSyxLQUFLLFNBQVNBLElBQUlMLENBQUM7UUFDakIsT0FBT0EsTUFBTSxLQUFLO0lBQ3BCO0lBQ0FDLEtBQUssU0FBU0EsSUFBSUQsQ0FBQztRQUNqQixPQUFPTSxNQUFNQyxPQUFPLENBQUNQO0lBQ3ZCO0lBQ0FRLEtBQUssU0FBU0EsSUFBSVIsQ0FBQyxFQUFFUyxDQUFDO1FBQ3BCLHdEQUF3RDtRQUN4RCxJQUFJLE9BQU9ULE1BQU0sT0FBT1MsS0FBSyxDQUFDLENBQUNULE1BQU0sQ0FBQyxDQUFDUyxHQUFHLE9BQU8sT0FBTyxtQ0FBbUM7UUFFM0YsSUFBSVgsR0FBR0ssR0FBRyxDQUFDSCxNQUFNRixHQUFHTSxHQUFHLENBQUNKLE1BQU1GLEdBQUdDLEdBQUcsQ0FBQ0MsSUFBSSxPQUFPQSxNQUFNUyxHQUFHLHNEQUFzRDtRQUUvRyxJQUFJWCxHQUFHRyxHQUFHLENBQUNELE1BQU1BLEtBQUtTLEdBQUcsT0FBTyxNQUFNLCtCQUErQjtRQUVyRSxJQUFJQztRQUVKLElBQUtBLEtBQUtWLEVBQUc7WUFDWCxJQUFJLENBQUVVLENBQUFBLEtBQUtELENBQUFBLEdBQUksT0FBTztRQUN4QjtRQUVBLElBQUtDLEtBQUtELEVBQUc7WUFDWCxJQUFJVCxDQUFDLENBQUNVLEVBQUUsS0FBS0QsQ0FBQyxDQUFDQyxFQUFFLEVBQUUsT0FBTztRQUM1QjtRQUVBLE9BQU9aLEdBQUdPLEdBQUcsQ0FBQ0ssS0FBS1YsTUFBTVMsSUFBSTtJQUMvQjtBQUNGO0FBRUEsU0FBU0UsV0FBV0MsUUFBUSxFQUFFQyxJQUFJO0lBQ2hDLElBQUlDLFFBQVFELEtBQUtFLE1BQU07SUFDdkJGLEtBQUtHLElBQUksQ0FBQ0o7SUFDVixPQUFPO1FBQ0wsT0FBTyxLQUFLQyxLQUFLSSxNQUFNLENBQUNILE9BQU87SUFDakM7QUFDRjtBQUVBLElBQUlJLGdCQUFnQixFQUFFO0FBQ3RCLElBQUlDLHFCQUFxQixFQUFFO0FBQzNCLElBQUlDLG9CQUFvQixFQUFFO0FBQzFCLElBQUlDLFlBQVksU0FBU0EsVUFBVVQsUUFBUTtJQUN6QyxPQUFPRCxXQUFXQyxVQUFVTTtBQUM5QjtBQUNBLElBQUlJLGlCQUFpQixTQUFTQSxlQUFlVixRQUFRO0lBQ25ELE9BQU9ELFdBQVdDLFVBQVVPO0FBQzlCO0FBQ0EsSUFBSUksVUFBVSxTQUFTQSxRQUFRWCxRQUFRO0lBQ3JDLE9BQU9ELFdBQVdDLFVBQVVRO0FBQzlCO0FBQ0EsU0FBU0ksU0FBU0MsS0FBSyxFQUFFQyxTQUFTLEVBQUVDLE1BQU0sRUFBRUMsZ0JBQWdCO0lBQzFELElBQUlELFdBQVcsS0FBSyxHQUFHO1FBQ3JCQSxTQUFTO0lBQ1g7SUFFQSxJQUFJQyxxQkFBcUIsS0FBSyxHQUFHO1FBQy9CQSxtQkFBbUI7SUFDckI7SUFFQSxxQkFBcUI7SUFDckIsSUFBSUEsa0JBQWtCVixjQUFjVyxPQUFPLENBQUMsU0FBVUMsTUFBTTtRQUMxRCxPQUFPQSxPQUFPSixjQUFjQztJQUM5QixJQUFJLG9CQUFvQjtJQUV4QixJQUFJSSxRQUFRTixNQUFNTyxPQUFPLENBQUNDLEtBQUssQ0FBQ0MsUUFBUTtJQUN4Q1QsTUFBTU8sT0FBTyxDQUFDRyxXQUFXLENBQUNOLE9BQU8sQ0FBQyxTQUFVTyxHQUFHO1FBQzdDLE9BQU9BLElBQUlDLEdBQUcsQ0FBQ0wsT0FBTyxDQUFDUCxNQUFNTyxPQUFPLEVBQUVEO0lBQ3hDLElBQUksdUJBQXVCO0lBRTNCTixNQUFNTyxPQUFPLENBQUNNLE1BQU0sR0FBR0MsS0FBS0MsR0FBRyxDQUFDLEdBQUdmLE1BQU1PLE9BQU8sQ0FBQ00sTUFBTSxHQUFHO0lBQzFEWCxVQUFVLENBQUNGLE1BQU1PLE9BQU8sQ0FBQ1MsbUJBQW1CLEdBQUcsSUFBSWhCLE1BQU1PLE9BQU8sQ0FBQ00sTUFBTSxFQUFFLGlCQUFpQjtJQUUxRixJQUFJLENBQUNiLE1BQU1PLE9BQU8sQ0FBQ1UsTUFBTSxFQUFFakIsTUFBTU8sT0FBTyxDQUFDVyxFQUFFLENBQUNDLE1BQU0sQ0FBQ25CLE1BQU1PLE9BQU8sQ0FBQ2EsS0FBSyxFQUFFcEIsTUFBTU8sT0FBTyxDQUFDYyxNQUFNLEdBQUcscUJBQXFCO0lBRXBILElBQUlsQixrQkFBa0JULG1CQUFtQlUsT0FBTyxDQUFDLFNBQVVDLE1BQU07UUFDL0QsT0FBT0EsT0FBT0o7SUFDaEI7SUFDQSxPQUFPQztBQUNUO0FBQ0EsSUFBSW9CLFVBQVU7QUFFZCxTQUFTQyxXQUFXdEIsU0FBUztJQUMzQnFCLFVBQVU7SUFDVixJQUFJcEIsU0FBUyxHQUFHLHFCQUFxQjtJQUVyQ1QsY0FBY1csT0FBTyxDQUFDLFNBQVVDLE1BQU07UUFDcEMsT0FBT0EsT0FBT0osY0FBY0M7SUFDOUI7SUFDQWhDLE1BQU1rQyxPQUFPLENBQUMsU0FBVW9CLElBQUk7UUFDMUIsSUFBSXhCLFFBQVF3QixLQUFLQyxhQUFhLENBQUNDLE9BQU8sRUFBRSw0REFBNEQ7UUFFcEcsSUFBSTFCLE1BQU1PLE9BQU8sQ0FBQ29CLE1BQU0sSUFBSTNCLE1BQU1PLE9BQU8sQ0FBQ3FCLEtBQUssSUFBSyxFQUFDNUIsTUFBTU8sT0FBTyxDQUFDUyxtQkFBbUIsSUFBSWhCLE1BQU1PLE9BQU8sQ0FBQ00sTUFBTSxHQUFHLElBQUlYLFNBQVNILFNBQVNDLE9BQU9DLFdBQVdDO0lBQzNKLElBQUksMkJBQTJCO0lBRS9CUixtQkFBbUJVLE9BQU8sQ0FBQyxTQUFVQyxNQUFNO1FBQ3pDLE9BQU9BLE9BQU9KO0lBQ2hCO0lBQ0EsSUFBSUMsV0FBVyxHQUFHLE9BQU8yQixzQkFBc0JOO1NBQWlCO1FBQzlELDBEQUEwRDtRQUMxRDVCLGtCQUFrQlMsT0FBTyxDQUFDLFNBQVVDLE1BQU07WUFDeEMsT0FBT0EsT0FBT0o7UUFDaEI7SUFDRixFQUFFLHdCQUF3QjtJQUUxQnFCLFVBQVU7QUFDWjtBQUVBLFNBQVNRLFdBQVc5QixLQUFLLEVBQUVhLE1BQU07SUFDL0IsSUFBSWIsVUFBVSxLQUFLLEdBQUc7UUFDcEJBLFFBQVE7SUFDVjtJQUVBLElBQUlhLFdBQVcsS0FBSyxHQUFHO1FBQ3JCQSxTQUFTO0lBQ1g7SUFFQSxJQUFJYixVQUFVLE1BQU05QixNQUFNa0MsT0FBTyxDQUFDLFNBQVVvQixJQUFJO1FBQzlDLE9BQU9BLEtBQUtDLGFBQWEsQ0FBQ0MsT0FBTyxDQUFDbkIsT0FBTyxDQUFDTSxNQUFNLEdBQUdBO0lBQ3JEO1NBQVEsSUFBSWIsU0FBU0EsTUFBTU8sT0FBTyxFQUFFO1FBQ2xDLElBQUlQLE1BQU1PLE9BQU8sQ0FBQ3dCLEVBQUUsRUFBRTtRQUN0Qi9CLE1BQU1PLE9BQU8sQ0FBQ00sTUFBTSxHQUFHQTtJQUN6QjtJQUVBLElBQUksQ0FBQ1MsU0FBUztRQUNaQSxVQUFVO1FBQ1ZPLHNCQUFzQk47SUFDeEI7QUFDRjtBQUNBLFNBQVNTO0lBQ1A5RCxNQUFNa0MsT0FBTyxDQUFDLFNBQVVvQixJQUFJO1FBQzFCLE9BQU9BLEtBQUtDLGFBQWEsQ0FBQ0MsT0FBTyxDQUFDbkIsT0FBTyxDQUFDeUIsV0FBVztJQUN2RDtBQUNGO0FBQ0EsSUFBSUMsWUFBWSxDQUFDO0FBQ2pCLElBQUlDLFNBQVMsU0FBU0EsT0FBT0MsT0FBTztJQUNsQyxPQUFPLEtBQU1GLENBQUFBLFlBQVk1RixTQUFTLENBQUMsR0FBRzRGLFdBQVdFLFFBQU87QUFDMUQ7QUFDQSxTQUFTQyxXQUFXQyxRQUFRLEVBQUVDLFFBQVEsRUFBRUMsUUFBUSxFQUFFQyxZQUFZO0lBQzVELElBQUlELGFBQWEsS0FBSyxHQUFHO1FBQ3ZCQSxXQUFXLENBQUM7SUFDZDtJQUVBLElBQUlDLGlCQUFpQixLQUFLLEdBQUc7UUFDM0JBLGVBQWU7SUFDakI7SUFFQSwyQ0FBMkM7SUFDM0MsSUFBSUMsWUFBWUosU0FBU0ssV0FBVztJQUNwQyxJQUFJQyxZQUFZNUcsT0FBTzZHLElBQUksQ0FBQ04sVUFBVU8sTUFBTSxDQUFDLFNBQVV4RixHQUFHO1FBQ3hELE9BQU9nQixHQUFHVSxHQUFHLENBQUN1RCxRQUFRLENBQUNqRixJQUFJLEVBQUVrRixRQUFRLENBQUNsRixJQUFJO0lBQzVDO0lBQ0EsSUFBSXlGLFdBQVcvRyxPQUFPNkcsSUFBSSxDQUFDTixVQUFVTyxNQUFNLENBQUMsU0FBVXhGLEdBQUc7UUFDdkQscUJBQXFCO1FBQ3JCLHdCQUF3QjtRQUN4Qix5QkFBeUI7UUFDekIsbUVBQW1FO1FBQ25FLElBQUlnQixHQUFHSSxHQUFHLENBQUM2RCxRQUFRLENBQUNqRixJQUFJLEtBQUtBLElBQUkwRixVQUFVLENBQUMsT0FBTztZQUNqRCxPQUFPMUYsSUFBSTJGLFFBQVEsQ0FBQyxjQUFjM0YsSUFBSTJGLFFBQVEsQ0FBQyxZQUFZM0YsSUFBSTJGLFFBQVEsQ0FBQyxrQkFBa0IzRixJQUFJMkYsUUFBUSxDQUFDO1FBQ3pHO0lBQ0Y7SUFDQSxJQUFJQyxZQUFZVCxlQUFlekcsT0FBTzZHLElBQUksQ0FBQ0wsVUFBVU0sTUFBTSxDQUFDLFNBQVV4RixHQUFHO1FBQ3ZFLE9BQU9pRixRQUFRLENBQUNqRixJQUFJLEtBQUssS0FBSztJQUNoQyxLQUFLLEVBQUU7SUFDUCxJQUFJNkYsZ0JBQWdCLEVBQUUsQ0FBQ0MsTUFBTSxDQUFDUixXQUFXO1FBQUM7UUFBWTtRQUFPO0tBQU0sRUFBRVMsTUFBTSxDQUFDLFNBQVVDLEdBQUcsRUFBRUMsSUFBSTtRQUM3RixJQUFJQyxJQUFJRixHQUFHLENBQUNDLEtBQUssRUFDYkUsT0FBT2pILDhCQUE4QjhHLEtBQUs7WUFBQ0M7U0FBSyxDQUFDRyxHQUFHLENBQUN0RztRQUV6RCxPQUFPcUc7SUFDVCxHQUFHbEIsV0FBVywyREFBMkQ7SUFFekVXLFVBQVU3QyxPQUFPLENBQUMsU0FBVS9DLEdBQUc7UUFDN0IsT0FBT0EsUUFBUSxjQUFlNkYsQ0FBQUEsYUFBYSxDQUFDN0YsSUFBSSxHQUFHUSxTQUFRO0lBQzdEO0lBRUEsSUFBSTlCLE9BQU82RyxJQUFJLENBQUNNLGVBQWU1RCxNQUFNLEdBQUcsR0FBRztRQUN6Q3ZELE9BQU8ySCxPQUFPLENBQUNSLGVBQWU5QyxPQUFPLENBQUMsU0FBVXVELElBQUk7WUFDbEQsSUFBSXRHLE1BQU1zRyxJQUFJLENBQUMsRUFBRSxFQUNiekgsUUFBUXlILElBQUksQ0FBQyxFQUFFO1lBRW5CLElBQUksQ0FBQ2IsU0FBU0UsUUFBUSxDQUFDM0YsTUFBTTtnQkFDM0IsSUFBSXVHO2dCQUVKLElBQUlwQyxPQUFPYTtnQkFDWCxJQUFJd0IsU0FBU3JDLElBQUksQ0FBQ25FLElBQUk7Z0JBRXRCLElBQUlBLElBQUkyRixRQUFRLENBQUMsTUFBTTtvQkFDckIsSUFBSVUsVUFBVXJHLElBQUl5RyxLQUFLLENBQUM7b0JBQ3hCRCxTQUFTSCxRQUFRTixNQUFNLENBQUMsU0FBVUMsR0FBRyxFQUFFaEcsR0FBRzt3QkFDeEMsT0FBT2dHLEdBQUcsQ0FBQ2hHLElBQUk7b0JBQ2pCLEdBQUdnRixXQUFXLDJEQUEyRDtvQkFFekUsSUFBSSxDQUFFd0IsQ0FBQUEsVUFBVUEsT0FBT0UsR0FBRyxHQUFHO3dCQUMzQixJQUFJQyxtQkFBbUJOLFFBQVFPLE9BQU8sSUFDbENDLFFBQVFGLGdCQUFnQixDQUFDLEVBQUUsRUFDM0JHLGlCQUFpQkgsaUJBQWlCSSxLQUFLLENBQUM7d0JBRTVDNUMsT0FBTzJDLGVBQWVGLE9BQU8sR0FBR2IsTUFBTSxDQUFDLFNBQVVDLEdBQUcsRUFBRWhHLEdBQUc7NEJBQ3ZELE9BQU9nRyxHQUFHLENBQUNoRyxJQUFJO3dCQUNqQixHQUFHZ0Y7d0JBQ0hoRixNQUFNNkc7b0JBQ1I7Z0JBQ0YsRUFBRSwwREFBMEQ7Z0JBRzVELElBQUlHLG9CQUFvQixDQUFDVCx3QkFBd0J2QixTQUFTSyxXQUFXLEtBQUssT0FBTyxLQUFLLElBQUlrQixzQkFBc0JsQyxPQUFPLENBQUNuQixPQUFPLENBQUMrRCxlQUFlO2dCQUUvSSxJQUFJVCxVQUFVQSxPQUFPRSxHQUFHLElBQUtGLENBQUFBLE9BQU9VLElBQUksSUFBSVYsa0JBQWtCcEgsTUFBTStILE1BQU0sR0FBRztvQkFDM0UsSUFBSUM7b0JBRUoseURBQXlEO29CQUN6RCxJQUFJNUYsTUFBTUMsT0FBTyxDQUFDNUMsUUFBUSxDQUFDdUksVUFBVVosTUFBSyxFQUFHRSxHQUFHLENBQUNXLEtBQUssQ0FBQ0QsU0FBU3ZJLFFBQVEseUNBQXlDO3lCQUM1RyxJQUFJMkgsT0FBT1UsSUFBSSxJQUFJckksU0FBU0EsTUFBTXlJLFdBQVcsSUFBSWQsT0FBT2MsV0FBVyxDQUFDQyxJQUFJLEtBQUsxSSxNQUFNeUksV0FBVyxDQUFDQyxJQUFJLEVBQUVmLE9BQU9VLElBQUksQ0FBQ3JJLFFBQVEsb0VBQW9FO3lCQUUzTCxJQUFJQSxVQUFVMkIsV0FBVzt3QkFDMUJnRyxPQUFPRSxHQUFHLENBQUM3SCxRQUFRLHdDQUF3Qzt3QkFDM0QsK0RBQStEO3dCQUUvRCxJQUFJbUkscUJBQXFCUixrQkFBa0JwSCxNQUFNb0ksS0FBSyxFQUFFOzRCQUN0RGhCLE9BQU9pQixtQkFBbUI7d0JBQzVCO29CQUNGLEVBQUUsaUNBQWlDO2dCQUN6QyxPQUFPO29CQUNMdEQsSUFBSSxDQUFDbkUsSUFBSSxHQUFHbkIsT0FBTywwQ0FBMEM7b0JBQzdELCtEQUErRDtvQkFFL0QsSUFBSW1JLHFCQUFxQjdDLElBQUksQ0FBQ25FLElBQUksWUFBWVosTUFBTXNJLE9BQU8sRUFBRTt3QkFDM0R2RCxJQUFJLENBQUNuRSxJQUFJLENBQUMySCxRQUFRLEdBQUd2SSxNQUFNd0ksWUFBWTtvQkFDekM7Z0JBQ0Y7Z0JBRUFDLG1CQUFtQjdDO1lBQ3JCO1FBQ0YsSUFBSSxtRUFBbUU7UUFFdkUsSUFBSUcsZ0JBQWdCQyxhQUFhSixTQUFTOEMsT0FBTyxJQUFJOUMsU0FBUytDLFVBQVUsRUFBRTtZQUN4RS9DLFNBQVMrQyxVQUFVLEdBQUd2SDtZQUV0QixJQUFJd0IsUUFBUW9ELFVBQVU0QyxhQUFhLENBQUNDLE9BQU8sQ0FBQ2pEO1lBRTVDLElBQUloRCxRQUFRLENBQUMsR0FBR29ELFVBQVU0QyxhQUFhLENBQUM3RixNQUFNLENBQUNILE9BQU87UUFDeEQsRUFBRSw0QkFBNEI7UUFHOUIsSUFBSXlELFNBQVN4RCxNQUFNLEVBQUU7WUFDbkIsOENBQThDO1lBQzlDLElBQUltRCxhQUFhSixTQUFTOEMsT0FBTyxFQUFFMUMsVUFBVTRDLGFBQWEsQ0FBQzlGLElBQUksQ0FBQzhDLFdBQVcsNENBQTRDO1lBRXZIQSxTQUFTK0MsVUFBVSxHQUFHdEMsU0FBU00sTUFBTSxDQUFDLFNBQVVDLEdBQUcsRUFBRWhHLEdBQUc7Z0JBQ3RELElBQUlrSTtnQkFFSixPQUFPbEosU0FBUyxDQUFDLEdBQUdnSCxLQUFNa0MsQ0FBQUEsWUFBWSxDQUFDLEdBQUdBLFNBQVMsQ0FBQ2xJLElBQUltSSxNQUFNLENBQUMsR0FBR0MsV0FBVyxLQUFLcEksSUFBSXFJLE1BQU0sQ0FBQyxHQUFHLEdBQUdwRCxRQUFRLENBQUNqRixJQUFJLEVBQUVrSSxTQUFRO1lBQzVILEdBQUcsQ0FBQztRQUNOLEVBQUUsNEZBQTRGO1FBRzlGLElBQUlsRCxTQUFTc0QsTUFBTSxFQUFFQyxlQUFldkQ7SUFDdEM7QUFDRjtBQUVBLFNBQVM2QyxtQkFBbUI3QyxRQUFRO0lBQ2xDLElBQUlBLFNBQVNLLFdBQVcsSUFBSUwsU0FBU0ssV0FBVyxDQUFDaEIsT0FBTyxFQUFFSSxXQUFXTyxTQUFTSyxXQUFXLENBQUNoQixPQUFPO0FBQ25HO0FBRUEsU0FBU2tFLGVBQWV2RCxRQUFRO0lBQzlCLElBQUlBLFNBQVN3RCxRQUFRLEVBQUV4RCxTQUFTd0QsUUFBUSxDQUFDeEQ7QUFDM0M7QUFFQSxTQUFTeUQsZUFBZUMsSUFBSSxFQUFFQyxLQUFLLEVBQUV2RCxTQUFTLEVBQUV3RCxXQUFXLEVBQUVDLHNCQUFzQjtJQUNqRixJQUFJQyxhQUFhSCxNQUFNSSxJQUFJLEVBQ3ZCQSxPQUFPRCxlQUFlLEtBQUssSUFBSSxFQUFFLEdBQUdBLFlBQ3BDRSxRQUFROUosOEJBQThCeUosT0FBTztRQUFDO0tBQU87SUFFekQsSUFBSXBCLE9BQU8sS0FBS21CLElBQUksQ0FBQyxFQUFFLENBQUNPLFdBQVcsS0FBS1AsS0FBSzNCLEtBQUssQ0FBQztJQUNuRCxJQUFJL0I7SUFFSixJQUFJMEQsU0FBUyxhQUFhO1FBQ3hCLDJDQUEyQztRQUMzQ00sUUFBUWhLLFNBQVM7WUFDZmtLLFNBQVM7UUFDWCxHQUFHRjtRQUNIaEUsV0FBV2dFLE1BQU1HLE1BQU07UUFDdkJuRSxTQUFTb0UsVUFBVSxHQUFHO0lBQ3hCLE9BQU8sSUFBSVYsU0FBUyxPQUFPO1FBQ3pCMUQsV0FBVyxJQUFJZ0UsTUFBTUcsTUFBTSxDQUFDSjtJQUM5QixPQUFPO1FBQ0wsSUFBSXZDLFNBQVM1QixTQUFTLENBQUMyQyxLQUFLLElBQUluSSxLQUFLLENBQUNtSSxLQUFLO1FBRTNDLElBQUksQ0FBQ2YsUUFBUTtZQUNYLE1BQU0sTUFBT2UsT0FBTztRQUN0QjtRQUVBdkMsV0FBV2hFLEdBQUdHLEdBQUcsQ0FBQzRILFFBQVE1SixXQUFXcUgsUUFBUXVDLFFBQVEsSUFBSXZDLE9BQU91QztJQUNsRSxFQUFFLDREQUE0RDtJQUM5RCx1RkFBdUY7SUFHdkYsTUFBTzNELFVBQVVDLFdBQVcsQ0FBRTtRQUM1QkQsWUFBWUEsVUFBVUMsV0FBVztJQUNuQyxFQUFFLHVEQUF1RDtJQUN6RCw2RkFBNkY7SUFHN0YsSUFBSSxDQUFDeEUsTUFBTXdJLEdBQUcsQ0FBQ2pFLFlBQVk7UUFDekIsSUFBSWtFLEtBQUssU0FBU0EsR0FBR0MsSUFBSTtZQUN2QixJQUFJLENBQUNBLElBQUksQ0FBQyxTQUFTLEVBQUUsT0FBT0EsS0FBS0MsU0FBUyxJQUFJRCxLQUFLQyxTQUFTLENBQUNwRixhQUFhO2lCQUFNLE9BQU9rRixHQUFHQyxJQUFJLENBQUMsU0FBUztRQUMxRztRQUVBbkUsWUFBWWtFLEdBQUdUO0lBQ2pCLEVBQUUsc0JBQXNCO0lBR3hCN0QsU0FBU3lFLFNBQVMsR0FBRyxFQUFFO0lBQ3ZCekUsU0FBU0ssV0FBVyxHQUFHRCxXQUFXLHVDQUF1QztJQUV6RSxJQUFJbUMsS0FBS21DLFFBQVEsQ0FBQyxhQUFhO1FBQzdCVixRQUFRaEssU0FBUztZQUNmMkssUUFBUTtRQUNWLEdBQUdYO0lBQ0wsT0FBTyxJQUFJekIsS0FBS21DLFFBQVEsQ0FBQyxhQUFhO1FBQ3BDVixRQUFRaEssU0FBUztZQUNmMkssUUFBUTtRQUNWLEdBQUdYO0lBQ0wsRUFBRSwyRkFBMkY7SUFDN0YsZ0dBQWdHO0lBQ2hHLDZCQUE2QjtJQUc3QmpFLFdBQVdDLFVBQVVnRSxPQUFPLENBQUM7SUFDN0IsT0FBT2hFO0FBQ1Q7QUFFQSxTQUFTNEUsWUFBWUMsY0FBYyxFQUFFQyxLQUFLO0lBQ3hDLElBQUlBLE9BQU87UUFDVCxJQUFJQSxNQUFNQyxVQUFVLEVBQUVGLGVBQWVHLEdBQUcsQ0FBQ0Y7YUFBWTtZQUNuREQsZUFBZUosU0FBUyxDQUFDdkgsSUFBSSxDQUFDNEg7WUFFOUJBLE1BQU14QixNQUFNLEdBQUd1QixnQkFBZ0IsNkVBQTZFO1lBRTVHLElBQUlDLE1BQU1HLFdBQVcsRUFBRTtnQkFDckIsSUFBSSxDQUFDakosR0FBR0csR0FBRyxDQUFDMEksY0FBYyxDQUFDQyxNQUFNRyxXQUFXLENBQUMsR0FBR0osY0FBYyxDQUFDQyxNQUFNRyxXQUFXLENBQUMsR0FBRyxFQUFFO2dCQUN0RkosY0FBYyxDQUFDQyxNQUFNRyxXQUFXLENBQUMsQ0FBQy9ILElBQUksQ0FBQzRIO1lBQ3pDLE9BQU8sSUFBSUEsTUFBTUksWUFBWSxFQUFFO2dCQUM3QixJQUFJLENBQUNsSixHQUFHQyxHQUFHLENBQUM0SSxjQUFjLENBQUNDLE1BQU1JLFlBQVksQ0FBQyxFQUFFLENBQUMsR0FBR0wsY0FBYyxDQUFDQyxNQUFNSSxZQUFZLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQztnQkFDN0ZMLGNBQWMsQ0FBQ0MsTUFBTUksWUFBWSxDQUFDLEVBQUUsQ0FBQyxDQUFDSixNQUFNSSxZQUFZLENBQUMsRUFBRSxDQUFDLEdBQUdKO1lBQ2pFLE9BQU8sSUFBSUEsTUFBTUgsTUFBTSxFQUFFRSxjQUFjLENBQUNDLE1BQU1ILE1BQU0sQ0FBQyxHQUFHRztRQUMxRDtRQUNBdkIsZUFBZXVCO1FBQ2ZqQyxtQkFBbUJpQztJQUNyQjtBQUNGO0FBRUEsU0FBU0ssYUFBYU4sY0FBYyxFQUFFQyxLQUFLLEVBQUVNLFdBQVc7SUFDdEQsSUFBSU4sT0FBTztRQUNULElBQUlBLE1BQU1DLFVBQVUsRUFBRTtZQUNwQkQsTUFBTXhCLE1BQU0sR0FBR3VCO1lBQ2ZDLE1BQU1PLGFBQWEsQ0FBQztnQkFDbEIzQixNQUFNO1lBQ1I7WUFDQSxJQUFJNEIsZUFBZVQsZUFBZVUsUUFBUSxDQUFDL0UsTUFBTSxDQUFDLFNBQVVnRixPQUFPO2dCQUNqRSxPQUFPQSxZQUFZVjtZQUNyQixJQUFJLHNGQUFzRjtZQUUxRixJQUFJOUgsUUFBUXNJLGFBQWFyQyxPQUFPLENBQUNtQztZQUNqQ1AsZUFBZVUsUUFBUSxHQUFHLEVBQUUsQ0FBQ3pFLE1BQU0sQ0FBQ3dFLGFBQWF2RCxLQUFLLENBQUMsR0FBRy9FLFFBQVE7Z0JBQUM4SDthQUFNLEVBQUVRLGFBQWF2RCxLQUFLLENBQUMvRTtZQUM5RnVHLGVBQWV1QjtRQUNqQixPQUFPRixZQUFZQyxnQkFBZ0JDLFFBQVEsaUJBQWlCO1FBRzVEakMsbUJBQW1CaUM7SUFDckI7QUFDRjtBQUVBLFNBQVNXLGdCQUFnQkMsS0FBSyxFQUFFcEMsTUFBTSxFQUFFcUMsS0FBSztJQUMzQyxJQUFJQSxVQUFVLEtBQUssR0FBRztRQUNwQkEsUUFBUTtJQUNWO0lBRUEsSUFBSUQsT0FBTztRQUNULDJHQUEyRztRQUMzRyxJQUFJbEUsU0FBU21FLFFBQVEsRUFBRSxDQUFDN0UsTUFBTSxDQUFDNEUsU0FBU0E7UUFDeENsRSxPQUFPekQsT0FBTyxDQUFDLFNBQVUrRyxLQUFLO1lBQzVCLE9BQU9jLFlBQVl0QyxRQUFRd0I7UUFDN0I7SUFDRjtBQUNGO0FBRUEsU0FBU2MsWUFBWWYsY0FBYyxFQUFFQyxLQUFLO0lBQ3hDLElBQUlBLE9BQU87UUFDVCxJQUFJQSxNQUFNQyxVQUFVLEVBQUU7WUFDcEJGLGVBQWVnQixNQUFNLENBQUNmO1FBQ3hCLE9BQU87WUFDTEEsTUFBTXhCLE1BQU0sR0FBRztZQUNmLElBQUl1QixlQUFlSixTQUFTLEVBQUVJLGVBQWVKLFNBQVMsR0FBR0ksZUFBZUosU0FBUyxDQUFDakUsTUFBTSxDQUFDLFNBQVVzRixDQUFDO2dCQUNsRyxPQUFPQSxNQUFNaEI7WUFDZixJQUFJLG9CQUFvQjtZQUV4QixJQUFJQSxNQUFNRyxXQUFXLEVBQUVKLGNBQWMsQ0FBQ0MsTUFBTUcsV0FBVyxDQUFDLEdBQUdKLGNBQWMsQ0FBQ0MsTUFBTUcsV0FBVyxDQUFDLENBQUN6RSxNQUFNLENBQUMsU0FBVXNGLENBQUM7Z0JBQzdHLE9BQU9BLE1BQU1oQjtZQUNmO2lCQUFRLElBQUlBLE1BQU1JLFlBQVksRUFBRSxPQUFPTCxjQUFjLENBQUNDLE1BQU1JLFlBQVksQ0FBQyxFQUFFLENBQUMsQ0FBQ0osTUFBTUksWUFBWSxDQUFDLEVBQUUsQ0FBQztpQkFBTSxJQUFJSixNQUFNSCxNQUFNLEVBQUVFLGNBQWMsQ0FBQ0MsTUFBTUgsTUFBTSxDQUFDLEdBQUc7UUFDNUo7UUFFQTlCLG1CQUFtQmlDLFFBQVEsdUZBQXVGO1FBRWxILElBQUlBLE1BQU1aLE9BQU8sS0FBSyxNQUFNO1lBQzFCMUosVUFBVXVMLHdCQUF3QixDQUFDdkwsVUFBVXdMLHFCQUFxQixFQUFFO2dCQUNsRSx1QkFBdUI7Z0JBQ3ZCLElBQUlsQixNQUFNekUsV0FBVyxFQUFFeUUsTUFBTXpFLFdBQVcsQ0FBQzJDLGFBQWEsR0FBRzhCLE1BQU16RSxXQUFXLENBQUMyQyxhQUFhLENBQUN4QyxNQUFNLENBQUMsU0FBVXNGLENBQUM7b0JBQ3pHLE9BQU9BLE1BQU1oQjtnQkFDZixJQUFJLDhCQUE4QjtnQkFFbENXLGdCQUFnQlgsTUFBTUwsU0FBUyxFQUFFSztnQkFDakNXLGdCQUFnQlgsTUFBTVMsUUFBUSxFQUFFVCxPQUFPLE9BQU8sZUFBZTtnQkFFN0QsSUFBSUEsTUFBTVosT0FBTyxFQUFFWSxNQUFNWixPQUFPLElBQUksb0JBQW9CO2dCQUV4RCxPQUFPWSxNQUFNekUsV0FBVztnQkFDeEIsT0FBT3lFLE1BQU1MLFNBQVM7WUFDeEI7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxTQUFTd0IsZUFBZWpHLFFBQVEsRUFBRTBELElBQUksRUFBRXpELFFBQVEsRUFBRWlHLEtBQUs7SUFDckQsSUFBSTVDLFNBQVN0RCxTQUFTc0QsTUFBTTtJQUM1QixJQUFJNkMsY0FBYzFDLGVBQWVDLE1BQU16RCxVQUFVRCxTQUFTSyxXQUFXLEVBQUUsTUFBTTZGO0lBQzdFTixZQUFZdEMsUUFBUXREO0lBQ3BCNEUsWUFBWXRCLFFBQVE2QyxhQUFhLHdEQUF3RDs7SUFJekY7UUFBQ0Q7UUFBT0EsTUFBTUUsU0FBUztLQUFDLENBQUNySSxPQUFPLENBQUMsU0FBVW1JLEtBQUs7UUFDOUMsSUFBSUEsVUFBVSxNQUFNO1lBQ2xCQSxNQUFNMUIsU0FBUyxHQUFHMkI7WUFFbEIsSUFBSUQsTUFBTTNILEdBQUcsRUFBRTtnQkFDYixJQUFJdkMsR0FBR0ksR0FBRyxDQUFDOEosTUFBTTNILEdBQUcsR0FBRzJILE1BQU0zSCxHQUFHLENBQUM0SDtxQkFBa0JELE1BQU0zSCxHQUFHLENBQUNMLE9BQU8sR0FBR2lJO1lBQ3pFO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsSUFBSUUsV0FBVzlMLFdBQVc7SUFDeEIrTCxLQUFLOUwsVUFBVStMLFlBQVk7SUFDM0I5QyxnQkFBZ0JBO0lBQ2hCbUMsYUFBYUE7SUFDYmhCLGFBQWFBO0lBQ2JPLGNBQWNBO0lBQ2QsYUFBYTtJQUNicUIsa0JBQWtCO0lBQ2xCQyxrQkFBa0I7SUFDbEJDLG1CQUFtQjtJQUNuQkMsaUJBQWlCM0ssR0FBR0ksR0FBRyxDQUFDd0ssY0FBY0EsYUFBYXBMO0lBQ25EcUwsZUFBZTdLLEdBQUdJLEdBQUcsQ0FBQzBLLGdCQUFnQkEsZUFBZXRMO0lBQ3JELGFBQWE7SUFDYm9MLFlBQVk1SyxHQUFHSSxHQUFHLENBQUN3SyxjQUFjQSxhQUFhcEw7SUFDOUMsYUFBYTtJQUNic0wsY0FBYzlLLEdBQUdJLEdBQUcsQ0FBQzBLLGdCQUFnQkEsZUFBZXRMO0lBQ3BEdUwsV0FBVyxDQUFDO0lBQ1pDLG9CQUFvQnBDO0lBQ3BCcUMsd0JBQXdCckM7SUFDeEJzQywwQkFBMEJ0QjtJQUMxQnVCLHlCQUF5QmhDO0lBQ3pCaUMsY0FBYyxTQUFTQSxhQUFhcEgsUUFBUSxFQUFFcUgsYUFBYSxFQUFFM0QsSUFBSSxFQUFFeEQsUUFBUSxFQUFFRCxRQUFRLEVBQUVpRyxLQUFLO1FBQzFGLElBQUlsRyxTQUFTb0UsVUFBVSxJQUFJbkUsU0FBU2tFLE1BQU0sSUFBSWxFLFNBQVNrRSxNQUFNLEtBQUtuRSxVQUFVO1lBQzFFLG1FQUFtRTtZQUNuRWlHLGVBQWVqRyxVQUFVMEQsTUFBTXpELFVBQVVpRztRQUMzQyxPQUFPO1lBQ0wscUVBQXFFO1lBQ3JFLElBQUlvQixpQkFBaUJySCxTQUFTOEQsSUFBSSxFQUM5QndELFVBQVVELG1CQUFtQixLQUFLLElBQUksRUFBRSxHQUFHQSxnQkFDM0NFLFVBQVV0Tiw4QkFBOEIrRixVQUFVO2dCQUFDO2FBQU87WUFFOUQsSUFBSXdILGlCQUFpQnZILFNBQVM2RCxJQUFJLEVBQzlCMkQsVUFBVUQsbUJBQW1CLEtBQUssSUFBSSxFQUFFLEdBQUdBLGdCQUMzQ0UsVUFBVXpOLDhCQUE4QmdHLFVBQVU7Z0JBQUM7YUFBTyxHQUFHLHdFQUF3RTtZQUd6SSxJQUFJMEgsYUFBYUwsUUFBUU0sSUFBSSxDQUFDLFNBQVVoTyxLQUFLLEVBQUVtRCxLQUFLO2dCQUNsRCxPQUFPaEIsR0FBR0MsR0FBRyxDQUFDcEMsU0FBU0gsT0FBTzJILE9BQU8sQ0FBQ3hILE9BQU9nTyxJQUFJLENBQUMsU0FBVUMsS0FBSztvQkFDL0QsSUFBSTlNLE1BQU04TSxLQUFLLENBQUMsRUFBRSxFQUNkQyxNQUFNRCxLQUFLLENBQUMsRUFBRTtvQkFDbEIsT0FBT0MsUUFBUUwsT0FBTyxDQUFDMUssTUFBTSxDQUFDaEMsSUFBSTtnQkFDcEMsS0FBS25CLFVBQVU2TixPQUFPLENBQUMxSyxNQUFNO1lBQy9CO1lBRUEsSUFBSTRLLFlBQVk7Z0JBQ2Qsb0RBQW9EO2dCQUNwRDNCLGVBQWVqRyxVQUFVMEQsTUFBTXpELFVBQVVpRztZQUMzQyxPQUFPO2dCQUNMLGlDQUFpQztnQkFDakNuRyxXQUFXQyxVQUFVd0gsU0FBU0csU0FBUztZQUN6QztRQUNGO0lBQ0Y7SUFDQUssY0FBYyxTQUFTQSxhQUFhaEksUUFBUTtRQUMxQyxJQUFJQSxTQUFTK0UsVUFBVSxFQUFFO1lBQ3ZCL0UsU0FBU2lJLE9BQU8sR0FBRztZQUNuQnBGLG1CQUFtQjdDO1FBQ3JCO0lBQ0Y7SUFDQWtJLGdCQUFnQixTQUFTQSxlQUFlbEksUUFBUSxFQUFFZ0UsS0FBSztRQUNyRCxJQUFJaEUsU0FBUytFLFVBQVUsSUFBSWYsTUFBTWlFLE9BQU8sSUFBSSxRQUFRakUsTUFBTWlFLE9BQU8sRUFBRTtZQUNqRWpJLFNBQVNpSSxPQUFPLEdBQUc7WUFDbkJwRixtQkFBbUI3QztRQUNyQjtJQUNGO0lBQ0FtSSxrQkFBa0IsU0FBU0E7UUFDekIsTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0lBQ0FDLG1CQUFtQixTQUFTQSxrQkFBa0JySSxRQUFRO1FBQ3BELE9BQU9BO0lBQ1Q7SUFDQXNJLG9CQUFvQixTQUFTQTtRQUMzQixPQUFPdk07SUFDVDtJQUNBd00scUJBQXFCLFNBQVNBO1FBQzVCLE9BQU94TTtJQUNUO0lBQ0F5TSxvQkFBb0IsU0FBU0Esc0JBQXNCO0lBQ25EQyx5QkFBeUIsU0FBU0E7UUFDaEMsT0FBTztJQUNUO0lBQ0FDLGVBQWUsU0FBU0E7UUFDdEIsT0FBTzNNO0lBQ1Q7SUFDQTRNLDJCQUEyQixTQUFTQTtRQUNsQyxPQUFPO0lBQ1Q7SUFDQUMsa0JBQWtCLFNBQVNBLG9CQUFvQjtJQUMvQ0Msa0JBQWtCLFNBQVNBLG9CQUFvQjtJQUMvQ0Msc0JBQXNCLFNBQVNBO1FBQzdCLE9BQU87SUFDVDtBQUNGO0FBQ0EsSUFBSUMsWUFBWS9NLEdBQUdJLEdBQUcsQ0FBQ2QsV0FBV0EsTUFBTSxDQUFDLE1BQU07QUFDL0MsSUFBSTBOLG9CQUFvQkQsWUFBWXpOLE1BQU0sQ0FBQyxNQUFNLENBQUMsa0JBQWtCO0FBQ3BFLFNBQVN3RCxPQUFPbUssT0FBTyxFQUFFN0ksU0FBUyxFQUFFekMsS0FBSztJQUN2QyxJQUFJd0IsT0FBT3RELE1BQU1xTixHQUFHLENBQUM5STtJQUVyQixJQUFJLENBQUNqQixNQUFNO1FBQ1RpQixVQUFVZixPQUFPLEdBQUcxQixPQUFPLGFBQWE7UUFFeEMsSUFBSXdMLFVBQVVoSyxPQUFPa0gsU0FBUytDLGVBQWUsQ0FBQ2hKLFdBQVd6QyxVQUFVbkMsYUFBYW1DLE1BQU1PLE9BQU8sQ0FBQ21MLFVBQVUsR0FBRyxJQUFJLEdBQUcsT0FDbEg7UUFDQXhOLE1BQU02RixHQUFHLENBQUN0QixXQUFXK0k7SUFDdkI7SUFFQTlDLFNBQVNpRCxlQUFlLENBQUNMLFNBQVM5SixNQUFNLE1BQU07UUFDNUMsT0FBTzNEO0lBQ1Q7SUFDQSxPQUFPNkssU0FBU2tELHFCQUFxQixDQUFDcEs7QUFDeEM7QUFDQSxTQUFTcUssdUJBQXVCcEosU0FBUyxFQUFFdEQsUUFBUTtJQUNqRCxJQUFJcUMsT0FBT3RELE1BQU1xTixHQUFHLENBQUM5STtJQUNyQixJQUFJakIsTUFBTWtILFNBQVNpRCxlQUFlLENBQUMsTUFBTW5LLE1BQU0sTUFBTTtRQUNuRHRELEtBQUssQ0FBQyxTQUFTLENBQUN1RTtRQUNoQixJQUFJdEQsVUFBVUEsU0FBU3NEO0lBQ3pCO0FBQ0Y7QUFDQSxTQUFTcUosYUFBYWxFLFFBQVEsRUFBRW5HLGFBQWEsRUFBRXNLLGNBQWMsRUFBRTFPLEdBQUc7SUFDaEUsSUFBSUEsUUFBUSxLQUFLLEdBQUc7UUFDbEJBLE1BQU07SUFDUjtJQUVBLElBQUksQ0FBQ29FLGNBQWNxRixTQUFTLEVBQUVyRixjQUFjcUYsU0FBUyxHQUFHLEVBQUU7SUFDMUQsT0FBTztRQUNMa0YsVUFBVVg7UUFDVmhPLEtBQUtBLE9BQU8sT0FBTyxPQUFPLEtBQUtBO1FBQy9CdUssVUFBVUE7UUFDVm5HLGVBQWVBO1FBQ2ZzSyxnQkFBZ0JBO0lBQ2xCO0FBQ0Y7QUFDQXJELFNBQVN1RCxrQkFBa0IsQ0FBQztJQUMxQkMsWUFBWUMsTUFBeUIsR0FBZSxDQUFDLEdBQUc7SUFDeEQsWUFBWTtJQUNaQyx5QkFBeUIsU0FBU0E7UUFDaEMsT0FBTztJQUNUO0lBQ0FDLFNBQVMxUCxlQUFlMFAsT0FBTztJQUMvQkMscUJBQXFCO0FBQ3ZCO0FBRUEsU0FBU0MsZ0NBQWdDQyxDQUFDLEVBQUVDLGNBQWM7SUFBSSxJQUFJQztJQUFJLElBQUksT0FBTy9PLFdBQVcsZUFBZTZPLENBQUMsQ0FBQzdPLE9BQU9nUCxRQUFRLENBQUMsSUFBSSxNQUFNO1FBQUUsSUFBSTlOLE1BQU1DLE9BQU8sQ0FBQzBOLE1BQU9FLENBQUFBLEtBQUtFLDRCQUE0QkosRUFBQyxLQUFNQyxrQkFBa0JELEtBQUssT0FBT0EsRUFBRWxOLE1BQU0sS0FBSyxVQUFVO1lBQUUsSUFBSW9OLElBQUlGLElBQUlFO1lBQUksSUFBSXpOLElBQUk7WUFBRyxPQUFPO2dCQUFjLElBQUlBLEtBQUt1TixFQUFFbE4sTUFBTSxFQUFFLE9BQU87b0JBQUV1TixNQUFNO2dCQUFLO2dCQUFHLE9BQU87b0JBQUVBLE1BQU07b0JBQU8zUSxPQUFPc1EsQ0FBQyxDQUFDdk4sSUFBSTtnQkFBQztZQUFHO1FBQUc7UUFBRSxNQUFNLElBQUlqQixVQUFVO0lBQTBJO0lBQUUwTyxLQUFLRixDQUFDLENBQUM3TyxPQUFPZ1AsUUFBUSxDQUFDO0lBQUksT0FBT0QsR0FBR0ksSUFBSSxDQUFDQyxJQUFJLENBQUNMO0FBQUs7QUFFM2xCLFNBQVNFLDRCQUE0QkosQ0FBQyxFQUFFUSxNQUFNO0lBQUksSUFBSSxDQUFDUixHQUFHO0lBQVEsSUFBSSxPQUFPQSxNQUFNLFVBQVUsT0FBT1Msa0JBQWtCVCxHQUFHUTtJQUFTLElBQUlFLElBQUluUixPQUFPb1IsU0FBUyxDQUFDQyxRQUFRLENBQUNyUCxJQUFJLENBQUN5TyxHQUFHcEksS0FBSyxDQUFDLEdBQUcsQ0FBQztJQUFJLElBQUk4SSxNQUFNLFlBQVlWLEVBQUU3SCxXQUFXLEVBQUV1SSxJQUFJVixFQUFFN0gsV0FBVyxDQUFDQyxJQUFJO0lBQUUsSUFBSXNJLE1BQU0sU0FBU0EsTUFBTSxPQUFPLE9BQU9yTyxNQUFNd08sSUFBSSxDQUFDYjtJQUFJLElBQUlVLE1BQU0sZUFBZSwyQ0FBMkNJLElBQUksQ0FBQ0osSUFBSSxPQUFPRCxrQkFBa0JULEdBQUdRO0FBQVM7QUFFL1osU0FBU0Msa0JBQWtCek8sR0FBRyxFQUFFK08sR0FBRztJQUFJLElBQUlBLE9BQU8sUUFBUUEsTUFBTS9PLElBQUljLE1BQU0sRUFBRWlPLE1BQU0vTyxJQUFJYyxNQUFNO0lBQUUsSUFBSyxJQUFJTCxJQUFJLEdBQUd1TyxPQUFPLElBQUkzTyxNQUFNME8sTUFBTXRPLElBQUlzTyxLQUFLdE8sSUFBSztRQUFFdU8sSUFBSSxDQUFDdk8sRUFBRSxHQUFHVCxHQUFHLENBQUNTLEVBQUU7SUFBRTtJQUFFLE9BQU91TztBQUFNO0FBQ3RMLFNBQVNDLHFCQUFxQkMsR0FBRztJQUMvQixPQUFPQSxJQUFJRCxvQkFBb0I7QUFDakM7QUFFQSxTQUFTRSxPQUFPQyxLQUFLO0lBQ25CLE9BQU8sQ0FBQ0EsTUFBTUMsV0FBVyxJQUFJRCxNQUFNcEgsTUFBTSxFQUFFc0gsSUFBSSxHQUFHLE1BQU1GLE1BQU12TyxLQUFLO0FBQ3JFO0FBRUEsSUFBSTBPLGVBQWUsV0FBVyxHQUFFclIsTUFBTXNSLGFBQWEsQ0FBQyxDQUFDO0FBQ3JELElBQUlDLFlBQVksU0FBU0EsVUFBVTVILEtBQUs7SUFDdEMsSUFBSXVCLFdBQVd2QixNQUFNdUIsUUFBUSxFQUN6QjFHLEtBQUttRixNQUFNbkYsRUFBRSxFQUNiRyxTQUFTZ0YsTUFBTWhGLE1BQU0sRUFDckI2TSxlQUFlN0gsTUFBTTZILFlBQVksRUFDakNDLFlBQVk5SCxNQUFNOEgsU0FBUyxFQUMzQkMsT0FBTy9ILE1BQU0rSCxJQUFJLEVBQ2pCQyxhQUFhaEksTUFBTWdJLFVBQVUsRUFDN0JDLFlBQVlqSSxNQUFNdEUsRUFBRSxFQUNwQkEsS0FBS3VNLGNBQWMsS0FBSyxJQUFJLFFBQVFBLFdBQ3BDQyxvQkFBb0JsSSxNQUFNcUYsVUFBVSxFQUNwQ0EsYUFBYTZDLHNCQUFzQixLQUFLLElBQUksUUFBUUEsbUJBQ3BEQyxtQkFBbUJuSSxNQUFNb0ksU0FBUyxFQUNsQ0EsWUFBWUQscUJBQXFCLEtBQUssSUFBSSxRQUFRQSxrQkFDbERFLHdCQUF3QnJJLE1BQU0vQixlQUFlLEVBQzdDQSxrQkFBa0JvSywwQkFBMEIsS0FBSyxJQUFJLE9BQU9BLHVCQUM1REMsd0JBQXdCdEksTUFBTXJGLG1CQUFtQixFQUNqREEsc0JBQXNCMk4sMEJBQTBCLEtBQUssSUFBSSxRQUFRQSx1QkFDakVDLHdCQUF3QnZJLE1BQU13SSxtQkFBbUIsRUFDakRBLHNCQUFzQkQsMEJBQTBCLEtBQUssSUFBSSxPQUFPQSx1QkFDaEVFLGtCQUFrQnpJLE1BQU0wSSxRQUFRLEVBQ2hDQSxXQUFXRCxvQkFBb0IsS0FBSyxJQUFJLFFBQVFBLGlCQUNoREUsWUFBWTNJLE1BQU0ySSxTQUFTLEVBQzNCQyxrQkFBa0I1SSxNQUFNNEksZUFBZSxFQUN2Q2pOLGNBQWNxRSxNQUFNckUsV0FBVyxFQUFFLHdCQUF3QjtJQUU3RCxJQUFJa04sWUFBWXhTLE1BQU15UyxRQUFRLENBQUMsUUFDM0J2TixRQUFRc04sU0FBUyxDQUFDLEVBQUUsRUFDcEJFLFdBQVdGLFNBQVMsQ0FBQyxFQUFFO0lBRTNCLElBQUlHLGFBQWEzUyxNQUFNeVMsUUFBUSxDQUFDO1FBQzlCLE9BQU8sSUFBSTFTLE1BQU02UyxPQUFPO0lBQzFCLElBQ0lDLFFBQVFGLFVBQVUsQ0FBQyxFQUFFO0lBRXpCLElBQUlHLGFBQWE5UyxNQUFNeVMsUUFBUSxDQUFDO1FBQzlCLElBQUlNLE1BQU0sSUFBSWhULE1BQU1pVCxTQUFTO1FBRTdCLElBQUl2QixXQUFXO1lBQ2IsSUFBSXRMLFNBQVNzTCxVQUFVdEwsTUFBTSxFQUN6QjhNLGlCQUFpQnBULDhCQUE4QjRSLFdBQVc7Z0JBQUM7YUFBUztZQUV4RS9MLFdBQVdxTixLQUFLRSxnQkFBZ0IsQ0FBQztRQUNuQztRQUVBLE9BQU9GO0lBQ1QsSUFDSUcsbUJBQW1CSixVQUFVLENBQUMsRUFBRTtJQUVwQyxJQUFJSyxhQUFhblQsTUFBTXlTLFFBQVEsQ0FBQztRQUM5QixJQUFJL04sUUFBUSxJQUFJM0UsTUFBTXFULEtBQUs7UUFDM0IxTyxNQUFNaUUsYUFBYSxHQUFHLEVBQUU7UUFDeEJqRSxNQUFNMEYsU0FBUyxHQUFHLEVBQUU7UUFDcEIsT0FBTzFGO0lBQ1QsSUFDSTJPLGVBQWVGLFVBQVUsQ0FBQyxFQUFFO0lBRWhDLElBQUlHLGFBQWF0VCxNQUFNeVMsUUFBUSxDQUFDO1FBQzlCLElBQUljLE1BQU0vQixlQUFlLElBQUl6UixNQUFNeVQsa0JBQWtCLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxLQUFLLFFBQVEsSUFBSXpULE1BQU0wVCxpQkFBaUIsQ0FBQyxJQUFJLEdBQUcsS0FBSztRQUN2SEYsSUFBSUcsUUFBUSxDQUFDQyxDQUFDLEdBQUc7UUFDakIsSUFBSWhQLFFBQVFlLFdBQVc2TixLQUFLNU8sUUFBUSxDQUFDLElBQUksMkJBQTJCO1FBRXBFNE8sSUFBSUssTUFBTSxDQUFDLEdBQUcsR0FBRztRQUNqQixPQUFPTDtJQUNULElBQ0lNLGFBQWFQLFVBQVUsQ0FBQyxFQUFFLEVBQzFCUSxvQkFBb0JSLFVBQVUsQ0FBQyxFQUFFO0lBRXJDLElBQUlTLGFBQWEvVCxNQUFNeVMsUUFBUSxDQUFDO1FBQzlCLE9BQU8sSUFBSTFTLE1BQU1pVSxLQUFLO0lBQ3hCLElBQ0lsUSxRQUFRaVEsVUFBVSxDQUFDLEVBQUUsRUFBRSxlQUFlO0lBRzFDLElBQUl6USxRQUFRdEQsTUFBTWlVLE1BQU0sQ0FBQztRQUN2Qi9PLE9BQU87UUFDUEQsUUFBUTtRQUNSVixRQUFRO1FBQ1JxRCxpQkFBaUJBO1FBQ2pCdkMsSUFBSUE7UUFDSjJKLFlBQVlBO1FBQ1pxRCxVQUFVQTtRQUNWL04scUJBQXFCO1FBQ3JCSCxRQUFRO1FBQ1IrUCxRQUFRO1FBQ1JsUSxhQUFhLEVBQUU7UUFDZlcsUUFBUWtQO1FBQ1JuUCxPQUFPMk87UUFDUDVCLFdBQVd5QjtRQUNYTCxPQUFPQTtRQUNQL08sT0FBT0E7UUFDUFUsSUFBSUE7UUFDSmtOLE1BQU1BO1FBQ055QyxVQUFVO1FBQ1ZDLGNBQWM7WUFBQztZQUFHO1NBQUU7UUFDcEJDLGFBQWEsRUFBRTtRQUNmQyxTQUFTLElBQUlsVSxZQUFZbVUsV0FBVztRQUNwQ0MsVUFBVXJUO1FBQ1ZzVCxRQUFRdFQ7UUFDUnVULFdBQVcsU0FBU0EsVUFBVXhRLEdBQUcsRUFBRXlRLFFBQVE7WUFDekMsSUFBSUEsYUFBYSxLQUFLLEdBQUc7Z0JBQ3ZCQSxXQUFXO1lBQ2I7WUFFQSxtRkFBbUY7WUFDbkYsaUZBQWlGO1lBQ2pGLGlGQUFpRjtZQUNqRiw4Q0FBOEM7WUFDOUMsSUFBSUEsVUFBVXJSLE1BQU1PLE9BQU8sQ0FBQ1UsTUFBTTtZQUNsQ2pCLE1BQU1PLE9BQU8sQ0FBQ0csV0FBVyxDQUFDbkIsSUFBSSxDQUFDO2dCQUM3QnFCLEtBQUtBO2dCQUNMeVEsVUFBVUE7WUFDWixJQUFJLDBHQUEwRztZQUU5R3JSLE1BQU1PLE9BQU8sQ0FBQ0csV0FBVyxHQUFHVixNQUFNTyxPQUFPLENBQUNHLFdBQVcsQ0FBQzRRLElBQUksQ0FBQyxTQUFVL1MsQ0FBQyxFQUFFUyxDQUFDO2dCQUN2RSxPQUFPVCxFQUFFOFMsUUFBUSxHQUFHclMsRUFBRXFTLFFBQVE7WUFDaEM7WUFDQSxPQUFPO2dCQUNMLDJEQUEyRDtnQkFDM0QsSUFBSUEsVUFBVXJSLE1BQU1PLE9BQU8sQ0FBQ1UsTUFBTTtnQkFDbENqQixNQUFNTyxPQUFPLENBQUNHLFdBQVcsR0FBR1YsTUFBTU8sT0FBTyxDQUFDRyxXQUFXLENBQUNtQyxNQUFNLENBQUMsU0FBVTBPLENBQUM7b0JBQ3RFLE9BQU9BLEVBQUUzUSxHQUFHLEtBQUtBO2dCQUNuQjtZQUNGO1FBQ0Y7UUFDQTRRLGtCQUFrQixTQUFTQSxpQkFBaUJuUSxNQUFNO1lBQ2hELE9BQU9tUCxrQkFBa0JuUDtRQUMzQjtRQUNBUyxZQUFZLFNBQVMyUDtZQUNuQixPQUFPM1AsV0FBVzlCO1FBQ3BCO1FBQ0EwUixXQUFXLFNBQVNBLFVBQVU5RCxLQUFLLEVBQUUrRCxPQUFPO1lBQzFDLElBQUkvRCxVQUFVLEtBQUssR0FBRztnQkFDcEJBLFFBQVEsQ0FBQztZQUNYO1lBRUEsSUFBSStELFlBQVksS0FBSyxHQUFHO2dCQUN0QkEsVUFBVTtZQUNaO1lBRUEsT0FBT0Msa0JBQWtCaEUsT0FBTytEO1FBQ2xDO1FBQ0EzUCxhQUFhQTtJQUNmO0lBQ0EsSUFBSTZQLHFCQUFxQm5WLE1BQU1vVixXQUFXLENBQUMsU0FBVXpRLE1BQU0sRUFBRXdDLE1BQU07UUFDakUsSUFBSXhDLFdBQVcsS0FBSyxHQUFHO1lBQ3JCQSxTQUFTckIsTUFBTU8sT0FBTyxDQUFDYyxNQUFNO1FBQy9CO1FBRUEsSUFBSXdDLFdBQVcsS0FBSyxHQUFHO1lBQ3JCQSxTQUFTLElBQUlwSCxNQUFNc1YsT0FBTyxDQUFDLEdBQUcsR0FBRztRQUNuQztRQUVBLElBQUlDLHNCQUFzQmhTLE1BQU1PLE9BQU8sQ0FBQzZOLElBQUksRUFDeEM2RCxRQUFRRCxvQkFBb0JDLEtBQUssRUFDakNDLFNBQVNGLG9CQUFvQkUsTUFBTTtRQUN2QyxJQUFJQyxXQUFXOVEsT0FBTytPLFFBQVEsQ0FBQ2dDLFVBQVUsQ0FBQ3ZPO1FBRTFDLElBQUk0SixxQkFBcUJwTSxTQUFTO1lBQ2hDLE9BQU87Z0JBQ0w0USxPQUFPQSxRQUFRNVEsT0FBT2dSLElBQUk7Z0JBQzFCSCxRQUFRQSxTQUFTN1EsT0FBT2dSLElBQUk7Z0JBQzVCQyxRQUFRO2dCQUNSSCxVQUFVQTtZQUNaO1FBQ0YsT0FBTztZQUNMLElBQUlJLE1BQU1sUixPQUFPa1IsR0FBRyxHQUFHelIsS0FBSzBSLEVBQUUsR0FBRyxLQUFLLGtDQUFrQztZQUV4RSxJQUFJQyxJQUFJLElBQUkzUixLQUFLNFIsR0FBRyxDQUFDSCxNQUFNLEtBQUtKLFVBQVUsaUJBQWlCO1lBRTNELElBQUlRLElBQUlGLElBQUtSLENBQUFBLFFBQVFDLE1BQUs7WUFDMUIsT0FBTztnQkFDTEQsT0FBT1U7Z0JBQ1BULFFBQVFPO2dCQUNSSCxRQUFRTCxRQUFRVTtnQkFDaEJSLFVBQVVBO1lBQ1o7UUFDRjtJQUNGLEdBQUcsRUFBRSxHQUFHLG1GQUFtRjtJQUUzRnpWLE1BQU1rVyxPQUFPLENBQUM7UUFDWjVTLE1BQU1PLE9BQU8sQ0FBQ3FCLEtBQUssR0FBR0E7UUFDdEI1QixNQUFNTyxPQUFPLENBQUM2TixJQUFJLEdBQUdBO1FBQ3JCcE8sTUFBTU8sT0FBTyxDQUFDYyxNQUFNLEdBQUdrUDtRQUN2QnZRLE1BQU1PLE9BQU8sQ0FBQ1MsbUJBQW1CLEdBQUdBO1FBQ3BDaEIsTUFBTU8sT0FBTyxDQUFDd0IsRUFBRSxHQUFHQTtRQUNuQi9CLE1BQU1PLE9BQU8sQ0FBQ1csRUFBRSxHQUFHQTtRQUNuQmxCLE1BQU1PLE9BQU8sQ0FBQ21MLFVBQVUsR0FBR0E7UUFDM0IxTCxNQUFNTyxPQUFPLENBQUN3TyxRQUFRLEdBQUdBLFVBQVUscUNBQXFDO1FBRXhFL08sTUFBTU8sT0FBTyxDQUFDc1EsUUFBUSxHQUFHZ0I7SUFDM0IsR0FBRztRQUFDN1E7UUFBcUJlO1FBQUkySjtRQUFZcUQ7UUFBVW5OO1FBQU93TTtRQUFNbUM7UUFBWXJQO0tBQUcsR0FBRyx5QkFBeUI7SUFFM0d4RSxNQUFNa1csT0FBTyxDQUFDO1FBQ1o1UyxNQUFNTyxPQUFPLENBQUNxUSxNQUFNLEdBQUd4QyxLQUFLNkQsS0FBSyxHQUFHN0QsS0FBSzhELE1BQU0sRUFBRSx3Q0FBd0M7UUFFekZuVyxPQUFPOFcsTUFBTSxDQUFDN1MsTUFBTU8sT0FBTyxDQUFDc1EsUUFBUSxFQUFFZ0IsdUJBQXVCLDhEQUE4RDtRQUMzSCx1RUFBdUU7UUFFdkUsSUFBSWhELHFCQUFxQjtZQUN2QixJQUFJcEIscUJBQXFCOEMsYUFBYTtnQkFDcENBLFdBQVd1QyxJQUFJLEdBQUcxRSxLQUFLNkQsS0FBSyxHQUFHLENBQUM7Z0JBQ2hDMUIsV0FBV3dDLEtBQUssR0FBRzNFLEtBQUs2RCxLQUFLLEdBQUc7Z0JBQ2hDMUIsV0FBV3lDLEdBQUcsR0FBRzVFLEtBQUs4RCxNQUFNLEdBQUc7Z0JBQy9CM0IsV0FBVzBDLE1BQU0sR0FBRzdFLEtBQUs4RCxNQUFNLEdBQUcsQ0FBQztZQUNyQyxPQUFPO2dCQUNMM0IsV0FBV0ssTUFBTSxHQUFHNVEsTUFBTU8sT0FBTyxDQUFDcVEsTUFBTTtZQUMxQztZQUVBTCxXQUFXMkMsc0JBQXNCLElBQUkscUVBQXFFO1lBQzFHLHlEQUF5RDtZQUV6RDNDLFdBQVc0QyxpQkFBaUI7UUFDOUI7UUFFQWpTLEdBQUdrUyxPQUFPLENBQUNoRixLQUFLNkQsS0FBSyxFQUFFN0QsS0FBSzhELE1BQU07UUFDbEMsSUFBSXRRLE9BQU9FLFdBQVc5QjtJQUN4QixHQUFHO1FBQUN1UTtRQUFZbkM7UUFBTVM7S0FBb0I7SUFDMUMsNEdBQTRHLEdBRTVHLDZCQUE2QixHQUU3QixJQUFJd0UsYUFBYTNXLE1BQU1vVixXQUFXLENBQUMsU0FBVW5PLElBQUk7UUFDL0MsSUFBSTJQLFVBQVUzUCxLQUFLMlAsT0FBTyxFQUN0QkMsVUFBVTVQLEtBQUs0UCxPQUFPO1FBRTFCLElBQUlELFlBQVksS0FBSyxHQUFHO1lBQ3RCLElBQUlFLHVCQUF1QnhULE1BQU1PLE9BQU8sQ0FBQzZOLElBQUksRUFDekMwRSxPQUFPVSxxQkFBcUJWLElBQUksRUFDaENDLFFBQVFTLHFCQUFxQlQsS0FBSyxFQUNsQ0MsTUFBTVEscUJBQXFCUixHQUFHLEVBQzlCQyxTQUFTTyxxQkFBcUJQLE1BQU07WUFDeEMxRCxNQUFNeEwsR0FBRyxDQUFDLENBQUN1UCxVQUFVUixJQUFHLElBQU1DLENBQUFBLFFBQVFELElBQUcsSUFBSyxJQUFJLEdBQUcsQ0FBRSxFQUFDUyxVQUFVUCxHQUFFLElBQU1DLENBQUFBLFNBQVNELEdBQUUsQ0FBQyxJQUFLLElBQUk7WUFDL0ZwRCxpQkFBaUI2RCxhQUFhLENBQUNsRSxPQUFPdlAsTUFBTU8sT0FBTyxDQUFDYyxNQUFNO1FBQzVEO0lBQ0YsR0FBRyxFQUFFO0lBQ0wseURBQXlELEdBRXpELElBQUlxUSxZQUFZaFYsTUFBTW9WLFdBQVcsQ0FBQyxTQUFVbEUsS0FBSyxFQUFFL0ssTUFBTTtRQUN2RCwyQ0FBMkM7UUFDM0MsSUFBSTdDLE1BQU1PLE9BQU8sQ0FBQ3dPLFFBQVEsRUFBRSxPQUFPLEVBQUU7UUFDckMsSUFBSTJFLE9BQU8sSUFBSUM7UUFDZixJQUFJQyxPQUFPLEVBQUUsRUFBRSwyQ0FBMkM7UUFFMUQsSUFBSUMsZ0JBQWdCaFIsU0FBU0EsT0FBTzdDLE1BQU1PLE9BQU8sQ0FBQ2EsS0FBSyxDQUFDaUUsYUFBYSxJQUFJckYsTUFBTU8sT0FBTyxDQUFDYSxLQUFLLENBQUNpRSxhQUFhLEVBQUUsZ0VBQWdFO1FBRTVLLElBQUl5TyxhQUFhbEUsaUJBQWlCbUUsZ0JBQWdCLENBQUNGLGVBQWUsTUFBTWhSLE1BQU0sQ0FBQyxTQUFVbVIsSUFBSTtZQUMzRixJQUFJQyxLQUFLdEcsT0FBT3FHO1lBQ2hCLElBQUlOLEtBQUtoTixHQUFHLENBQUN1TixLQUFLLE9BQU87WUFDekJQLEtBQUtyTSxHQUFHLENBQUM0TTtZQUNULE9BQU87UUFDVCxJQUFJLDREQUE0RDtRQUNoRSw2Q0FBNkM7UUFFN0MsSUFBSTlGLGFBQWFBLFVBQVV0TCxNQUFNLElBQUlxUixZQUFZM1QsT0FBTyxFQUFFdVQsYUFBYTNGLFVBQVV0TCxNQUFNLENBQUNpUixZQUFZSSxZQUFZM1QsT0FBTztRQUV2SCxJQUFLLElBQUk0VCxZQUFZNUgsZ0NBQWdDdUgsYUFBYU0sT0FBTyxDQUFDLENBQUNBLFFBQVFELFdBQVUsRUFBR3RILElBQUksRUFBRztZQUNyRyxJQUFJd0gsYUFBYUQsTUFBTWxZLEtBQUs7WUFDNUIsSUFBSTJSLGNBQWN3RyxXQUFXN04sTUFBTSxFQUFFLGtCQUFrQjtZQUV2RCxNQUFPcUgsWUFBYTtnQkFDbEIsSUFBSS9LLFdBQVcrSyxZQUFZekksVUFBVTtnQkFDckMsSUFBSXRDLFVBQVU4USxLQUFLclUsSUFBSSxDQUFDbEQsU0FBUyxDQUFDLEdBQUdnWSxZQUFZO29CQUMvQ3hHLGFBQWFBO2dCQUNmO2dCQUNBQSxjQUFjQSxZQUFZbEksTUFBTTtZQUNsQztRQUNGO1FBRUEsT0FBT2lPO0lBQ1QsR0FBRyxFQUFFO0lBQ0wsNkJBQTZCLEdBRTdCLElBQUlVLG9CQUFvQjVYLE1BQU1vVixXQUFXLENBQUMsU0FBVWxFLEtBQUs7UUFDdkQsSUFBSTJHLEtBQUszRyxNQUFNMEYsT0FBTyxHQUFHdFQsTUFBTU8sT0FBTyxDQUFDdVEsWUFBWSxDQUFDLEVBQUU7UUFDdEQsSUFBSTBELEtBQUs1RyxNQUFNMkYsT0FBTyxHQUFHdlQsTUFBTU8sT0FBTyxDQUFDdVEsWUFBWSxDQUFDLEVBQUU7UUFDdEQsT0FBT2hRLEtBQUsyVCxLQUFLLENBQUMzVCxLQUFLNFQsSUFBSSxDQUFDSCxLQUFLQSxLQUFLQyxLQUFLQTtJQUM3QyxHQUFHLEVBQUU7SUFDTCxJQUFJRyxVQUFValksTUFBTWtXLE9BQU8sQ0FBQztRQUMxQixPQUFPLElBQUl6VTtJQUNiLEdBQUcsRUFBRTtJQUNMLDBEQUEwRCxHQUUxRCxJQUFJeVcsT0FBTyxJQUFJblksTUFBTXNWLE9BQU87SUFDNUIsSUFBSThDLG1CQUFtQm5ZLE1BQU1vVixXQUFXLENBQUMsU0FBVWxFLEtBQUssRUFBRWpILEVBQUUsRUFBRTlELE1BQU07UUFDbEUsdUJBQXVCO1FBQ3ZCLElBQUlpUyxnQkFBZ0JwRCxVQUFVOUQsT0FBTy9LLFNBQVMsNkdBQTZHO1FBRTNKLElBQUk3QyxNQUFNTyxPQUFPLENBQUMyUSxRQUFRLElBQUl0RCxNQUFNN0gsSUFBSSxLQUFLLFdBQVc2SCxNQUFNN0gsSUFBSSxLQUFLLFNBQVM7WUFDOUUvRixNQUFNTyxPQUFPLENBQUMyUSxRQUFRLENBQUM5USxPQUFPLENBQUMsU0FBVThRLFFBQVE7Z0JBQy9DLElBQUksQ0FBQzRELGNBQWNDLElBQUksQ0FBQyxTQUFVQyxHQUFHO29CQUNuQyxPQUFPQSxJQUFJbkgsV0FBVyxLQUFLcUQsU0FBU3JELFdBQVc7Z0JBQ2pELElBQUlpSCxjQUFjdlYsSUFBSSxDQUFDMlI7WUFDekI7UUFDRixFQUFFLGdFQUFnRTtRQUdsRSxJQUFJNEQsY0FBY3hWLE1BQU0sRUFBRTtZQUN2QjtnQkFDQyxJQUFJMlYsbUJBQW1CTCxLQUFLN1EsR0FBRyxDQUFDd0wsTUFBTXBILENBQUMsRUFBRW9ILE1BQU0yRixDQUFDLEVBQUUsR0FBR0MsU0FBUyxDQUFDblYsTUFBTU8sT0FBTyxDQUFDYyxNQUFNO2dCQUNuRixJQUFJZixRQUFRc04sTUFBTTdILElBQUksS0FBSyxVQUFVdU8sa0JBQWtCMUcsU0FBUztnQkFFaEUsSUFBSXdILHdCQUF3QixTQUFTQSxzQkFBc0JuQixFQUFFO29CQUMzRCxPQUFPckcsTUFBTS9KLE1BQU0sQ0FBQ3VSLHFCQUFxQixDQUFDbkI7Z0JBQzVDO2dCQUVBLElBQUlvQixhQUFhO29CQUNmQyxTQUFTO29CQUNUcEUsVUFBVTtnQkFDWjtnQkFFQSxJQUFJcUUsUUFBUSxTQUFTQTtvQkFDbkIsSUFBSVAsTUFBTVEsT0FBT3RaLEtBQUs7b0JBRXRCLElBQUl1WixvQkFBb0IsU0FBU0Esa0JBQWtCeEIsRUFBRTt3QkFDbkQsdUVBQXVFO3dCQUN2RSxJQUFJLENBQUNvQixXQUFXbkUsUUFBUSxFQUFFOzRCQUN4Qm1FLFdBQVduRSxRQUFRLEdBQUcsTUFBTSxrREFBa0Q7NEJBRTlFbFIsTUFBTU8sT0FBTyxDQUFDMlEsUUFBUSxHQUFHLEVBQUU7d0JBQzdCLEVBQUUseUJBQXlCO3dCQUczQixJQUFJbFIsTUFBTU8sT0FBTyxDQUFDMlEsUUFBUSxFQUFFbFIsTUFBTU8sT0FBTyxDQUFDMlEsUUFBUSxDQUFDM1IsSUFBSSxDQUFDeVYsS0FBSyw4QkFBOEI7O3dCQUUzRnBILE1BQU0vSixNQUFNLENBQUM0UixpQkFBaUIsQ0FBQ3hCO29CQUNqQztvQkFFQSxJQUFJeUIsZUFBZXJaLFNBQVMsQ0FBQyxHQUFHdVIsT0FBT29ILEtBQUs7d0JBQzFDRixlQUFlQTt3QkFDZlEsU0FBU0QsV0FBV0MsT0FBTzt3QkFDM0JoVixPQUFPQTt3QkFDUDJVLGtCQUFrQkE7d0JBQ2xCeEYsS0FBS0csaUJBQWlCSCxHQUFHO3dCQUN6QnBPLFFBQVFyQixNQUFNTyxPQUFPLENBQUNjLE1BQU07d0JBQzVCLGlEQUFpRDt3QkFDakRzVSxpQkFBaUIsU0FBU0E7NEJBQ3hCLE9BQU9ELGFBQWFKLE9BQU8sR0FBR0QsV0FBV0MsT0FBTyxHQUFHO3dCQUNyRDt3QkFDQSw4RUFBOEU7d0JBQzlFLHFGQUFxRjt3QkFDckYseUVBQXlFO3dCQUN6RXpSLFFBQVF4SCxTQUFTLENBQUMsR0FBR3VSLE1BQU0vSixNQUFNLEVBQUU7NEJBQ2pDNFIsbUJBQW1CQTs0QkFDbkJMLHVCQUF1QkE7d0JBQ3pCO3dCQUNBUSxlQUFldlosU0FBUyxDQUFDLEdBQUd1UixNQUFNZ0ksYUFBYSxFQUFFOzRCQUMvQ0gsbUJBQW1CQTs0QkFDbkJMLHVCQUF1QkE7d0JBQ3pCO3dCQUNBUyxhQUFhakk7b0JBQ2Y7b0JBRUFqSCxHQUFHK08sZUFBZSxxRkFBcUY7b0JBQ3ZHLDBGQUEwRjtvQkFDMUYsbUNBQW1DO29CQUVuQyxJQUFJTCxXQUFXQyxPQUFPLEtBQUssUUFBUUQsV0FBV25FLFFBQVEsSUFBSSxPQUFPO3dCQUMvRCx5REFBeUQ7d0JBQ3pELG1GQUFtRjt3QkFDbkYsSUFBSXlELFFBQVF2RyxJQUFJLElBQUl2UCxNQUFNd08sSUFBSSxDQUFDc0gsUUFBUW1CLE1BQU0sSUFBSWYsSUFBSSxDQUFDLFNBQVU5VixDQUFDOzRCQUMvRCxPQUFPQSxFQUFFdUgsTUFBTSxLQUFLd08sSUFBSXhPLE1BQU07d0JBQ2hDLElBQUk7NEJBQ0Z1UCxvQkFBb0JMLGNBQWM7Z0NBQUNWOzZCQUFJO3dCQUN6Qzt3QkFFQSxPQUFPO29CQUNUO2dCQUNGO2dCQUVBLElBQUssSUFBSWdCLGFBQWF6SixnQ0FBZ0N1SSxnQkFBZ0JVLFFBQVEsQ0FBQyxDQUFDQSxTQUFTUSxZQUFXLEVBQUduSixJQUFJLEVBQUc7b0JBQzVHLElBQUlvSixPQUFPVjtvQkFFWCxJQUFJVSxTQUFTLFNBQVM7Z0JBQ3hCO1lBQ0Y7UUFDRjtRQUVBLE9BQU9uQjtJQUNULEdBQUcsRUFBRTtJQUNMLElBQUlsRCxvQkFBb0JsVixNQUFNb1YsV0FBVyxDQUFDLFNBQVVsRSxLQUFLLEVBQUUrRCxPQUFPO1FBQ2hFLElBQUlBLFlBQVksS0FBSyxHQUFHO1lBQ3RCQSxVQUFVO1FBQ1o7UUFFQTNSLE1BQU1PLE9BQU8sQ0FBQ3lRLE9BQU8sQ0FBQ2tGLElBQUksQ0FBQyxlQUFldEk7UUFDMUMsSUFBSStELFNBQVMwQixXQUFXekY7UUFDeEIsSUFBSWdHLE9BQU9pQixpQkFBaUJqSCxPQUFPLFNBQVV1SSxJQUFJO1lBQy9DLElBQUl0SSxjQUFjc0ksS0FBS3RJLFdBQVc7WUFDbEMsSUFBSS9LLFdBQVcrSyxZQUFZekksVUFBVSxFQUFFLDZCQUE2QjtZQUVwRSxJQUFJLENBQUN0QyxVQUFVLFFBQVEsa0JBQWtCO1lBRXpDLElBQUlBLFNBQVNzVCxXQUFXLEVBQUV0VCxTQUFTc1QsV0FBVyxDQUFDRCxPQUFPLHlDQUF5QztZQUUvRixJQUFJclQsU0FBU3VULFdBQVcsSUFBSXZULFNBQVN3VCxZQUFZLElBQUl4VCxTQUFTeVQsVUFBVSxJQUFJelQsU0FBUzBULFlBQVksRUFBRTtnQkFDakcsSUFBSXZDLEtBQUt0RyxPQUFPd0k7Z0JBQ2hCLElBQUlNLGNBQWM5QixRQUFRcEosR0FBRyxDQUFDMEk7Z0JBRTlCLElBQUksQ0FBQ3dDLGFBQWE7b0JBQ2hCLHdFQUF3RTtvQkFDeEU5QixRQUFRNVEsR0FBRyxDQUFDa1EsSUFBSWtDO29CQUNoQixJQUFJclQsU0FBU3VULFdBQVcsRUFBRXZULFNBQVN1VCxXQUFXLENBQUNoYSxTQUFTLENBQUMsR0FBRzhaLE1BQU07d0JBQ2hFcFEsTUFBTTtvQkFDUjtvQkFDQSxJQUFJakQsU0FBU3dULFlBQVksRUFBRXhULFNBQVN3VCxZQUFZLENBQUNqYSxTQUFTLENBQUMsR0FBRzhaLE1BQU07d0JBQ2xFcFEsTUFBTTtvQkFDUjtnQkFDRixPQUFPLElBQUkwUSxZQUFZbkIsT0FBTyxFQUFFO29CQUM5Qiw4RkFBOEY7b0JBQzlGYSxLQUFLUixlQUFlO2dCQUN0QjtZQUNGO1FBQ0YsR0FDQSxTQUFVeFQsT0FBTztZQUNmLE9BQU9BLFFBQVFVLE1BQU0sQ0FBQyxTQUFVdkUsR0FBRztnQkFDakMsT0FBTztvQkFBQztvQkFBUTtvQkFBUTtvQkFBUztvQkFBTztpQkFBUSxDQUFDNEwsSUFBSSxDQUFDLFNBQVV0RixJQUFJO29CQUNsRSxPQUFPdEcsSUFBSThHLFVBQVUsQ0FBQyxZQUFZUixLQUFLO2dCQUN6QztZQUNGO1FBQ0YsSUFBSSx1QkFBdUI7UUFFM0JtUixvQkFBb0JuSSxPQUFPZ0csTUFBTWpDO1FBQ2pDLE9BQU9pQztJQUNULEdBQUcsRUFBRTtJQUNMLElBQUltQyxzQkFBc0JyWixNQUFNb1YsV0FBVyxDQUFDLFNBQVVsRSxLQUFLLEVBQUVnRyxJQUFJLEVBQUVqQyxPQUFPO1FBQ3hFLElBQUlBLFlBQVksS0FBSyxHQUFHO1lBQ3RCQSxVQUFVO1FBQ1o7UUFFQTNSLE1BQU1PLE9BQU8sQ0FBQ3lRLE9BQU8sQ0FBQ2tGLElBQUksQ0FBQyxpQkFBaUJ0STtRQUM1QyxJQUFJK0QsU0FBUzBCLFdBQVd6RjtRQUN4QixJQUFJLENBQUNnRyxNQUFNQSxPQUFPaUIsaUJBQWlCakgsT0FBTztZQUN4QyxPQUFPO1FBQ1Q7UUFDQS9PLE1BQU13TyxJQUFJLENBQUNzSCxRQUFRbUIsTUFBTSxJQUFJMVYsT0FBTyxDQUFDLFNBQVUrVixJQUFJO1lBQ2pELHdGQUF3RjtZQUN4RiwyRUFBMkU7WUFDM0UsSUFBSXZDLFFBQVMsRUFBQ0EsS0FBS3RVLE1BQU0sSUFBSSxDQUFDc1UsS0FBS21CLElBQUksQ0FBQyxTQUFVOVYsQ0FBQztnQkFDakQsT0FBT0EsRUFBRTRPLFdBQVcsS0FBS3NJLEtBQUt0SSxXQUFXO1lBQzNDLEVBQUMsR0FBSTtnQkFDSCxJQUFJQSxjQUFjc0ksS0FBS3RJLFdBQVc7Z0JBQ2xDLElBQUkvSyxXQUFXK0ssWUFBWXpJLFVBQVU7Z0JBRXJDLElBQUl0QyxVQUFVO29CQUNaLElBQUlBLFNBQVN5VCxVQUFVLEVBQUV6VCxTQUFTeVQsVUFBVSxDQUFDbGEsU0FBUyxDQUFDLEdBQUc4WixNQUFNO3dCQUM5RHBRLE1BQU07b0JBQ1I7b0JBQ0EsSUFBSWpELFNBQVMwVCxZQUFZLEVBQUUxVCxTQUFTMFQsWUFBWSxDQUFDbmEsU0FBUyxDQUFDLEdBQUc4WixNQUFNO3dCQUNsRXBRLE1BQU07b0JBQ1I7Z0JBQ0Y7Z0JBRUE0TyxPQUFPLENBQUMsU0FBUyxDQUFDaEgsT0FBT3dJO1lBQzNCO1FBQ0Y7SUFDRixHQUFHLEVBQUU7SUFDTCxJQUFJTyxnQkFBZ0JoYSxNQUFNb1YsV0FBVyxDQUFDLFNBQVVsTixJQUFJO1FBQ2xELE9BQU8sU0FBVWdKLEtBQUssRUFBRStELE9BQU87WUFDN0IsSUFBSUEsWUFBWSxLQUFLLEdBQUc7Z0JBQ3RCQSxVQUFVO1lBQ1o7WUFFQTNSLE1BQU1PLE9BQU8sQ0FBQ3lRLE9BQU8sQ0FBQ2tGLElBQUksQ0FBQ3RSLE1BQU1nSjtZQUNqQyxJQUFJK0QsU0FBUzBCLFdBQVd6RjtZQUN4QixJQUFJZ0csT0FBT2lCLGlCQUFpQmpILE9BQU8sU0FBVXVJLElBQUk7Z0JBQy9DLElBQUl0SSxjQUFjc0ksS0FBS3RJLFdBQVc7Z0JBQ2xDLElBQUkvSyxXQUFXK0ssWUFBWXpJLFVBQVU7Z0JBRXJDLElBQUl0QyxZQUFZQSxRQUFRLENBQUM4QixLQUFLLEVBQUU7b0JBQzlCLDJGQUEyRjtvQkFDM0Ysb0NBQW9DO29CQUNwQyxJQUFJQSxTQUFTLFdBQVdBLFNBQVMsaUJBQWlCQSxTQUFTLGlCQUFpQjVFLE1BQU1PLE9BQU8sQ0FBQ3dRLFdBQVcsQ0FBQy9OLFFBQVEsQ0FBQzZLLGNBQWM7d0JBQzNIL0ssUUFBUSxDQUFDOEIsS0FBSyxDQUFDdVI7b0JBQ2pCO2dCQUNGO1lBQ0YsSUFBSSxtRUFBbUU7WUFFdkUsSUFBSXZSLFNBQVMsZUFBZTtnQkFDMUI1RSxNQUFNTyxPQUFPLENBQUN1USxZQUFZLEdBQUc7b0JBQUNsRCxNQUFNMEYsT0FBTztvQkFBRTFGLE1BQU0yRixPQUFPO2lCQUFDO2dCQUMzRHZULE1BQU1PLE9BQU8sQ0FBQ3dRLFdBQVcsR0FBRzZDLEtBQUtuUSxHQUFHLENBQUMsU0FBVXVSLEdBQUc7b0JBQ2hELE9BQU9BLElBQUluSCxXQUFXO2dCQUN4QjtZQUNGO1lBRUEsSUFBSSxDQUFDakosU0FBUyxXQUFXQSxTQUFTLGlCQUFpQkEsU0FBUyxhQUFZLEtBQU0sQ0FBQ2dQLEtBQUt0VSxNQUFNLElBQUkyUCxpQkFBaUI7Z0JBQzdHLElBQUlxRixrQkFBa0IxRyxVQUFVLEdBQUdxQjtZQUNyQztRQUNGO0lBQ0YsR0FBRztRQUFDQTtLQUFnQjtJQUNwQnZTLE1BQU1rVyxPQUFPLENBQUM7UUFDWjVTLE1BQU1PLE9BQU8sQ0FBQzRRLE1BQU0sR0FBRztZQUNyQndGLFNBQVNELGNBQWM7WUFDdkJFLGVBQWVGLGNBQWM7WUFDN0JHLGVBQWVILGNBQWM7WUFDN0JJLFNBQVNKLGNBQWM7WUFDdkJLLGVBQWVMLGNBQWM7WUFDN0JNLGFBQWFOLGNBQWM7WUFDM0JPLGdCQUFnQixTQUFTQSxlQUFlQyxDQUFDO2dCQUN2QyxPQUFPbkIsb0JBQW9CbUIsR0FBRyxFQUFFO1lBQ2xDO1lBQ0FDLGVBQWV2RjtZQUNmLG9GQUFvRjtZQUNwRix3RkFBd0Y7WUFDeEYscUZBQXFGO1lBQ3JGd0YsMkJBQTJCLFNBQVNBLDBCQUEwQkYsQ0FBQztnQkFDN0QsT0FBT2xYLE1BQU1PLE9BQU8sQ0FBQzJRLFFBQVEsR0FBR1EsVUFBVXdGO1lBQzVDO1lBQ0FHLHNCQUFzQixTQUFTQSxxQkFBcUJILENBQUM7Z0JBQ25ELE9BQU9sWCxNQUFNTyxPQUFPLENBQUMyUSxRQUFRLEdBQUdyVCxXQUFXa1ksb0JBQW9CbUI7WUFDakU7UUFDRjtJQUNGLEdBQUc7UUFBQ2pJO0tBQWdCO0lBQ3BCLDZHQUE2RyxHQUM3RyxtREFBbUQ7SUFFbkQsSUFBSWlGLGNBQWN4WCxNQUFNaVUsTUFBTTtJQUM5QmpVLE1BQU1rVyxPQUFPLENBQUM7UUFDWixJQUFJMEUsaUJBQWlCdFgsTUFBTU8sT0FBTyxFQUM5QnFCLFFBQVEwVixlQUFlMVYsS0FBSyxFQUM1QlgsU0FBU3FXLGVBQWVyVyxNQUFNLEVBQzlCYyxLQUFLdVYsZUFBZXZWLEVBQUUsRUFDdEJnTixXQUFXdUksZUFBZXZJLFFBQVEsRUFDbEMvTixzQkFBc0JzVyxlQUFldFcsbUJBQW1CLEVBQ3hESCxTQUFTeVcsZUFBZXpXLE1BQU0sRUFDOUJILGNBQWM0VyxlQUFlNVcsV0FBVyxFQUN4Q3dRLFdBQVdvRyxlQUFlcEcsUUFBUSxFQUNsQ0osZUFBZXdHLGVBQWV4RyxZQUFZLEVBQzFDQyxjQUFjdUcsZUFBZXZHLFdBQVcsRUFDeEMxSyxRQUFROUosOEJBQThCK2EsZ0JBQWdCO1lBQUM7WUFBUztZQUFVO1lBQU07WUFBWTtZQUF1QjtZQUFVO1lBQWU7WUFBWTtZQUFnQjtTQUFjO1FBRTFMcEQsWUFBWTNULE9BQU8sR0FBRzhGO0lBQ3hCLEdBQUc7UUFBQytIO1FBQU1tQztLQUFXLEdBQUcscUJBQXFCO0lBRTdDN1QsTUFBTTZhLGVBQWUsQ0FBQztRQUNwQixPQUFPLEtBQU1sSixDQUFBQSxjQUFjbk4sR0FBR3NXLGFBQWEsQ0FBQ25KLFdBQVU7SUFDeEQsR0FBRztRQUFDQTtLQUFXLEdBQUcsb0JBQW9CO0lBRXRDM1IsTUFBTTZhLGVBQWUsQ0FBQztRQUNwQixJQUFJOUksV0FBVztZQUNidk4sR0FBR3VOLFNBQVMsQ0FBQ2dKLE9BQU8sR0FBRztZQUN2QixJQUFJLE9BQU9oSixjQUFjLFVBQVUxUyxPQUFPOFcsTUFBTSxDQUFDM1IsSUFBSXVOO2lCQUFnQnZOLEdBQUd1TixTQUFTLENBQUMxSSxJQUFJLEdBQUd0SixNQUFNaWIsZ0JBQWdCO1FBQ2pIO1FBRUEsSUFBSXBULGlCQUFpQjtZQUNuQnBELEdBQUd5VyxXQUFXLEdBQUdsYixNQUFNbWIscUJBQXFCO1lBQzVDMVcsR0FBRzJXLGNBQWMsR0FBR3BiLE1BQU13SSxZQUFZO1FBQ3hDO0lBQ0YsR0FBRztRQUFDd0o7UUFBV25LO0tBQWdCLEdBQUcsa0ZBQWtGO0lBQ3BILGlFQUFpRTtJQUVqRSxJQUFJd1QsU0FBU3BiLE1BQU1vVixXQUFXLENBQUMsU0FBU2dHLE9BQU96UixLQUFLO1FBQ2xELElBQUkwUixXQUFXLFNBQVNBO1lBQ3RCLE9BQU8zSSxTQUFTO1FBQ2xCLEdBQUcsc0RBQXNEO1FBR3pEMVMsTUFBTXNiLFNBQVMsQ0FBQztZQUNkLElBQUlDLFNBQVNqSixhQUFhQSxVQUFVaFAsTUFBTU8sT0FBTztZQUNqRCxPQUFPLEtBQU0wWCxDQUFBQSxVQUFVQSxPQUFPQyxJQUFJLEdBQUdELE9BQU9DLElBQUksQ0FBQ0gsWUFBWUEsVUFBUztRQUN4RSxHQUFHLEVBQUU7UUFDTCxPQUFPMVIsTUFBTXVCLFFBQVE7SUFDdkIsR0FBRyxFQUFFLEdBQUcsMEJBQTBCO0lBRWxDbEwsTUFBTTZhLGVBQWUsQ0FBQztRQUNwQnBXLE9BQVEsV0FBVyxHQUFFekUsTUFBTXliLGFBQWEsQ0FBQ0wsUUFBUSxNQUFNLFdBQVcsR0FBRXBiLE1BQU15YixhQUFhLENBQUNwSyxhQUFhcUssUUFBUSxFQUFFO1lBQzdHbGMsT0FBT2dZLFlBQVkzVCxPQUFPO1FBQzVCLEdBQUcsT0FBT3FILGFBQWEsYUFBYUEsU0FBUzVILE1BQU1PLE9BQU8sSUFBSXFILFlBQVltSSxjQUFjL1A7SUFDMUYsR0FBRztRQUFDNEI7UUFBT2dHO1FBQVVzTSxZQUFZM1QsT0FBTztLQUFDO0lBQ3pDN0QsTUFBTTZhLGVBQWUsQ0FBQztRQUNwQixJQUFJM1YsT0FBTztZQUNULCtEQUErRDtZQUMvRCxJQUFJLENBQUM1QixNQUFNTyxPQUFPLENBQUN3QixFQUFFLEVBQUU7Z0JBQ3JCRCxXQUFXOUI7WUFDYixPQUFPLElBQUksQ0FBQ2tCLEdBQUdtWCxFQUFFLElBQUluWCxHQUFHYSxFQUFFLEtBQUtiLEdBQUdvWCxnQkFBZ0IsRUFBRTtnQkFDakRwWCxDQUFBQSxHQUFHbVgsRUFBRSxJQUFJblgsR0FBR2EsRUFBRSxFQUFFMFYsT0FBTyxHQUFHO2dCQUMzQnZXLEdBQUdvWCxnQkFBZ0IsQ0FBQyxTQUFVQyxDQUFDO29CQUM3QixPQUFPeFksU0FBU0MsT0FBT3VZLEdBQUcsR0FBRztnQkFDL0I7WUFDRixPQUFPQyxRQUFRQyxJQUFJLENBQUM7UUFDdEI7SUFDRixHQUFHO1FBQUM3VztRQUFPWjtLQUFvQixHQUFHLDhCQUE4QjtJQUVoRXRFLE1BQU1zYixTQUFTLENBQUM7UUFDZCxPQUFPO1lBQ0wsSUFBSWhZLE1BQU1PLE9BQU8sQ0FBQ1csRUFBRSxFQUFFO2dCQUNwQmxCLE1BQU1PLE9BQU8sQ0FBQ1csRUFBRSxDQUFDd1gsV0FBVyxDQUFDblMsT0FBTztnQkFDcEMsSUFBSXZHLE1BQU1PLE9BQU8sQ0FBQ1csRUFBRSxDQUFDeVgsZ0JBQWdCLEVBQUUzWSxNQUFNTyxPQUFPLENBQUNXLEVBQUUsQ0FBQ3lYLGdCQUFnQjtnQkFDeEVwUyxRQUFRdkcsTUFBTU8sT0FBTyxDQUFDVyxFQUFFO1lBQzFCO1lBRUEySyx1QkFBdUI3TCxNQUFNTyxPQUFPLENBQUNhLEtBQUssRUFBRTtnQkFDMUNtRixRQUFRdkcsTUFBTU8sT0FBTyxDQUFDYSxLQUFLO2dCQUMzQm1GLFFBQVF2RyxNQUFNTyxPQUFPLENBQUM0TixTQUFTO2dCQUMvQjVILFFBQVF2RyxNQUFNTyxPQUFPLENBQUNjLE1BQU07Z0JBQzVCa0YsUUFBUXZHLE1BQU1PLE9BQU87WUFDdkI7UUFDRjtJQUNGLEdBQUcsRUFBRTtJQUNMLE9BQU9QLE1BQU1PLE9BQU8sQ0FBQzRRLE1BQU07QUFDN0I7QUFFQSxTQUFTNUssUUFBUWpJLEdBQUc7SUFDbEIsSUFBSUEsSUFBSWlJLE9BQU8sRUFBRWpJLElBQUlpSSxPQUFPO0lBRTVCLElBQUssSUFBSXFTLEtBQUt0YSxJQUFLO1FBQ2pCLElBQUksT0FBT3NhLE1BQU0sWUFBWUEsRUFBRXJTLE9BQU8sRUFBRXFTLEVBQUVyUyxPQUFPO1FBQ2pELE9BQU9qSSxHQUFHLENBQUNzYSxFQUFFO0lBQ2Y7QUFDRjtBQUVBLFNBQVNDLFdBQVdDLE9BQU87SUFDekIsSUFBSWIsU0FBU3ZiLE1BQU1tYyxVQUFVLENBQUNDO0lBRTlCLElBQUksQ0FBQ2IsUUFBUTtRQUNYTyxRQUFRQyxJQUFJLENBQUM7SUFDZjtJQUVBLE9BQU9SO0FBQ1Q7QUFFQSxTQUFTYyxTQUFTNVosUUFBUSxFQUFFNlosY0FBYztJQUN4QyxJQUFJQSxtQkFBbUIsS0FBSyxHQUFHO1FBQzdCQSxpQkFBaUI7SUFDbkI7SUFFQSxJQUFJQyxjQUFjSixXQUFXOUssZUFDekJxRCxZQUFZNkgsWUFBWTdILFNBQVMsRUFBRSxhQUFhO0lBR3BELElBQUl4USxNQUFNbEUsTUFBTWlVLE1BQU0sQ0FBQ3hSO0lBQ3ZCekMsTUFBTTZhLGVBQWUsQ0FBQztRQUNwQixPQUFPLEtBQU0zVyxDQUFBQSxJQUFJTCxPQUFPLEdBQUdwQixRQUFPO0lBQ3BDLEdBQUc7UUFBQ0E7S0FBUyxHQUFHLGtCQUFrQjtJQUVsQ3pDLE1BQU1zYixTQUFTLENBQUM7UUFDZCxJQUFJa0IsY0FBYzlILFVBQVV4USxLQUFLb1k7UUFDakMsT0FBTztZQUNMLE9BQU9FO1FBQ1Q7SUFDRixHQUFHO1FBQUNGO0tBQWU7SUFDbkIsT0FBTztBQUNUO0FBQ0EsU0FBU0c7SUFDUCxPQUFPTixXQUFXOUs7QUFDcEI7QUFDQSxTQUFTcUwsVUFBVWphLFFBQVEsRUFBRWthLFVBQVUsRUFBRUMsV0FBVztJQUNsRCxJQUFJQyxlQUFlVixXQUFXOUssZUFDMUJqTSxhQUFheVgsYUFBYXpYLFVBQVU7SUFFeEMsSUFBSTBYLFdBQVc5YyxNQUFNaVUsTUFBTTtJQUMzQixJQUFJL1AsTUFBTTBZLGNBQWNBLGNBQWNFO0lBQ3RDOWMsTUFBTTZhLGVBQWUsQ0FBQztRQUNwQixJQUFJM1csSUFBSUwsT0FBTyxFQUFFO1lBQ2ZwQixTQUFTeUIsSUFBSUwsT0FBTztZQUNwQnVCO1FBQ0Y7SUFDRixHQUFHdVg7SUFDSCxPQUFPelk7QUFDVDtBQUNBLFNBQVM2WSxZQUFZSCxXQUFXO0lBQzlCLElBQUlwSyxZQUFZeFMsTUFBTXlTLFFBQVEsQ0FBQyxRQUMzQjVMLElBQUkyTCxTQUFTLENBQUMsRUFBRSxFQUNoQndLLGNBQWN4SyxTQUFTLENBQUMsRUFBRTtJQUU5QixJQUFJc0ssV0FBVzljLE1BQU1pVSxNQUFNLENBQUM5UztJQUM1QixJQUFJK0MsTUFBTTBZLGNBQWNBLGNBQWNFO0lBQ3RDOWMsTUFBTTZhLGVBQWUsQ0FBQztRQUNwQixPQUFPLEtBQUttQyxZQUFZLFNBQVV6YSxDQUFDO1lBQ2pDLE9BQU8sQ0FBQ0E7UUFDVjtJQUNGLEdBQUc7UUFBQzJCLElBQUlMLE9BQU87S0FBQztJQUNoQixPQUFPO1FBQUNLO1FBQUtBLElBQUlMLE9BQU87S0FBQztBQUMzQjtBQUNBLFNBQVNvWixVQUFVQyxLQUFLLEVBQUVDLEdBQUcsRUFBRUMsVUFBVSxFQUFFQyxVQUFVO0lBQ25ELElBQUlDLFNBQVN0ZCxNQUFNa1csT0FBTyxDQUFDO1FBQ3pCLHVCQUF1QjtRQUN2QixJQUFJZ0MsT0FBTyxJQUFJZ0YsU0FBUyx3QkFBd0I7UUFFaEQsSUFBSUUsWUFBWUEsV0FBV2xGO1FBQzNCLE9BQU9BO0lBQ1QsR0FBRztRQUFDZ0Y7S0FBTSxHQUFHLG9DQUFvQztJQUVqRCxJQUFJSyxVQUFVbGQsV0FBVyxTQUFVNmMsS0FBSyxFQUFFQyxHQUFHO1FBQzNDLElBQUlLLFdBQVdyYixNQUFNQyxPQUFPLENBQUMrYSxPQUFPQSxNQUFNO1lBQUNBO1NBQUk7UUFDL0MsT0FBT00sUUFBUUMsR0FBRyxDQUFDRixTQUFTelcsR0FBRyxDQUFDLFNBQVVvVyxHQUFHO1lBQzNDLE9BQU8sSUFBSU0sUUFBUSxTQUFVcmMsR0FBRyxFQUFFdWMsTUFBTTtnQkFDdEMsT0FBT0wsT0FBT00sSUFBSSxDQUFDVCxLQUFLLFNBQVUxRCxJQUFJO29CQUNwQyxJQUFJQSxLQUFLL1UsS0FBSyxFQUFFO3dCQUNkK1UsS0FBS29FLEtBQUssR0FBRyxDQUFDO3dCQUNkcEUsS0FBS3FFLFNBQVMsR0FBRyxDQUFDO3dCQUNsQnJFLEtBQUsvVSxLQUFLLENBQUNxWixRQUFRLENBQUMsU0FBVW5jLEdBQUc7NEJBQy9CLElBQUlpSDs0QkFFSixJQUFJakgsSUFBSXNHLElBQUksRUFBRXVSLEtBQUtvRSxLQUFLLEdBQUdsZSxTQUFTLENBQUMsR0FBRzhaLEtBQUtvRSxLQUFLLEVBQUdoVixDQUFBQSxZQUFZLENBQUMsR0FBR0EsU0FBUyxDQUFDakgsSUFBSXNHLElBQUksQ0FBQyxHQUFHdEcsS0FBS2lILFNBQVE7NEJBQ3hHLElBQUlqSCxJQUFJb2MsUUFBUSxJQUFJLENBQUN2RSxLQUFLcUUsU0FBUyxDQUFDbGMsSUFBSW9jLFFBQVEsQ0FBQzlWLElBQUksQ0FBQyxFQUFFdVIsS0FBS3FFLFNBQVMsQ0FBQ2xjLElBQUlvYyxRQUFRLENBQUM5VixJQUFJLENBQUMsR0FBR3RHLElBQUlvYyxRQUFRO3dCQUMxRztvQkFDRjtvQkFFQTVjLElBQUlxWTtnQkFDTixHQUFHNEQsWUFBWSxTQUFVWSxLQUFLO29CQUM1QixPQUFPTixPQUFPTSxNQUFNQyxPQUFPO2dCQUM3QjtZQUNGO1FBQ0Y7SUFDRixHQUFHO1FBQUNoQjtRQUFPQztLQUFJLEdBQUcsc0JBQXNCO0lBRXhDLE9BQU9oYixNQUFNQyxPQUFPLENBQUMrYSxPQUFPSSxVQUFVQSxPQUFPLENBQUMsRUFBRTtBQUNsRDtBQUVBLElBQUlZLGdCQUFnQjtJQUNsQnpLLFVBQVU7SUFDVjZCLE9BQU87SUFDUEMsUUFBUTtJQUNSNEksVUFBVTtBQUNaO0FBRUEsU0FBU0MsUUFBUXBYLElBQUk7SUFDbkIsSUFBSWlFLFdBQVdqRSxLQUFLaUUsUUFBUSxFQUN4Qm9ULFlBQVlyWCxLQUFLcVgsU0FBUyxFQUMxQnZZLFlBQVlrQixLQUFLbEIsU0FBUyxFQUMxQndZLFdBQVd0WCxLQUFLc1gsUUFBUSxFQUN4QkMsVUFBVXZYLEtBQUt1WCxPQUFPLEVBQ3RCN1UsUUFBUTlKLDhCQUE4Qm9ILE1BQU07UUFBQztRQUFZO1FBQWE7UUFBYTtRQUFZO0tBQVU7SUFFN0csa0JBQWtCO0lBQ2xCLElBQUl1TCxZQUFZeFMsTUFBTXlTLFFBQVEsQ0FBQzhMLFdBQzNCL1osS0FBS2dPLFNBQVMsQ0FBQyxFQUFFO0lBRXJCLElBQUksQ0FBQ2hPLElBQUlzWCxRQUFRQyxJQUFJLENBQUMseUJBQXlCLCtCQUErQjtJQUU5RS9iLE1BQU1zYixTQUFTLENBQUM7UUFDZCxPQUFPa0QsV0FBV0EsUUFBUWhhLElBQUl1QjtJQUNoQyxHQUFHLEVBQUUsR0FBRyxnRUFBZ0U7SUFFeEUsSUFBSTBPLFNBQVNsRCxVQUFVNVIsU0FBUyxDQUFDLEdBQUdnSyxPQUFPO1FBQ3pDdUIsVUFBVUE7UUFDVjFHLElBQUlBO0lBQ047SUFDQXhFLE1BQU1zYixTQUFTLENBQUM7UUFDZCxPQUFPLEtBQUtnRCxVQUFVN0o7SUFDeEIsR0FBRztRQUFDQTtLQUFPO0lBQ1gsT0FBTztBQUNUO0FBRUEsSUFBSWdLLGtCQUFrQixXQUFXLEdBQUV4ZSxlQUFleWUsSUFBSSxDQUFDLFNBQVNELGdCQUFnQjlVLEtBQUs7SUFDbkYsSUFBSTRVLFdBQVc1VSxNQUFNNFUsUUFBUSxFQUN6QkMsVUFBVTdVLE1BQU02VSxPQUFPLEVBQ3ZCdFQsV0FBV3ZCLE1BQU11QixRQUFRLEVBQ3pCN0YsS0FBS3NFLE1BQU10RSxFQUFFLEVBQ2JzWixNQUFNaFYsTUFBTWdWLEdBQUcsRUFDZjNQLGFBQWFyRixNQUFNcUYsVUFBVSxFQUM3QitDLFlBQVlwSSxNQUFNb0ksU0FBUyxFQUMzQm5LLGtCQUFrQitCLE1BQU0vQixlQUFlLEVBQ3ZDNEosZUFBZTdILE1BQU02SCxZQUFZLEVBQ2pDbE4sc0JBQXNCcUYsTUFBTXJGLG1CQUFtQixFQUMvQzZOLHNCQUFzQnhJLE1BQU13SSxtQkFBbUIsRUFDL0NFLFdBQVcxSSxNQUFNMEksUUFBUSxFQUN6QjdOLEtBQUttRixNQUFNbkYsRUFBRSxFQUNiRyxTQUFTZ0YsTUFBTWhGLE1BQU0sRUFDckI4TSxZQUFZOUgsTUFBTThILFNBQVMsRUFDM0JFLGFBQWFoSSxNQUFNZ0ksVUFBVSxFQUM3QlcsWUFBWTNJLE1BQU0ySSxTQUFTLEVBQzNCQyxrQkFBa0I1SSxNQUFNNEksZUFBZSxFQUN2Q3FNLFlBQVlqVixNQUFNaVYsU0FBUyxFQUMzQkMsU0FBU2xWLE1BQU1rVixNQUFNLEVBQ3JCQyxRQUFRblYsTUFBTW1WLEtBQUssRUFDbkJDLGFBQWFsZiw4QkFBOEI4SixPQUFPO1FBQUM7UUFBWTtRQUFXO1FBQVk7UUFBTTtRQUFPO1FBQWM7UUFBYTtRQUFtQjtRQUFnQjtRQUF1QjtRQUF1QjtRQUFZO1FBQU07UUFBVTtRQUFhO1FBQWM7UUFBYTtRQUFtQjtRQUFhO1FBQVU7S0FBUTtJQUV6VSxJQUFJcVYsZUFBZWhmLE1BQU1pVSxNQUFNLElBQUksaUdBQWlHO0lBRXBJLElBQUl0QixhQUFhM1MsTUFBTXlTLFFBQVEsQ0FBQyxDQUFDLElBQzdCd00sY0FBY3RNLFVBQVUsQ0FBQyxFQUFFLEVBQzNCK0gsNEJBQTRCdUUsWUFBWXZFLHlCQUF5QixFQUNqRWpHLFNBQVM1VSw4QkFBOEJvZixhQUFhO1FBQUM7S0FBNEIsR0FDakZYLFlBQVkzTCxVQUFVLENBQUMsRUFBRTtJQUU3QixJQUFJdU0sY0FBYzVlLFdBQVd1ZSxVQUFVO1FBQ3JDTSxRQUFRO1FBQ1JDLFVBQVU7WUFDUkQsUUFBUTtZQUNSTixRQUFRO1FBQ1Y7UUFDQVEsVUFBVSxLQUF1RCxHQUFHOWUsZUFBZWdmLGNBQWMsR0FBR3BlLENBQVNBO0lBQy9HLElBQ0lrUCxPQUFPNk8sV0FBVyxDQUFDLEVBQUUsRUFDckJ4TixPQUFPd04sV0FBVyxDQUFDLEVBQUUsRUFDckI1WixjQUFjNFosV0FBVyxDQUFDLEVBQUUsRUFBRSw4Q0FBOEM7SUFHaEYsSUFBSU0sWUFBWXhmLE1BQU1pVSxNQUFNLENBQUM7SUFDN0IsSUFBSS9PLFFBQVFsRixNQUFNa1csT0FBTyxDQUFDO1FBQ3hCLE9BQU9zSixVQUFVM2IsT0FBTyxHQUFHMmIsVUFBVTNiLE9BQU8sSUFBSSxDQUFDLENBQUM2TixLQUFLNkQsS0FBSyxJQUFJLENBQUMsQ0FBQzdELEtBQUs4RCxNQUFNO0lBQy9FLEdBQUc7UUFBQzlEO0tBQUs7SUFDVCxJQUFJcE8sUUFBUXRELE1BQU1rVyxPQUFPLENBQUM7UUFDeEIsT0FBTztZQUNMeEUsTUFBTUE7WUFDTnBNLGFBQWFBO1lBQ2JnWixXQUFXQTtZQUNYdlksV0FBV2laLGFBQWFuYixPQUFPO1FBQ2pDO0lBQ0YsR0FBRztRQUFDNk47S0FBSyxHQUFHLGlHQUFpRztJQUU3RyxJQUFJLElBQWtCLEVBQWEsT0FBTyxXQUFXLEdBQUV6UixlQUFld2IsYUFBYSxDQUFDLE9BQU85YixTQUFTO1FBQ2xHbWYsT0FBT25mLFNBQVMsQ0FBQyxHQUFHd2UsZUFBZVc7SUFDckMsR0FBR0MsYUFBYUgsWUFBWSxpQ0FBaUM7SUFFN0QsT0FBTyxXQUFXLEdBQUUzZSxlQUFld2IsYUFBYSxDQUFDLE9BQU85YixTQUFTO1FBQy9EdUUsS0FBSzFELFVBQVU7WUFBQzZQO1lBQU0yTztTQUFhO1FBQ25DRixPQUFPbmYsU0FBUyxDQUFDLEdBQUd3ZSxlQUFlVztJQUNyQyxHQUFHckssUUFBUXNLLGFBQWFILFdBQVcxWixTQUFTLFdBQVcsR0FBRWpGLGVBQWV3YixhQUFhLENBQUM0QyxTQUFTMWUsU0FBUyxDQUFDLEdBQUdnSyxPQUFPckc7QUFDckg7QUFFQSxJQUFJOFgsU0FBUyxXQUFXLEdBQUVuYixlQUFleWUsSUFBSSxDQUFDLFNBQVN0RCxPQUFPblUsSUFBSTtJQUNoRSxJQUFJaUUsV0FBV2pFLEtBQUtpRSxRQUFRLEVBQ3hCdkIsUUFBUTlKLDhCQUE4Qm9ILE1BQU07UUFBQztLQUFXO0lBRTVELElBQUl3WSxZQUFZemYsTUFBTWlVLE1BQU07SUFDNUIsT0FBTyxXQUFXLEdBQUVoVSxlQUFld2IsYUFBYSxDQUFDZ0QsaUJBQWlCOWUsU0FBUyxDQUFDLEdBQUdnSyxPQUFPO1FBQ3BGNFUsVUFBVSxTQUFTQTtZQUNqQixJQUFJa0IsVUFBVTViLE9BQU8sRUFBRTtnQkFDckIsSUFBSTZiLFNBQVMvZixTQUFTO29CQUNwQmdnQixXQUFXO29CQUNYQyxPQUFPO2dCQUNULEdBQUdqVyxNQUFNbkYsRUFBRTtnQkFFWCxJQUFJMFQsT0FBTyxJQUFJblksTUFBTThmLGFBQWEsQ0FBQ2xnQixTQUFTO29CQUMxQ21nQixpQkFBaUI7b0JBQ2pCLGlCQUFpQjtvQkFDakIsZUFBZTtvQkFDZkMsUUFBUU4sVUFBVTViLE9BQU87b0JBQ3pCdVksU0FBU3pTLE1BQU1nVixHQUFHLEdBQUdjLFVBQVU1YixPQUFPLENBQUNtYyxVQUFVLENBQUMsVUFBVU4sVUFBVXZlO2dCQUN4RSxHQUFHdWU7Z0JBQ0gsT0FBT3hIO1lBQ1Q7UUFDRjtRQUNBMEcsV0FBVyxXQUFXLEdBQUUzZSxlQUFld2IsYUFBYSxDQUFDLFVBQVU7WUFDN0R2WCxLQUFLdWI7WUFDTFgsT0FBTztnQkFDTG1CLFNBQVM7WUFDWDtRQUNGO0lBQ0YsSUFBSS9VO0FBQ047QUFFQTNMLGNBQWMsR0FBRzZiO0FBQ2pCN2IsZ0JBQWdCLEdBQUd5TTtBQUNuQnpNLHNCQUFzQixHQUFHNEQ7QUFDekI1RCxpQkFBaUIsR0FBRzJEO0FBQ3BCM0QsZUFBZSxHQUFHNkQ7QUFDbEI3RCxrQkFBa0IsR0FBR21HO0FBQ3JCbkcsb0JBQW9CLEdBQUc2UDtBQUN2QjdQLGNBQWMsR0FBR2lHO0FBQ2pCakcsbUJBQW1CLEdBQUcrRjtBQUN0Qi9GLGtCQUFrQixHQUFHNkY7QUFDckI3Riw0QkFBNEIsR0FBR3dSO0FBQy9CeFIsY0FBYyxHQUFHa0Y7QUFDakJsRixnQkFBZ0IsR0FBRzhEO0FBQ25COUQsb0JBQW9CLEdBQUc4UjtBQUN2QjlSLDhCQUE4QixHQUFHNFA7QUFDakM1UCxpQkFBaUIsR0FBR2dTO0FBQ3BCaFMsZ0JBQWdCLEdBQUc4YztBQUNuQjljLGlCQUFpQixHQUFHMGQ7QUFDcEIxZCxtQkFBbUIsR0FBR3dkO0FBQ3RCeGQsZ0JBQWdCLEdBQUdrZDtBQUNuQmxkLGlCQUFpQixHQUFHbWQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vYS1wcm9qLWNhbm5vbi1sb2wvLi9ub2RlX21vZHVsZXMvcmVhY3QtdGhyZWUtZmliZXIvd2ViLmNqcy5qcz9mZmFiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChleCkgeyByZXR1cm4gKGV4ICYmICh0eXBlb2YgZXggPT09ICdvYmplY3QnKSAmJiAnZGVmYXVsdCcgaW4gZXgpID8gZXhbJ2RlZmF1bHQnXSA6IGV4OyB9XG5cbnZhciBfZXh0ZW5kcyA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2V4dGVuZHMnKSk7XG52YXIgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlJykpO1xudmFyIF9jb25zdHJ1Y3QgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jb25zdHJ1Y3QnKSk7XG52YXIgVEhSRUUgPSByZXF1aXJlKCd0aHJlZScpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdF9fZGVmYXVsdCA9IF9pbnRlcm9wRGVmYXVsdChSZWFjdCk7XG52YXIgUmVjb25jaWxlciA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdyZWFjdC1yZWNvbmNpbGVyJykpO1xudmFyIHNjaGVkdWxlciA9IHJlcXVpcmUoJ3NjaGVkdWxlcicpO1xudmFyIHRpbnlFbWl0dGVyID0gcmVxdWlyZSgndGlueS1lbWl0dGVyJyk7XG52YXIgdXNlUHJvbWlzZSA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdyZWFjdC1wcm9taXNlLXN1c3BlbnNlJykpO1xudmFyIHVzZU1lYXN1cmUgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgncmVhY3QtdXNlLW1lYXN1cmUnKSk7XG52YXIgcmVzaXplT2JzZXJ2ZXIgPSByZXF1aXJlKCdAanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlcicpO1xudmFyIG1lcmdlUmVmcyA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdyZWFjdC1tZXJnZS1yZWZzJykpO1xuXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gdHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7IHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkgeyB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTsgaWYgKHR5cGVvZiByZXMgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTsgfVxudmFyIHJvb3RzID0gbmV3IE1hcCgpO1xudmFyIGVtcHR5T2JqZWN0ID0ge307XG52YXIgaXMgPSB7XG4gIG9iajogZnVuY3Rpb24gb2JqKGEpIHtcbiAgICByZXR1cm4gYSA9PT0gT2JqZWN0KGEpICYmICFpcy5hcnIoYSk7XG4gIH0sXG4gIGZ1bjogZnVuY3Rpb24gZnVuKGEpIHtcbiAgICByZXR1cm4gdHlwZW9mIGEgPT09ICdmdW5jdGlvbic7XG4gIH0sXG4gIHN0cjogZnVuY3Rpb24gc3RyKGEpIHtcbiAgICByZXR1cm4gdHlwZW9mIGEgPT09ICdzdHJpbmcnO1xuICB9LFxuICBudW06IGZ1bmN0aW9uIG51bShhKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBhID09PSAnbnVtYmVyJztcbiAgfSxcbiAgdW5kOiBmdW5jdGlvbiB1bmQoYSkge1xuICAgIHJldHVybiBhID09PSB2b2lkIDA7XG4gIH0sXG4gIGFycjogZnVuY3Rpb24gYXJyKGEpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhKTtcbiAgfSxcbiAgZXF1OiBmdW5jdGlvbiBlcXUoYSwgYikge1xuICAgIC8vIFdyb25nIHR5cGUgb3Igb25lIG9mIHRoZSB0d28gdW5kZWZpbmVkLCBkb2Vzbid0IG1hdGNoXG4gICAgaWYgKHR5cGVvZiBhICE9PSB0eXBlb2YgYiB8fCAhIWEgIT09ICEhYikgcmV0dXJuIGZhbHNlOyAvLyBBdG9taWMsIGp1c3QgY29tcGFyZSBhIGFnYWluc3QgYlxuXG4gICAgaWYgKGlzLnN0cihhKSB8fCBpcy5udW0oYSkgfHwgaXMub2JqKGEpKSByZXR1cm4gYSA9PT0gYjsgLy8gQXJyYXksIHNoYWxsb3cgY29tcGFyZSBmaXJzdCB0byBzZWUgaWYgaXQncyBhIG1hdGNoXG5cbiAgICBpZiAoaXMuYXJyKGEpICYmIGEgPT0gYikgcmV0dXJuIHRydWU7IC8vIExhc3QgcmVzb3J0LCBnbyB0aHJvdWdoIGtleXNcblxuICAgIHZhciBpO1xuXG4gICAgZm9yIChpIGluIGEpIHtcbiAgICAgIGlmICghKGkgaW4gYikpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgaW4gYikge1xuICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXMudW5kKGkpID8gYSA9PT0gYiA6IHRydWU7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVN1YnMoY2FsbGJhY2ssIHN1YnMpIHtcbiAgdmFyIGluZGV4ID0gc3Vicy5sZW5ndGg7XG4gIHN1YnMucHVzaChjYWxsYmFjayk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHZvaWQgc3Vicy5zcGxpY2UoaW5kZXgsIDEpO1xuICB9O1xufVxuXG52YXIgZ2xvYmFsRWZmZWN0cyA9IFtdO1xudmFyIGdsb2JhbEFmdGVyRWZmZWN0cyA9IFtdO1xudmFyIGdsb2JhbFRhaWxFZmZlY3RzID0gW107XG52YXIgYWRkRWZmZWN0ID0gZnVuY3Rpb24gYWRkRWZmZWN0KGNhbGxiYWNrKSB7XG4gIHJldHVybiBjcmVhdGVTdWJzKGNhbGxiYWNrLCBnbG9iYWxFZmZlY3RzKTtcbn07XG52YXIgYWRkQWZ0ZXJFZmZlY3QgPSBmdW5jdGlvbiBhZGRBZnRlckVmZmVjdChjYWxsYmFjaykge1xuICByZXR1cm4gY3JlYXRlU3VicyhjYWxsYmFjaywgZ2xvYmFsQWZ0ZXJFZmZlY3RzKTtcbn07XG52YXIgYWRkVGFpbCA9IGZ1bmN0aW9uIGFkZFRhaWwoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGNyZWF0ZVN1YnMoY2FsbGJhY2ssIGdsb2JhbFRhaWxFZmZlY3RzKTtcbn07XG5mdW5jdGlvbiByZW5kZXJHbChzdGF0ZSwgdGltZXN0YW1wLCByZXBlYXQsIHJ1bkdsb2JhbEVmZmVjdHMpIHtcbiAgaWYgKHJlcGVhdCA9PT0gdm9pZCAwKSB7XG4gICAgcmVwZWF0ID0gMDtcbiAgfVxuXG4gIGlmIChydW5HbG9iYWxFZmZlY3RzID09PSB2b2lkIDApIHtcbiAgICBydW5HbG9iYWxFZmZlY3RzID0gZmFsc2U7XG4gIH1cblxuICAvLyBSdW4gZ2xvYmFsIGVmZmVjdHNcbiAgaWYgKHJ1bkdsb2JhbEVmZmVjdHMpIGdsb2JhbEVmZmVjdHMuZm9yRWFjaChmdW5jdGlvbiAoZWZmZWN0KSB7XG4gICAgcmV0dXJuIGVmZmVjdCh0aW1lc3RhbXApICYmIHJlcGVhdCsrO1xuICB9KTsgLy8gUnVuIGxvY2FsIGVmZmVjdHNcblxuICB2YXIgZGVsdGEgPSBzdGF0ZS5jdXJyZW50LmNsb2NrLmdldERlbHRhKCk7XG4gIHN0YXRlLmN1cnJlbnQuc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3ViKSB7XG4gICAgcmV0dXJuIHN1Yi5yZWYuY3VycmVudChzdGF0ZS5jdXJyZW50LCBkZWx0YSk7XG4gIH0pOyAvLyBEZWNyZWFzZSBmcmFtZSBjb3VudFxuXG4gIHN0YXRlLmN1cnJlbnQuZnJhbWVzID0gTWF0aC5tYXgoMCwgc3RhdGUuY3VycmVudC5mcmFtZXMgLSAxKTtcbiAgcmVwZWF0ICs9ICFzdGF0ZS5jdXJyZW50LmludmFsaWRhdGVGcmFtZWxvb3AgPyAxIDogc3RhdGUuY3VycmVudC5mcmFtZXM7IC8vIFJlbmRlciBjb250ZW50XG5cbiAgaWYgKCFzdGF0ZS5jdXJyZW50Lm1hbnVhbCkgc3RhdGUuY3VycmVudC5nbC5yZW5kZXIoc3RhdGUuY3VycmVudC5zY2VuZSwgc3RhdGUuY3VycmVudC5jYW1lcmEpOyAvLyBSdW4gZ2xvYmFsIGVmZmVjdHNcblxuICBpZiAocnVuR2xvYmFsRWZmZWN0cykgZ2xvYmFsQWZ0ZXJFZmZlY3RzLmZvckVhY2goZnVuY3Rpb24gKGVmZmVjdCkge1xuICAgIHJldHVybiBlZmZlY3QodGltZXN0YW1wKTtcbiAgfSk7XG4gIHJldHVybiByZXBlYXQ7XG59XG52YXIgcnVubmluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiByZW5kZXJMb29wKHRpbWVzdGFtcCkge1xuICBydW5uaW5nID0gdHJ1ZTtcbiAgdmFyIHJlcGVhdCA9IDA7IC8vIFJ1biBnbG9iYWwgZWZmZWN0c1xuXG4gIGdsb2JhbEVmZmVjdHMuZm9yRWFjaChmdW5jdGlvbiAoZWZmZWN0KSB7XG4gICAgcmV0dXJuIGVmZmVjdCh0aW1lc3RhbXApICYmIHJlcGVhdCsrO1xuICB9KTtcbiAgcm9vdHMuZm9yRWFjaChmdW5jdGlvbiAocm9vdCkge1xuICAgIHZhciBzdGF0ZSA9IHJvb3QuY29udGFpbmVySW5mby5fX3N0YXRlOyAvLyBJZiB0aGUgZnJhbWVsb29wIGlzIGludmFsaWRhdGVkLCBkbyBub3QgcnVuIGFub3RoZXIgZnJhbWVcblxuICAgIGlmIChzdGF0ZS5jdXJyZW50LmFjdGl2ZSAmJiBzdGF0ZS5jdXJyZW50LnJlYWR5ICYmICghc3RhdGUuY3VycmVudC5pbnZhbGlkYXRlRnJhbWVsb29wIHx8IHN0YXRlLmN1cnJlbnQuZnJhbWVzID4gMCkpIHJlcGVhdCA9IHJlbmRlckdsKHN0YXRlLCB0aW1lc3RhbXAsIHJlcGVhdCk7XG4gIH0pOyAvLyBSdW4gZ2xvYmFsIGFmdGVyLWVmZmVjdHNcblxuICBnbG9iYWxBZnRlckVmZmVjdHMuZm9yRWFjaChmdW5jdGlvbiAoZWZmZWN0KSB7XG4gICAgcmV0dXJuIGVmZmVjdCh0aW1lc3RhbXApO1xuICB9KTtcbiAgaWYgKHJlcGVhdCAhPT0gMCkgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXJMb29wKTtlbHNlIHtcbiAgICAvLyBUYWlsIGNhbGwgZWZmZWN0cywgdGhleSBhcmUgY2FsbGVkIHdoZW4gcmVuZGVyaW5nIHN0b3BzXG4gICAgZ2xvYmFsVGFpbEVmZmVjdHMuZm9yRWFjaChmdW5jdGlvbiAoZWZmZWN0KSB7XG4gICAgICByZXR1cm4gZWZmZWN0KHRpbWVzdGFtcCk7XG4gICAgfSk7XG4gIH0gLy8gRmxhZyBlbmQgb2Ygb3BlcmF0aW9uXG5cbiAgcnVubmluZyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpbnZhbGlkYXRlKHN0YXRlLCBmcmFtZXMpIHtcbiAgaWYgKHN0YXRlID09PSB2b2lkIDApIHtcbiAgICBzdGF0ZSA9IHRydWU7XG4gIH1cblxuICBpZiAoZnJhbWVzID09PSB2b2lkIDApIHtcbiAgICBmcmFtZXMgPSAyO1xuICB9XG5cbiAgaWYgKHN0YXRlID09PSB0cnVlKSByb290cy5mb3JFYWNoKGZ1bmN0aW9uIChyb290KSB7XG4gICAgcmV0dXJuIHJvb3QuY29udGFpbmVySW5mby5fX3N0YXRlLmN1cnJlbnQuZnJhbWVzID0gZnJhbWVzO1xuICB9KTtlbHNlIGlmIChzdGF0ZSAmJiBzdGF0ZS5jdXJyZW50KSB7XG4gICAgaWYgKHN0YXRlLmN1cnJlbnQudnIpIHJldHVybjtcbiAgICBzdGF0ZS5jdXJyZW50LmZyYW1lcyA9IGZyYW1lcztcbiAgfVxuXG4gIGlmICghcnVubmluZykge1xuICAgIHJ1bm5pbmcgPSB0cnVlO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXJMb29wKTtcbiAgfVxufVxuZnVuY3Rpb24gZm9yY2VSZXNpemUoKSB7XG4gIHJvb3RzLmZvckVhY2goZnVuY3Rpb24gKHJvb3QpIHtcbiAgICByZXR1cm4gcm9vdC5jb250YWluZXJJbmZvLl9fc3RhdGUuY3VycmVudC5mb3JjZVJlc2l6ZSgpO1xuICB9KTtcbn1cbnZhciBjYXRhbG9ndWUgPSB7fTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiBleHRlbmQob2JqZWN0cykge1xuICByZXR1cm4gdm9pZCAoY2F0YWxvZ3VlID0gX2V4dGVuZHMoe30sIGNhdGFsb2d1ZSwgb2JqZWN0cykpO1xufTtcbmZ1bmN0aW9uIGFwcGx5UHJvcHMoaW5zdGFuY2UsIG5ld1Byb3BzLCBvbGRQcm9wcywgYWNjdW11bGF0aXZlKSB7XG4gIGlmIChvbGRQcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgb2xkUHJvcHMgPSB7fTtcbiAgfVxuXG4gIGlmIChhY2N1bXVsYXRpdmUgPT09IHZvaWQgMCkge1xuICAgIGFjY3VtdWxhdGl2ZSA9IGZhbHNlO1xuICB9XG5cbiAgLy8gRmlsdGVyIGVxdWFscywgZXZlbnRzIGFuZCByZXNlcnZlZCBwcm9wc1xuICB2YXIgY29udGFpbmVyID0gaW5zdGFuY2UuX19jb250YWluZXI7XG4gIHZhciBzYW1lUHJvcHMgPSBPYmplY3Qua2V5cyhuZXdQcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gaXMuZXF1KG5ld1Byb3BzW2tleV0sIG9sZFByb3BzW2tleV0pO1xuICB9KTtcbiAgdmFyIGhhbmRsZXJzID0gT2JqZWN0LmtleXMobmV3UHJvcHMpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgLy8gRXZlbnQtaGFuZGxlcnMgLi4uXG4gICAgLy8gICBhcmUgZnVuY3Rpb25zLCB0aGF0XG4gICAgLy8gICBzdGFydCB3aXRoIFwib25cIiwgYW5kXG4gICAgLy8gICBjb250YWluIHRoZSBuYW1lIFwiUG9pbnRlclwiLCBcIkNsaWNrXCIsIFwiQ29udGV4dE1lbnVcIiwgb3IgXCJXaGVlbFwiXG4gICAgaWYgKGlzLmZ1bihuZXdQcm9wc1trZXldKSAmJiBrZXkuc3RhcnRzV2l0aCgnb24nKSkge1xuICAgICAgcmV0dXJuIGtleS5pbmNsdWRlcygnUG9pbnRlcicpIHx8IGtleS5pbmNsdWRlcygnQ2xpY2snKSB8fCBrZXkuaW5jbHVkZXMoJ0NvbnRleHRNZW51JykgfHwga2V5LmluY2x1ZGVzKCdXaGVlbCcpO1xuICAgIH1cbiAgfSk7XG4gIHZhciBsZWZ0T3ZlcnMgPSBhY2N1bXVsYXRpdmUgPyBPYmplY3Qua2V5cyhvbGRQcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gbmV3UHJvcHNba2V5XSA9PT0gdm9pZCAwO1xuICB9KSA6IFtdO1xuICB2YXIgZmlsdGVyZWRQcm9wcyA9IFtdLmNvbmNhdChzYW1lUHJvcHMsIFsnY2hpbGRyZW4nLCAna2V5JywgJ3JlZiddKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcHJvcCkge1xuICAgIHZhciBfID0gYWNjW3Byb3BdLFxuICAgICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoYWNjLCBbcHJvcF0ubWFwKF90b1Byb3BlcnR5S2V5KSk7XG5cbiAgICByZXR1cm4gcmVzdDtcbiAgfSwgbmV3UHJvcHMpOyAvLyBBZGQgbGVmdC1vdmVycyBhcyB1bmRlZmluZWQgcHJvcHMgc28gdGhleSBjYW4gYmUgcmVtb3ZlZFxuXG4gIGxlZnRPdmVycy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4ga2V5ICE9PSAnY2hpbGRyZW4nICYmIChmaWx0ZXJlZFByb3BzW2tleV0gPSB1bmRlZmluZWQpO1xuICB9KTtcblxuICBpZiAoT2JqZWN0LmtleXMoZmlsdGVyZWRQcm9wcykubGVuZ3RoID4gMCkge1xuICAgIE9iamVjdC5lbnRyaWVzKGZpbHRlcmVkUHJvcHMpLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBrZXkgPSBfcmVmWzBdLFxuICAgICAgICAgIHZhbHVlID0gX3JlZlsxXTtcblxuICAgICAgaWYgKCFoYW5kbGVycy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIHZhciBfaW5zdGFuY2UkX19jb250YWluZXI7XG5cbiAgICAgICAgdmFyIHJvb3QgPSBpbnN0YW5jZTtcbiAgICAgICAgdmFyIHRhcmdldCA9IHJvb3Rba2V5XTtcblxuICAgICAgICBpZiAoa2V5LmluY2x1ZGVzKCctJykpIHtcbiAgICAgICAgICB2YXIgZW50cmllcyA9IGtleS5zcGxpdCgnLScpO1xuICAgICAgICAgIHRhcmdldCA9IGVudHJpZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGFjY1trZXldO1xuICAgICAgICAgIH0sIGluc3RhbmNlKTsgLy8gSWYgdGhlIHRhcmdldCBpcyBhdG9taWMsIGl0IGZvcmNlcyB1cyB0byBzd2l0Y2ggdGhlIHJvb3RcblxuICAgICAgICAgIGlmICghKHRhcmdldCAmJiB0YXJnZXQuc2V0KSkge1xuICAgICAgICAgICAgdmFyIF9lbnRyaWVzJHJldmVyc2UgPSBlbnRyaWVzLnJldmVyc2UoKSxcbiAgICAgICAgICAgICAgICBfbmFtZSA9IF9lbnRyaWVzJHJldmVyc2VbMF0sXG4gICAgICAgICAgICAgICAgcmV2ZXJzZUVudHJpZXMgPSBfZW50cmllcyRyZXZlcnNlLnNsaWNlKDEpO1xuXG4gICAgICAgICAgICByb290ID0gcmV2ZXJzZUVudHJpZXMucmV2ZXJzZSgpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFjY1trZXldO1xuICAgICAgICAgICAgfSwgaW5zdGFuY2UpO1xuICAgICAgICAgICAga2V5ID0gX25hbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFNwZWNpYWwgdHJlYXRtZW50IGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3Igc2V0L2NvcHlcblxuXG4gICAgICAgIHZhciBpc0NvbG9yTWFuYWdlbWVudCA9IChfaW5zdGFuY2UkX19jb250YWluZXIgPSBpbnN0YW5jZS5fX2NvbnRhaW5lcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbnN0YW5jZSRfX2NvbnRhaW5lci5fX3N0YXRlLmN1cnJlbnQuY29sb3JNYW5hZ2VtZW50O1xuXG4gICAgICAgIGlmICh0YXJnZXQgJiYgdGFyZ2V0LnNldCAmJiAodGFyZ2V0LmNvcHkgfHwgdGFyZ2V0IGluc3RhbmNlb2YgVEhSRUUuTGF5ZXJzKSkge1xuICAgICAgICAgIHZhciBfdGFyZ2V0O1xuXG4gICAgICAgICAgLy8gSWYgdmFsdWUgaXMgYW4gYXJyYXkgaXQgaGFzIGdvdCB0byBiZSB0aGUgc2V0IGZ1bmN0aW9uXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSAoX3RhcmdldCA9IHRhcmdldCkuc2V0LmFwcGx5KF90YXJnZXQsIHZhbHVlKTsgLy8gVGVzdCBhZ2FpbiB0YXJnZXQuY29weShjbGFzcykgbmV4dCAuLi5cbiAgICAgICAgICBlbHNlIGlmICh0YXJnZXQuY29weSAmJiB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciAmJiB0YXJnZXQuY29uc3RydWN0b3IubmFtZSA9PT0gdmFsdWUuY29uc3RydWN0b3IubmFtZSkgdGFyZ2V0LmNvcHkodmFsdWUpOyAvLyBJZiBub3RoaW5nIGVsc2UgZml0cywganVzdCBzZXQgdGhlIHNpbmdsZSB2YWx1ZSwgaWdub3JlIHVuZGVmaW5lZFxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0LXNwcmluZy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvMjc0XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnNldCh2YWx1ZSk7IC8vIEF1dG8tY29udmVydCBzUkdCIGNvbG9ycywgZm9yIG5vdyAuLi5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Qtc3ByaW5nL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy8zNDRcblxuICAgICAgICAgICAgICAgIGlmIChpc0NvbG9yTWFuYWdlbWVudCAmJiB0YXJnZXQgaW5zdGFuY2VvZiBUSFJFRS5Db2xvcikge1xuICAgICAgICAgICAgICAgICAgdGFyZ2V0LmNvbnZlcnRTUkdCVG9MaW5lYXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gLy8gRWxzZSwganVzdCBvdmVyd3JpdGUgdGhlIHZhbHVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm9vdFtrZXldID0gdmFsdWU7IC8vIEF1dG8tY29udmVydCBzUkdCIHRleHR1cmVzLCBmb3Igbm93IC4uLlxuICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdC1zcHJpbmcvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzM0NFxuXG4gICAgICAgICAgaWYgKGlzQ29sb3JNYW5hZ2VtZW50ICYmIHJvb3Rba2V5XSBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUpIHtcbiAgICAgICAgICAgIHJvb3Rba2V5XS5lbmNvZGluZyA9IFRIUkVFLnNSR0JFbmNvZGluZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpbnZhbGlkYXRlSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH0pOyAvLyBQcmVlbXB0aXZlbHkgZGVsZXRlIHRoZSBpbnN0YW5jZSBmcm9tIHRoZSBjb250YWluZXJzIGludGVyYWN0aW9uXG5cbiAgICBpZiAoYWNjdW11bGF0aXZlICYmIGNvbnRhaW5lciAmJiBpbnN0YW5jZS5yYXljYXN0ICYmIGluc3RhbmNlLl9faGFuZGxlcnMpIHtcbiAgICAgIGluc3RhbmNlLl9faGFuZGxlcnMgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHZhciBpbmRleCA9IGNvbnRhaW5lci5fX2ludGVyYWN0aW9uLmluZGV4T2YoaW5zdGFuY2UpO1xuXG4gICAgICBpZiAoaW5kZXggPiAtMSkgY29udGFpbmVyLl9faW50ZXJhY3Rpb24uc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9IC8vIFByZXAgaW50ZXJhY3Rpb24gaGFuZGxlcnNcblxuXG4gICAgaWYgKGhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgLy8gQWRkIGludGVyYWN0aXZlIG9iamVjdCB0byBjZW50cmFsIGNvbnRhaW5lclxuICAgICAgaWYgKGNvbnRhaW5lciAmJiBpbnN0YW5jZS5yYXljYXN0KSBjb250YWluZXIuX19pbnRlcmFjdGlvbi5wdXNoKGluc3RhbmNlKTsgLy8gQWRkIGhhbmRsZXJzIHRvIHRoZSBpbnN0YW5jZXMgaGFuZGxlci1tYXBcblxuICAgICAgaW5zdGFuY2UuX19oYW5kbGVycyA9IGhhbmRsZXJzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICAgICAgdmFyIF9leHRlbmRzMjtcblxuICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGFjYywgKF9leHRlbmRzMiA9IHt9LCBfZXh0ZW5kczJba2V5LmNoYXJBdCgyKS50b0xvd2VyQ2FzZSgpICsga2V5LnN1YnN0cigzKV0gPSBuZXdQcm9wc1trZXldLCBfZXh0ZW5kczIpKTtcbiAgICAgIH0sIHt9KTtcbiAgICB9IC8vIENhbGwgdGhlIHVwZGF0ZSBsaWZlY3ljbGUgd2hlbiBpdCBpcyBiZWluZyB1cGRhdGVkLCBidXQgb25seSB3aGVuIGl0IGlzIHBhcnQgb2YgdGhlIHNjZW5lXG5cblxuICAgIGlmIChpbnN0YW5jZS5wYXJlbnQpIHVwZGF0ZUluc3RhbmNlKGluc3RhbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZhbGlkYXRlSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgaWYgKGluc3RhbmNlLl9fY29udGFpbmVyICYmIGluc3RhbmNlLl9fY29udGFpbmVyLl9fc3RhdGUpIGludmFsaWRhdGUoaW5zdGFuY2UuX19jb250YWluZXIuX19zdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUluc3RhbmNlKGluc3RhbmNlKSB7XG4gIGlmIChpbnN0YW5jZS5vblVwZGF0ZSkgaW5zdGFuY2Uub25VcGRhdGUoaW5zdGFuY2UpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZSh0eXBlLCBfcmVmMiwgY29udGFpbmVyLCBob3N0Q29udGV4dCwgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICB2YXIgX3JlZjIkYXJncyA9IF9yZWYyLmFyZ3MsXG4gICAgICBhcmdzID0gX3JlZjIkYXJncyA9PT0gdm9pZCAwID8gW10gOiBfcmVmMiRhcmdzLFxuICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmMiwgW1wiYXJnc1wiXSk7XG5cbiAgdmFyIG5hbWUgPSBcIlwiICsgdHlwZVswXS50b1VwcGVyQ2FzZSgpICsgdHlwZS5zbGljZSgxKTtcbiAgdmFyIGluc3RhbmNlO1xuXG4gIGlmICh0eXBlID09PSAncHJpbWl0aXZlJykge1xuICAgIC8vIFN3aXRjaCBvZmYgZGlzcG9zZSBmb3IgcHJpbWl0aXZlIG9iamVjdHNcbiAgICBwcm9wcyA9IF9leHRlbmRzKHtcbiAgICAgIGRpc3Bvc2U6IG51bGxcbiAgICB9LCBwcm9wcyk7XG4gICAgaW5zdGFuY2UgPSBwcm9wcy5vYmplY3Q7XG4gICAgaW5zdGFuY2UuX19pbnN0YW5jZSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ25ldycpIHtcbiAgICBpbnN0YW5jZSA9IG5ldyBwcm9wcy5vYmplY3QoYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhcmdldCA9IGNhdGFsb2d1ZVtuYW1lXSB8fCBUSFJFRVtuYW1lXTtcblxuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICB0aHJvdyBcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCIgaXMgbm90IHBhcnQgb2YgdGhlIFRIUkVFIG5hbWVzcGFjZSEgRGlkIHlvdSBmb3JnZXQgdG8gZXh0ZW5kIGl0PyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdC1zcHJpbmcvcmVhY3QtdGhyZWUtZmliZXIvYmxvYi9tYXN0ZXIvYXBpLm1kI3B1dHRpbmctYWxyZWFkeS1leGlzdGluZy1vYmplY3RzLWludG8tdGhlLXNjZW5lLWdyYXBoXCI7XG4gICAgfVxuXG4gICAgaW5zdGFuY2UgPSBpcy5hcnIoYXJncykgPyBfY29uc3RydWN0KHRhcmdldCwgYXJncykgOiBuZXcgdGFyZ2V0KGFyZ3MpO1xuICB9IC8vIEJpbmQgdG8gdGhlIHJvb3QgY29udGFpbmVyIGluIGNhc2UgcG9ydGFscyBhcmUgYmVpbmcgdXNlZFxuICAvLyBUaGlzIGlzIHBlcmhhcHMgYmV0dGVyIGZvciBldmVudCBtYW5hZ2VtZW50IGFzIHdlIGNhbiBrZWVwIHRoZW0gb24gYSBzaW5nbGUgaW5zdGFuY2VcblxuXG4gIHdoaWxlIChjb250YWluZXIuX19jb250YWluZXIpIHtcbiAgICBjb250YWluZXIgPSBjb250YWluZXIuX19jb250YWluZXI7XG4gIH0gLy8gVE9ETzogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNzE0N1xuICAvLyBJZiBpdCdzIHN0aWxsIG5vdCB0aGVyZSBpdCBtZWFucyB0aGUgcG9ydGFsIHdhcyBjcmVhdGVkIG9uIGEgdmlydHVhbCBub2RlIG91dHNpZGUgb2YgcmVhY3RcblxuXG4gIGlmICghcm9vdHMuaGFzKGNvbnRhaW5lcikpIHtcbiAgICB2YXIgZm4gPSBmdW5jdGlvbiBmbihub2RlKSB7XG4gICAgICBpZiAoIW5vZGVbXCJyZXR1cm5cIl0pIHJldHVybiBub2RlLnN0YXRlTm9kZSAmJiBub2RlLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2Vsc2UgcmV0dXJuIGZuKG5vZGVbXCJyZXR1cm5cIl0pO1xuICAgIH07XG5cbiAgICBjb250YWluZXIgPSBmbihpbnRlcm5hbEluc3RhbmNlSGFuZGxlKTtcbiAgfSAvLyBBcHBseSBpbml0aWFsIHByb3BzXG5cblxuICBpbnN0YW5jZS5fX29iamVjdHMgPSBbXTtcbiAgaW5zdGFuY2UuX19jb250YWluZXIgPSBjb250YWluZXI7IC8vIEF1dG8tYXR0YWNoIGdlb21ldHJpZXMgYW5kIG1hdGVyaWFsc1xuXG4gIGlmIChuYW1lLmVuZHNXaXRoKCdHZW9tZXRyeScpKSB7XG4gICAgcHJvcHMgPSBfZXh0ZW5kcyh7XG4gICAgICBhdHRhY2g6ICdnZW9tZXRyeSdcbiAgICB9LCBwcm9wcyk7XG4gIH0gZWxzZSBpZiAobmFtZS5lbmRzV2l0aCgnTWF0ZXJpYWwnKSkge1xuICAgIHByb3BzID0gX2V4dGVuZHMoe1xuICAgICAgYXR0YWNoOiAnbWF0ZXJpYWwnXG4gICAgfSwgcHJvcHMpO1xuICB9IC8vIEl0IHNob3VsZCBOT1QgY2FsbCBvblVwZGF0ZSBvbiBvYmplY3QgaW5zdGFuY2lhdGlvbiwgYmVjYXVzZSBpdCBoYXNuJ3QgYmVlbiBhZGRlZCB0byB0aGVcbiAgLy8gdmlldyB5ZXQuIElmIHRoZSBjYWxsYmFjayByZWxpZXMgb24gcmVmZXJlbmNlcyBmb3IgaW5zdGFuY2UsIHRoZXkgd29uJ3QgYmUgcmVhZHkgeWV0LCB0aGlzIGlzXG4gIC8vIHdoeSBpdCBwYXNzZXMgXCJmYWxzZVwiIGhlcmVcblxuXG4gIGFwcGx5UHJvcHMoaW5zdGFuY2UsIHByb3BzLCB7fSk7XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gIGlmIChjaGlsZCkge1xuICAgIGlmIChjaGlsZC5pc09iamVjdDNEKSBwYXJlbnRJbnN0YW5jZS5hZGQoY2hpbGQpO2Vsc2Uge1xuICAgICAgcGFyZW50SW5zdGFuY2UuX19vYmplY3RzLnB1c2goY2hpbGQpO1xuXG4gICAgICBjaGlsZC5wYXJlbnQgPSBwYXJlbnRJbnN0YW5jZTsgLy8gVGhlIGF0dGFjaCBhdHRyaWJ1dGUgaW1wbGllcyB0aGF0IHRoZSBvYmplY3QgYXR0YWNoZXMgaXRzZWxmIG9uIHRoZSBwYXJlbnRcblxuICAgICAgaWYgKGNoaWxkLmF0dGFjaEFycmF5KSB7XG4gICAgICAgIGlmICghaXMuYXJyKHBhcmVudEluc3RhbmNlW2NoaWxkLmF0dGFjaEFycmF5XSkpIHBhcmVudEluc3RhbmNlW2NoaWxkLmF0dGFjaEFycmF5XSA9IFtdO1xuICAgICAgICBwYXJlbnRJbnN0YW5jZVtjaGlsZC5hdHRhY2hBcnJheV0ucHVzaChjaGlsZCk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkLmF0dGFjaE9iamVjdCkge1xuICAgICAgICBpZiAoIWlzLm9iaihwYXJlbnRJbnN0YW5jZVtjaGlsZC5hdHRhY2hPYmplY3RbMF1dKSkgcGFyZW50SW5zdGFuY2VbY2hpbGQuYXR0YWNoT2JqZWN0WzBdXSA9IHt9O1xuICAgICAgICBwYXJlbnRJbnN0YW5jZVtjaGlsZC5hdHRhY2hPYmplY3RbMF1dW2NoaWxkLmF0dGFjaE9iamVjdFsxXV0gPSBjaGlsZDtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGQuYXR0YWNoKSBwYXJlbnRJbnN0YW5jZVtjaGlsZC5hdHRhY2hdID0gY2hpbGQ7XG4gICAgfVxuICAgIHVwZGF0ZUluc3RhbmNlKGNoaWxkKTtcbiAgICBpbnZhbGlkYXRlSW5zdGFuY2UoY2hpbGQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluc2VydEJlZm9yZShwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGJlZm9yZUNoaWxkKSB7XG4gIGlmIChjaGlsZCkge1xuICAgIGlmIChjaGlsZC5pc09iamVjdDNEKSB7XG4gICAgICBjaGlsZC5wYXJlbnQgPSBwYXJlbnRJbnN0YW5jZTtcbiAgICAgIGNoaWxkLmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICB0eXBlOiAnYWRkZWQnXG4gICAgICB9KTtcbiAgICAgIHZhciByZXN0U2libGluZ3MgPSBwYXJlbnRJbnN0YW5jZS5jaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKHNpYmxpbmcpIHtcbiAgICAgICAgcmV0dXJuIHNpYmxpbmcgIT09IGNoaWxkO1xuICAgICAgfSk7IC8vIFRPRE86IHRoZSBvcmRlciBpcyBvdXQgb2Ygd2hhY2sgaWYgZGF0YSBvYmplY3RzIGFyZSBwcmVzZW50LCBoYXMgdG8gYmUgcmVjYWxjdWxhdGVkXG5cbiAgICAgIHZhciBpbmRleCA9IHJlc3RTaWJsaW5ncy5pbmRleE9mKGJlZm9yZUNoaWxkKTtcbiAgICAgIHBhcmVudEluc3RhbmNlLmNoaWxkcmVuID0gW10uY29uY2F0KHJlc3RTaWJsaW5ncy5zbGljZSgwLCBpbmRleCksIFtjaGlsZF0sIHJlc3RTaWJsaW5ncy5zbGljZShpbmRleCkpO1xuICAgICAgdXBkYXRlSW5zdGFuY2UoY2hpbGQpO1xuICAgIH0gZWxzZSBhcHBlbmRDaGlsZChwYXJlbnRJbnN0YW5jZSwgY2hpbGQpOyAvLyBUT0RPOiBvcmRlciEhIVxuXG5cbiAgICBpbnZhbGlkYXRlSW5zdGFuY2UoY2hpbGQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVJlY3Vyc2l2ZShhcnJheSwgcGFyZW50LCBjbG9uZSkge1xuICBpZiAoY2xvbmUgPT09IHZvaWQgMCkge1xuICAgIGNsb25lID0gZmFsc2U7XG4gIH1cblxuICBpZiAoYXJyYXkpIHtcbiAgICAvLyBUaHJlZSB1c2VzIHNwbGljZSBvcCdzIGludGVybmFsbHkgd2UgbWF5IGhhdmUgdG8gc2hhbGxvdy1jbG9uZSB0aGUgYXJyYXkgaW4gb3JkZXIgdG8gc2FmZWx5IHJlbW92ZSBpdGVtc1xuICAgIHZhciB0YXJnZXQgPSBjbG9uZSA/IFtdLmNvbmNhdChhcnJheSkgOiBhcnJheTtcbiAgICB0YXJnZXQuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHJldHVybiByZW1vdmVDaGlsZChwYXJlbnQsIGNoaWxkKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZChwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgaWYgKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkLmlzT2JqZWN0M0QpIHtcbiAgICAgIHBhcmVudEluc3RhbmNlLnJlbW92ZShjaGlsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG4gICAgICBpZiAocGFyZW50SW5zdGFuY2UuX19vYmplY3RzKSBwYXJlbnRJbnN0YW5jZS5fX29iamVjdHMgPSBwYXJlbnRJbnN0YW5jZS5fX29iamVjdHMuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4ICE9PSBjaGlsZDtcbiAgICAgIH0pOyAvLyBSZW1vdmUgYXR0YWNobWVudFxuXG4gICAgICBpZiAoY2hpbGQuYXR0YWNoQXJyYXkpIHBhcmVudEluc3RhbmNlW2NoaWxkLmF0dGFjaEFycmF5XSA9IHBhcmVudEluc3RhbmNlW2NoaWxkLmF0dGFjaEFycmF5XS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHggIT09IGNoaWxkO1xuICAgICAgfSk7ZWxzZSBpZiAoY2hpbGQuYXR0YWNoT2JqZWN0KSBkZWxldGUgcGFyZW50SW5zdGFuY2VbY2hpbGQuYXR0YWNoT2JqZWN0WzBdXVtjaGlsZC5hdHRhY2hPYmplY3RbMV1dO2Vsc2UgaWYgKGNoaWxkLmF0dGFjaCkgcGFyZW50SW5zdGFuY2VbY2hpbGQuYXR0YWNoXSA9IG51bGw7XG4gICAgfVxuXG4gICAgaW52YWxpZGF0ZUluc3RhbmNlKGNoaWxkKTsgLy8gQWxsb3cgb2JqZWN0cyB0byBiYWlsIG91dCBvZiByZWN1cnNpdmUgZGlzcG9zZSBhbGx0b2dldGhlciBieSBwYXNzaW5nIGRpc3Bvc2U9e251bGx9XG5cbiAgICBpZiAoY2hpbGQuZGlzcG9zZSAhPT0gbnVsbCkge1xuICAgICAgc2NoZWR1bGVyLnVuc3RhYmxlX3J1bldpdGhQcmlvcml0eShzY2hlZHVsZXIudW5zdGFibGVfSWRsZVByaW9yaXR5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFJlbW92ZSBpbnRlcmFjdGl2aXR5XG4gICAgICAgIGlmIChjaGlsZC5fX2NvbnRhaW5lcikgY2hpbGQuX19jb250YWluZXIuX19pbnRlcmFjdGlvbiA9IGNoaWxkLl9fY29udGFpbmVyLl9faW50ZXJhY3Rpb24uZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgcmV0dXJuIHggIT09IGNoaWxkO1xuICAgICAgICB9KTsgLy8gUmVtb3ZlIG5lc3RlZCBjaGlsZCBvYmplY3RzXG5cbiAgICAgICAgcmVtb3ZlUmVjdXJzaXZlKGNoaWxkLl9fb2JqZWN0cywgY2hpbGQpO1xuICAgICAgICByZW1vdmVSZWN1cnNpdmUoY2hpbGQuY2hpbGRyZW4sIGNoaWxkLCB0cnVlKTsgLy8gRGlzcG9zZSBpdGVtXG5cbiAgICAgICAgaWYgKGNoaWxkLmRpc3Bvc2UpIGNoaWxkLmRpc3Bvc2UoKTsgLy8gUmVtb3ZlIHJlZmVyZW5jZXNcblxuICAgICAgICBkZWxldGUgY2hpbGQuX19jb250YWluZXI7XG4gICAgICAgIGRlbGV0ZSBjaGlsZC5fX29iamVjdHM7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3dpdGNoSW5zdGFuY2UoaW5zdGFuY2UsIHR5cGUsIG5ld1Byb3BzLCBmaWJlcikge1xuICB2YXIgcGFyZW50ID0gaW5zdGFuY2UucGFyZW50O1xuICB2YXIgbmV3SW5zdGFuY2UgPSBjcmVhdGVJbnN0YW5jZSh0eXBlLCBuZXdQcm9wcywgaW5zdGFuY2UuX19jb250YWluZXIsIG51bGwsIGZpYmVyKTtcbiAgcmVtb3ZlQ2hpbGQocGFyZW50LCBpbnN0YW5jZSk7XG4gIGFwcGVuZENoaWxkKHBhcmVudCwgbmV3SW5zdGFuY2UpIC8vIFRoaXMgZXZpbCBoYWNrIHN3aXRjaGVzIHRoZSByZWFjdC1pbnRlcm5hbCBmaWJlciBub2RlXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTQ5ODNcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTUwMjFcbiAgO1xuICBbZmliZXIsIGZpYmVyLmFsdGVybmF0ZV0uZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICBpZiAoZmliZXIgIT09IG51bGwpIHtcbiAgICAgIGZpYmVyLnN0YXRlTm9kZSA9IG5ld0luc3RhbmNlO1xuXG4gICAgICBpZiAoZmliZXIucmVmKSB7XG4gICAgICAgIGlmIChpcy5mdW4oZmliZXIucmVmKSkgZmliZXIucmVmKG5ld0luc3RhbmNlKTtlbHNlIGZpYmVyLnJlZi5jdXJyZW50ID0gbmV3SW5zdGFuY2U7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxudmFyIFJlbmRlcmVyID0gUmVjb25jaWxlcih7XG4gIG5vdzogc2NoZWR1bGVyLnVuc3RhYmxlX25vdyxcbiAgY3JlYXRlSW5zdGFuY2U6IGNyZWF0ZUluc3RhbmNlLFxuICByZW1vdmVDaGlsZDogcmVtb3ZlQ2hpbGQsXG4gIGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcbiAgaW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG4gIC8vIEB0cy1pZ25vcmVcbiAgd2FybnNJZk5vdEFjdGluZzogdHJ1ZSxcbiAgc3VwcG9ydHNNdXRhdGlvbjogdHJ1ZSxcbiAgaXNQcmltYXJ5UmVuZGVyZXI6IGZhbHNlLFxuICBzY2hlZHVsZVRpbWVvdXQ6IGlzLmZ1bihzZXRUaW1lb3V0KSA/IHNldFRpbWVvdXQgOiB1bmRlZmluZWQsXG4gIGNhbmNlbFRpbWVvdXQ6IGlzLmZ1bihjbGVhclRpbWVvdXQpID8gY2xlYXJUaW1lb3V0IDogdW5kZWZpbmVkLFxuICAvLyBAdHMtaWdub3JlXG4gIHNldFRpbWVvdXQ6IGlzLmZ1bihzZXRUaW1lb3V0KSA/IHNldFRpbWVvdXQgOiB1bmRlZmluZWQsXG4gIC8vIEB0cy1pZ25vcmVcbiAgY2xlYXJUaW1lb3V0OiBpcy5mdW4oY2xlYXJUaW1lb3V0KSA/IGNsZWFyVGltZW91dCA6IHVuZGVmaW5lZCxcbiAgbm9UaW1lb3V0OiAtMSxcbiAgYXBwZW5kSW5pdGlhbENoaWxkOiBhcHBlbmRDaGlsZCxcbiAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcjogYXBwZW5kQ2hpbGQsXG4gIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcjogcmVtb3ZlQ2hpbGQsXG4gIGluc2VydEluQ29udGFpbmVyQmVmb3JlOiBpbnNlcnRCZWZvcmUsXG4gIGNvbW1pdFVwZGF0ZTogZnVuY3Rpb24gY29tbWl0VXBkYXRlKGluc3RhbmNlLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIGZpYmVyKSB7XG4gICAgaWYgKGluc3RhbmNlLl9faW5zdGFuY2UgJiYgbmV3UHJvcHMub2JqZWN0ICYmIG5ld1Byb3BzLm9iamVjdCAhPT0gaW5zdGFuY2UpIHtcbiAgICAgIC8vIDxpbnN0YW5jZSBvYmplY3Q9ey4uLn0gLz4gd2hlcmUgdGhlIG9iamVjdCByZWZlcmVuY2UgaGFzIGNoYW5nZWRcbiAgICAgIHN3aXRjaEluc3RhbmNlKGluc3RhbmNlLCB0eXBlLCBuZXdQcm9wcywgZmliZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGlzIGEgZGF0YSBvYmplY3QsIGxldCdzIGV4dHJhY3QgY3JpdGljYWwgaW5mb3JtYXRpb24gYWJvdXQgaXRcbiAgICAgIHZhciBfbmV3UHJvcHMkYXJncyA9IG5ld1Byb3BzLmFyZ3MsXG4gICAgICAgICAgYXJnc05ldyA9IF9uZXdQcm9wcyRhcmdzID09PSB2b2lkIDAgPyBbXSA6IF9uZXdQcm9wcyRhcmdzLFxuICAgICAgICAgIHJlc3ROZXcgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShuZXdQcm9wcywgW1wiYXJnc1wiXSk7XG5cbiAgICAgIHZhciBfb2xkUHJvcHMkYXJncyA9IG9sZFByb3BzLmFyZ3MsXG4gICAgICAgICAgYXJnc09sZCA9IF9vbGRQcm9wcyRhcmdzID09PSB2b2lkIDAgPyBbXSA6IF9vbGRQcm9wcyRhcmdzLFxuICAgICAgICAgIHJlc3RPbGQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShvbGRQcm9wcywgW1wiYXJnc1wiXSk7IC8vIElmIGl0IGhhcyBuZXcgcHJvcHMgb3IgYXJndW1lbnRzLCB0aGVuIGl0IG5lZWRzIHRvIGJlIHJlLWluc3RhbmNpYXRlZFxuXG5cbiAgICAgIHZhciBoYXNOZXdBcmdzID0gYXJnc05ldy5zb21lKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGlzLm9iaih2YWx1ZSkgPyBPYmplY3QuZW50cmllcyh2YWx1ZSkuc29tZShmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgICAgICB2YXIga2V5ID0gX3JlZjNbMF0sXG4gICAgICAgICAgICAgIHZhbCA9IF9yZWYzWzFdO1xuICAgICAgICAgIHJldHVybiB2YWwgIT09IGFyZ3NPbGRbaW5kZXhdW2tleV07XG4gICAgICAgIH0pIDogdmFsdWUgIT09IGFyZ3NPbGRbaW5kZXhdO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChoYXNOZXdBcmdzKSB7XG4gICAgICAgIC8vIE5leHQgd2UgY3JlYXRlIGEgbmV3IGluc3RhbmNlIGFuZCBhcHBlbmQgaXQgYWdhaW5cbiAgICAgICAgc3dpdGNoSW5zdGFuY2UoaW5zdGFuY2UsIHR5cGUsIG5ld1Byb3BzLCBmaWJlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2UganVzdCBvdmVyd3JpdGUgcHJvcHNcbiAgICAgICAgYXBwbHlQcm9wcyhpbnN0YW5jZSwgcmVzdE5ldywgcmVzdE9sZCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBoaWRlSW5zdGFuY2U6IGZ1bmN0aW9uIGhpZGVJbnN0YW5jZShpbnN0YW5jZSkge1xuICAgIGlmIChpbnN0YW5jZS5pc09iamVjdDNEKSB7XG4gICAgICBpbnN0YW5jZS52aXNpYmxlID0gZmFsc2U7XG4gICAgICBpbnZhbGlkYXRlSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgIH1cbiAgfSxcbiAgdW5oaWRlSW5zdGFuY2U6IGZ1bmN0aW9uIHVuaGlkZUluc3RhbmNlKGluc3RhbmNlLCBwcm9wcykge1xuICAgIGlmIChpbnN0YW5jZS5pc09iamVjdDNEICYmIHByb3BzLnZpc2libGUgPT0gbnVsbCB8fCBwcm9wcy52aXNpYmxlKSB7XG4gICAgICBpbnN0YW5jZS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgIGludmFsaWRhdGVJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgfVxuICB9LFxuICBoaWRlVGV4dEluc3RhbmNlOiBmdW5jdGlvbiBoaWRlVGV4dEluc3RhbmNlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGV4dCBpcyBub3QgYWxsb3dlZCBpbiB0aGUgcmVhY3QtdGhyZWUtZmlicmUgdHJlZS4gWW91IG1heSBoYXZlIGV4dHJhbmVvdXMgd2hpdGVzcGFjZSBiZXR3ZWVuIGNvbXBvbmVudHMuJyk7XG4gIH0sXG4gIGdldFB1YmxpY0luc3RhbmNlOiBmdW5jdGlvbiBnZXRQdWJsaWNJbnN0YW5jZShpbnN0YW5jZSkge1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSxcbiAgZ2V0Um9vdEhvc3RDb250ZXh0OiBmdW5jdGlvbiBnZXRSb290SG9zdENvbnRleHQoKSB7XG4gICAgcmV0dXJuIGVtcHR5T2JqZWN0O1xuICB9LFxuICBnZXRDaGlsZEhvc3RDb250ZXh0OiBmdW5jdGlvbiBnZXRDaGlsZEhvc3RDb250ZXh0KCkge1xuICAgIHJldHVybiBlbXB0eU9iamVjdDtcbiAgfSxcbiAgY3JlYXRlVGV4dEluc3RhbmNlOiBmdW5jdGlvbiBjcmVhdGVUZXh0SW5zdGFuY2UoKSB7fSxcbiAgZmluYWxpemVJbml0aWFsQ2hpbGRyZW46IGZ1bmN0aW9uIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgcHJlcGFyZVVwZGF0ZTogZnVuY3Rpb24gcHJlcGFyZVVwZGF0ZSgpIHtcbiAgICByZXR1cm4gZW1wdHlPYmplY3Q7XG4gIH0sXG4gIHNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWU6IGZ1bmN0aW9uIHNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWUoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBwcmVwYXJlRm9yQ29tbWl0OiBmdW5jdGlvbiBwcmVwYXJlRm9yQ29tbWl0KCkge30sXG4gIHJlc2V0QWZ0ZXJDb21taXQ6IGZ1bmN0aW9uIHJlc2V0QWZ0ZXJDb21taXQoKSB7fSxcbiAgc2hvdWxkU2V0VGV4dENvbnRlbnQ6IGZ1bmN0aW9uIHNob3VsZFNldFRleHRDb250ZW50KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSk7XG52YXIgaGFzU3ltYm9sID0gaXMuZnVuKFN5bWJvbCkgJiYgU3ltYm9sW1wiZm9yXCJdO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sW1wiZm9yXCJdKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbmZ1bmN0aW9uIHJlbmRlcihlbGVtZW50LCBjb250YWluZXIsIHN0YXRlKSB7XG4gIHZhciByb290ID0gcm9vdHMuZ2V0KGNvbnRhaW5lcik7XG5cbiAgaWYgKCFyb290KSB7XG4gICAgY29udGFpbmVyLl9fc3RhdGUgPSBzdGF0ZTsgLy8gQHRzLWlnbm9yZVxuXG4gICAgdmFyIG5ld1Jvb3QgPSByb290ID0gUmVuZGVyZXIuY3JlYXRlQ29udGFpbmVyKGNvbnRhaW5lciwgc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZS5jdXJyZW50LmNvbmN1cnJlbnQgPyAyIDogMCwgZmFsc2UsIC8vIEB0cy1pZ25vcmVcbiAgICBudWxsKTtcbiAgICByb290cy5zZXQoY29udGFpbmVyLCBuZXdSb290KTtcbiAgfVxuXG4gIFJlbmRlcmVyLnVwZGF0ZUNvbnRhaW5lcihlbGVtZW50LCByb290LCBudWxsLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSk7XG4gIHJldHVybiBSZW5kZXJlci5nZXRQdWJsaWNSb290SW5zdGFuY2Uocm9vdCk7XG59XG5mdW5jdGlvbiB1bm1vdW50Q29tcG9uZW50QXROb2RlKGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgdmFyIHJvb3QgPSByb290cy5nZXQoY29udGFpbmVyKTtcbiAgaWYgKHJvb3QpIFJlbmRlcmVyLnVwZGF0ZUNvbnRhaW5lcihudWxsLCByb290LCBudWxsLCBmdW5jdGlvbiAoKSB7XG4gICAgcm9vdHNbXCJkZWxldGVcIl0oY29udGFpbmVyKTtcbiAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGNvbnRhaW5lcik7XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBjb250YWluZXJJbmZvLCBpbXBsZW1lbnRhdGlvbiwga2V5KSB7XG4gIGlmIChrZXkgPT09IHZvaWQgMCkge1xuICAgIGtleSA9IG51bGw7XG4gIH1cblxuICBpZiAoIWNvbnRhaW5lckluZm8uX19vYmplY3RzKSBjb250YWluZXJJbmZvLl9fb2JqZWN0cyA9IFtdO1xuICByZXR1cm4ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9QT1JUQUxfVFlQRSxcbiAgICBrZXk6IGtleSA9PSBudWxsID8gbnVsbCA6ICcnICsga2V5LFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBjb250YWluZXJJbmZvOiBjb250YWluZXJJbmZvLFxuICAgIGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvblxuICB9O1xufVxuUmVuZGVyZXIuaW5qZWN0SW50b0RldlRvb2xzKHtcbiAgYnVuZGxlVHlwZTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyA/IDAgOiAxLFxuICAvL0B0cy1pZ25vcmVcbiAgZmluZEhvc3RJbnN0YW5jZUJ5RmliZXI6IGZ1bmN0aW9uIGZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9LFxuICB2ZXJzaW9uOiBSZWFjdF9fZGVmYXVsdC52ZXJzaW9uLFxuICByZW5kZXJlclBhY2thZ2VOYW1lOiAncmVhY3QtdGhyZWUtZmliZXInXG59KTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQ7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTsgcmV0dXJuIGl0Lm5leHQuYmluZChpdCk7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuZnVuY3Rpb24gaXNPcnRob2dyYXBoaWNDYW1lcmEoZGVmKSB7XG4gIHJldHVybiBkZWYuaXNPcnRob2dyYXBoaWNDYW1lcmE7XG59XG5cbmZ1bmN0aW9uIG1ha2VJZChldmVudCkge1xuICByZXR1cm4gKGV2ZW50LmV2ZW50T2JqZWN0IHx8IGV2ZW50Lm9iamVjdCkudXVpZCArICcvJyArIGV2ZW50LmluZGV4O1xufVxuXG52YXIgc3RhdGVDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQoe30pO1xudmFyIHVzZUNhbnZhcyA9IGZ1bmN0aW9uIHVzZUNhbnZhcyhwcm9wcykge1xuICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIGdsID0gcHJvcHMuZ2wsXG4gICAgICBjYW1lcmEgPSBwcm9wcy5jYW1lcmEsXG4gICAgICBvcnRob2dyYXBoaWMgPSBwcm9wcy5vcnRob2dyYXBoaWMsXG4gICAgICByYXljYXN0ZXIgPSBwcm9wcy5yYXljYXN0ZXIsXG4gICAgICBzaXplID0gcHJvcHMuc2l6ZSxcbiAgICAgIHBpeGVsUmF0aW8gPSBwcm9wcy5waXhlbFJhdGlvLFxuICAgICAgX3Byb3BzJHZyID0gcHJvcHMudnIsXG4gICAgICB2ciA9IF9wcm9wcyR2ciA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkdnIsXG4gICAgICBfcHJvcHMkY29uY3VycmVudCA9IHByb3BzLmNvbmN1cnJlbnQsXG4gICAgICBjb25jdXJyZW50ID0gX3Byb3BzJGNvbmN1cnJlbnQgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGNvbmN1cnJlbnQsXG4gICAgICBfcHJvcHMkc2hhZG93TWFwID0gcHJvcHMuc2hhZG93TWFwLFxuICAgICAgc2hhZG93TWFwID0gX3Byb3BzJHNoYWRvd01hcCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkc2hhZG93TWFwLFxuICAgICAgX3Byb3BzJGNvbG9yTWFuYWdlbWVuID0gcHJvcHMuY29sb3JNYW5hZ2VtZW50LFxuICAgICAgY29sb3JNYW5hZ2VtZW50ID0gX3Byb3BzJGNvbG9yTWFuYWdlbWVuID09PSB2b2lkIDAgPyB0cnVlIDogX3Byb3BzJGNvbG9yTWFuYWdlbWVuLFxuICAgICAgX3Byb3BzJGludmFsaWRhdGVGcmFtID0gcHJvcHMuaW52YWxpZGF0ZUZyYW1lbG9vcCxcbiAgICAgIGludmFsaWRhdGVGcmFtZWxvb3AgPSBfcHJvcHMkaW52YWxpZGF0ZUZyYW0gPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGludmFsaWRhdGVGcmFtLFxuICAgICAgX3Byb3BzJHVwZGF0ZURlZmF1bHRDID0gcHJvcHMudXBkYXRlRGVmYXVsdENhbWVyYSxcbiAgICAgIHVwZGF0ZURlZmF1bHRDYW1lcmEgPSBfcHJvcHMkdXBkYXRlRGVmYXVsdEMgPT09IHZvaWQgMCA/IHRydWUgOiBfcHJvcHMkdXBkYXRlRGVmYXVsdEMsXG4gICAgICBfcHJvcHMkbm9FdmVudHMgPSBwcm9wcy5ub0V2ZW50cyxcbiAgICAgIG5vRXZlbnRzID0gX3Byb3BzJG5vRXZlbnRzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRub0V2ZW50cyxcbiAgICAgIG9uQ3JlYXRlZCA9IHByb3BzLm9uQ3JlYXRlZCxcbiAgICAgIG9uUG9pbnRlck1pc3NlZCA9IHByb3BzLm9uUG9pbnRlck1pc3NlZCxcbiAgICAgIGZvcmNlUmVzaXplID0gcHJvcHMuZm9yY2VSZXNpemU7IC8vIExvY2FsLCByZWFjdGl2ZSBzdGF0ZVxuXG4gIHZhciBfdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShmYWxzZSksXG4gICAgICByZWFkeSA9IF91c2VTdGF0ZVswXSxcbiAgICAgIHNldFJlYWR5ID0gX3VzZVN0YXRlWzFdO1xuXG4gIHZhciBfdXNlU3RhdGUyID0gUmVhY3QudXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMigpO1xuICB9KSxcbiAgICAgIG1vdXNlID0gX3VzZVN0YXRlMlswXTtcblxuICB2YXIgX3VzZVN0YXRlMyA9IFJlYWN0LnVzZVN0YXRlKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmF5ID0gbmV3IFRIUkVFLlJheWNhc3RlcigpO1xuXG4gICAgaWYgKHJheWNhc3Rlcikge1xuICAgICAgdmFyIGZpbHRlciA9IHJheWNhc3Rlci5maWx0ZXIsXG4gICAgICAgICAgcmF5Y2FzdGVyUHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShyYXljYXN0ZXIsIFtcImZpbHRlclwiXSk7XG5cbiAgICAgIGFwcGx5UHJvcHMocmF5LCByYXljYXN0ZXJQcm9wcywge30pO1xuICAgIH1cblxuICAgIHJldHVybiByYXk7XG4gIH0pLFxuICAgICAgZGVmYXVsdFJheWNhc3RlciA9IF91c2VTdGF0ZTNbMF07XG5cbiAgdmFyIF91c2VTdGF0ZTQgPSBSZWFjdC51c2VTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XG4gICAgc2NlbmUuX19pbnRlcmFjdGlvbiA9IFtdO1xuICAgIHNjZW5lLl9fb2JqZWN0cyA9IFtdO1xuICAgIHJldHVybiBzY2VuZTtcbiAgfSksXG4gICAgICBkZWZhdWx0U2NlbmUgPSBfdXNlU3RhdGU0WzBdO1xuXG4gIHZhciBfdXNlU3RhdGU1ID0gUmVhY3QudXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW0gPSBvcnRob2dyYXBoaWMgPyBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKDAsIDAsIDAsIDAsIDAuMSwgMTAwMCkgOiBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoNzUsIDAsIDAuMSwgMTAwMCk7XG4gICAgY2FtLnBvc2l0aW9uLnogPSA1O1xuICAgIGlmIChjYW1lcmEpIGFwcGx5UHJvcHMoY2FtLCBjYW1lcmEsIHt9KTsgLy8gQWx3YXlzIGxvb2sgYXQgWzAsIDAsIDBdXG5cbiAgICBjYW0ubG9va0F0KDAsIDAsIDApO1xuICAgIHJldHVybiBjYW07XG4gIH0pLFxuICAgICAgZGVmYXVsdENhbSA9IF91c2VTdGF0ZTVbMF0sXG4gICAgICBfc2V0RGVmYXVsdENhbWVyYSA9IF91c2VTdGF0ZTVbMV07XG5cbiAgdmFyIF91c2VTdGF0ZTYgPSBSZWFjdC51c2VTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBUSFJFRS5DbG9jaygpO1xuICB9KSxcbiAgICAgIGNsb2NrID0gX3VzZVN0YXRlNlswXTsgLy8gUHVibGljIHN0YXRlXG5cblxuICB2YXIgc3RhdGUgPSBSZWFjdC51c2VSZWYoe1xuICAgIHJlYWR5OiBmYWxzZSxcbiAgICBhY3RpdmU6IHRydWUsXG4gICAgbWFudWFsOiAwLFxuICAgIGNvbG9yTWFuYWdlbWVudDogY29sb3JNYW5hZ2VtZW50LFxuICAgIHZyOiB2cixcbiAgICBjb25jdXJyZW50OiBjb25jdXJyZW50LFxuICAgIG5vRXZlbnRzOiBub0V2ZW50cyxcbiAgICBpbnZhbGlkYXRlRnJhbWVsb29wOiBmYWxzZSxcbiAgICBmcmFtZXM6IDAsXG4gICAgYXNwZWN0OiAwLFxuICAgIHN1YnNjcmliZXJzOiBbXSxcbiAgICBjYW1lcmE6IGRlZmF1bHRDYW0sXG4gICAgc2NlbmU6IGRlZmF1bHRTY2VuZSxcbiAgICByYXljYXN0ZXI6IGRlZmF1bHRSYXljYXN0ZXIsXG4gICAgbW91c2U6IG1vdXNlLFxuICAgIGNsb2NrOiBjbG9jayxcbiAgICBnbDogZ2wsXG4gICAgc2l6ZTogc2l6ZSxcbiAgICB2aWV3cG9ydDogbnVsbCxcbiAgICBpbml0aWFsQ2xpY2s6IFswLCAwXSxcbiAgICBpbml0aWFsSGl0czogW10sXG4gICAgcG9pbnRlcjogbmV3IHRpbnlFbWl0dGVyLlRpbnlFbWl0dGVyKCksXG4gICAgY2FwdHVyZWQ6IHVuZGVmaW5lZCxcbiAgICBldmVudHM6IHVuZGVmaW5lZCxcbiAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIHN1YnNjcmliZShyZWYsIHByaW9yaXR5KSB7XG4gICAgICBpZiAocHJpb3JpdHkgPT09IHZvaWQgMCkge1xuICAgICAgICBwcmlvcml0eSA9IDA7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoaXMgc3Vic2NyaXB0aW9uIHdhcyBnaXZlbiBhIHByaW9yaXR5LCBpdCB0YWtlcyByZW5kZXJpbmcgaW50byBpdHMgb3duIGhhbmRzXG4gICAgICAvLyBGb3IgdGhhdCByZWFzb24gd2Ugc3dpdGNoIG9mZiBhdXRvbWF0aWMgcmVuZGVyaW5nIGFuZCBpbmNyZWFzZSB0aGUgbWFudWFsIGZsYWdcbiAgICAgIC8vIEFzIGxvbmcgYXMgdGhpcyBmbGFnIGlzIHBvc2l0aXZlICh0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSByZW5kZXIgc3Vic2NyaXB0aW9uKVxuICAgICAgLy8gLi50aGVyZSBjYW4gYmUgbm8gaW50ZXJuYWwgcmVuZGVyaW5nIGF0IGFsbFxuICAgICAgaWYgKHByaW9yaXR5KSBzdGF0ZS5jdXJyZW50Lm1hbnVhbCsrO1xuICAgICAgc3RhdGUuY3VycmVudC5zdWJzY3JpYmVycy5wdXNoKHtcbiAgICAgICAgcmVmOiByZWYsXG4gICAgICAgIHByaW9yaXR5OiBwcmlvcml0eVxuICAgICAgfSk7IC8vIFNvcnQgbGF5ZXJzIGZyb20gbG93ZXN0IHRvIGhpZ2hlc3QsIG1lYW5pbmcsIGhpZ2hlc3QgcHJpb3JpdHkgcmVuZGVycyBsYXN0IChvbiB0b3Agb2YgdGhlIG90aGVyIGZyYW1lcylcblxuICAgICAgc3RhdGUuY3VycmVudC5zdWJzY3JpYmVycyA9IHN0YXRlLmN1cnJlbnQuc3Vic2NyaWJlcnMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIERlY3JlYXNlIG1hbnVhbCBmbGFnIGlmIHRoaXMgc3Vic2NyaXB0aW9uIGhhZCBhIHByaW9yaXR5XG4gICAgICAgIGlmIChwcmlvcml0eSkgc3RhdGUuY3VycmVudC5tYW51YWwtLTtcbiAgICAgICAgc3RhdGUuY3VycmVudC5zdWJzY3JpYmVycyA9IHN0YXRlLmN1cnJlbnQuc3Vic2NyaWJlcnMuZmlsdGVyKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgcmV0dXJuIHMucmVmICE9PSByZWY7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9LFxuICAgIHNldERlZmF1bHRDYW1lcmE6IGZ1bmN0aW9uIHNldERlZmF1bHRDYW1lcmEoY2FtZXJhKSB7XG4gICAgICByZXR1cm4gX3NldERlZmF1bHRDYW1lcmEoY2FtZXJhKTtcbiAgICB9LFxuICAgIGludmFsaWRhdGU6IGZ1bmN0aW9uIGludmFsaWRhdGUkMSgpIHtcbiAgICAgIHJldHVybiBpbnZhbGlkYXRlKHN0YXRlKTtcbiAgICB9LFxuICAgIGludGVyc2VjdDogZnVuY3Rpb24gaW50ZXJzZWN0KGV2ZW50LCBwcmVwYXJlKSB7XG4gICAgICBpZiAoZXZlbnQgPT09IHZvaWQgMCkge1xuICAgICAgICBldmVudCA9IHt9O1xuICAgICAgfVxuXG4gICAgICBpZiAocHJlcGFyZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHByZXBhcmUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFuZGxlUG9pbnRlck1vdmUoZXZlbnQsIHByZXBhcmUpO1xuICAgIH0sXG4gICAgZm9yY2VSZXNpemU6IGZvcmNlUmVzaXplXG4gIH0pO1xuICB2YXIgZ2V0Q3VycmVudFZpZXdwb3J0ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGNhbWVyYSwgdGFyZ2V0KSB7XG4gICAgaWYgKGNhbWVyYSA9PT0gdm9pZCAwKSB7XG4gICAgICBjYW1lcmEgPSBzdGF0ZS5jdXJyZW50LmNhbWVyYTtcbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHtcbiAgICAgIHRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDApO1xuICAgIH1cblxuICAgIHZhciBfc3RhdGUkY3VycmVudCRzaXplID0gc3RhdGUuY3VycmVudC5zaXplLFxuICAgICAgICB3aWR0aCA9IF9zdGF0ZSRjdXJyZW50JHNpemUud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF9zdGF0ZSRjdXJyZW50JHNpemUuaGVpZ2h0O1xuICAgIHZhciBkaXN0YW5jZSA9IGNhbWVyYS5wb3NpdGlvbi5kaXN0YW5jZVRvKHRhcmdldCk7XG5cbiAgICBpZiAoaXNPcnRob2dyYXBoaWNDYW1lcmEoY2FtZXJhKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHdpZHRoIC8gY2FtZXJhLnpvb20sXG4gICAgICAgIGhlaWdodDogaGVpZ2h0IC8gY2FtZXJhLnpvb20sXG4gICAgICAgIGZhY3RvcjogMSxcbiAgICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZm92ID0gY2FtZXJhLmZvdiAqIE1hdGguUEkgLyAxODA7IC8vIGNvbnZlcnQgdmVydGljYWwgZm92IHRvIHJhZGlhbnNcblxuICAgICAgdmFyIGggPSAyICogTWF0aC50YW4oZm92IC8gMikgKiBkaXN0YW5jZTsgLy8gdmlzaWJsZSBoZWlnaHRcblxuICAgICAgdmFyIHcgPSBoICogKHdpZHRoIC8gaGVpZ2h0KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiB3LFxuICAgICAgICBoZWlnaHQ6IGgsXG4gICAgICAgIGZhY3Rvcjogd2lkdGggLyB3LFxuICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2VcbiAgICAgIH07XG4gICAgfVxuICB9LCBbXSk7IC8vIFdyaXRlcyBsb2NhbHMgaW50byBwdWJsaWMgc3RhdGUgZm9yIGRpc3RyaWJ1dGlvbiBhbW9uZyBzdWJzY3JpYmVycywgY29udGV4dCwgZXRjXG5cbiAgUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgc3RhdGUuY3VycmVudC5yZWFkeSA9IHJlYWR5O1xuICAgIHN0YXRlLmN1cnJlbnQuc2l6ZSA9IHNpemU7XG4gICAgc3RhdGUuY3VycmVudC5jYW1lcmEgPSBkZWZhdWx0Q2FtO1xuICAgIHN0YXRlLmN1cnJlbnQuaW52YWxpZGF0ZUZyYW1lbG9vcCA9IGludmFsaWRhdGVGcmFtZWxvb3A7XG4gICAgc3RhdGUuY3VycmVudC52ciA9IHZyO1xuICAgIHN0YXRlLmN1cnJlbnQuZ2wgPSBnbDtcbiAgICBzdGF0ZS5jdXJyZW50LmNvbmN1cnJlbnQgPSBjb25jdXJyZW50O1xuICAgIHN0YXRlLmN1cnJlbnQubm9FdmVudHMgPSBub0V2ZW50czsgLy8gTWFrZSB2aWV3cG9ydCBiYWNrd2FyZHMgY29tcGF0aWJsZVxuXG4gICAgc3RhdGUuY3VycmVudC52aWV3cG9ydCA9IGdldEN1cnJlbnRWaWV3cG9ydDtcbiAgfSwgW2ludmFsaWRhdGVGcmFtZWxvb3AsIHZyLCBjb25jdXJyZW50LCBub0V2ZW50cywgcmVhZHksIHNpemUsIGRlZmF1bHRDYW0sIGdsXSk7IC8vIEFkanVzdHMgZGVmYXVsdCBjYW1lcmFcblxuICBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICBzdGF0ZS5jdXJyZW50LmFzcGVjdCA9IHNpemUud2lkdGggLyBzaXplLmhlaWdodDsgLy8gQXNzaWduIHZpZXdwb3J0IHByb3BzIHRvIHRoZSBmdW5jdGlvblxuXG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZS5jdXJyZW50LnZpZXdwb3J0LCBnZXRDdXJyZW50Vmlld3BvcnQoKSk7IC8vICM5MiAoaHR0cHM6Ly9naXRodWIuY29tL2RyY21kYS9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvOTIpXG4gICAgLy8gU29tZXRpbWVzIGF1dG9tYXRpYyBkZWZhdWx0IGNhbWVyYSBhZGp1c3RtZW50IGlzbid0IHdhbnRlZCBiZWhhdmlvdXJcblxuICAgIGlmICh1cGRhdGVEZWZhdWx0Q2FtZXJhKSB7XG4gICAgICBpZiAoaXNPcnRob2dyYXBoaWNDYW1lcmEoZGVmYXVsdENhbSkpIHtcbiAgICAgICAgZGVmYXVsdENhbS5sZWZ0ID0gc2l6ZS53aWR0aCAvIC0yO1xuICAgICAgICBkZWZhdWx0Q2FtLnJpZ2h0ID0gc2l6ZS53aWR0aCAvIDI7XG4gICAgICAgIGRlZmF1bHRDYW0udG9wID0gc2l6ZS5oZWlnaHQgLyAyO1xuICAgICAgICBkZWZhdWx0Q2FtLmJvdHRvbSA9IHNpemUuaGVpZ2h0IC8gLTI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZhdWx0Q2FtLmFzcGVjdCA9IHN0YXRlLmN1cnJlbnQuYXNwZWN0O1xuICAgICAgfVxuXG4gICAgICBkZWZhdWx0Q2FtLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTsgLy8gIzE3ODogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0LXNwcmluZy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvMTc4XG4gICAgICAvLyBVcGRhdGUgbWF0cml4IHdvcmxkIHNpbmNlIHRoZSByZW5kZXJlciBpcyBhIGZyYW1lIGxhdGVcblxuICAgICAgZGVmYXVsdENhbS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuICAgIH1cblxuICAgIGdsLnNldFNpemUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuICAgIGlmIChyZWFkeSkgaW52YWxpZGF0ZShzdGF0ZSk7XG4gIH0sIFtkZWZhdWx0Q2FtLCBzaXplLCB1cGRhdGVEZWZhdWx0Q2FtZXJhXSk7XG4gIC8qKiBFdmVudHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgLyoqIFNldHMgdXAgZGVmYXVsdFJheWNhc3RlciAqL1xuXG4gIHZhciBwcmVwYXJlUmF5ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgY2xpZW50WCA9IF9yZWYuY2xpZW50WCxcbiAgICAgICAgY2xpZW50WSA9IF9yZWYuY2xpZW50WTtcblxuICAgIGlmIChjbGllbnRYICE9PSB2b2lkIDApIHtcbiAgICAgIHZhciBfc3RhdGUkY3VycmVudCRzaXplMiA9IHN0YXRlLmN1cnJlbnQuc2l6ZSxcbiAgICAgICAgICBsZWZ0ID0gX3N0YXRlJGN1cnJlbnQkc2l6ZTIubGVmdCxcbiAgICAgICAgICByaWdodCA9IF9zdGF0ZSRjdXJyZW50JHNpemUyLnJpZ2h0LFxuICAgICAgICAgIHRvcCA9IF9zdGF0ZSRjdXJyZW50JHNpemUyLnRvcCxcbiAgICAgICAgICBib3R0b20gPSBfc3RhdGUkY3VycmVudCRzaXplMi5ib3R0b207XG4gICAgICBtb3VzZS5zZXQoKGNsaWVudFggLSBsZWZ0KSAvIChyaWdodCAtIGxlZnQpICogMiAtIDEsIC0oKGNsaWVudFkgLSB0b3ApIC8gKGJvdHRvbSAtIHRvcCkpICogMiArIDEpO1xuICAgICAgZGVmYXVsdFJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKG1vdXNlLCBzdGF0ZS5jdXJyZW50LmNhbWVyYSk7XG4gICAgfVxuICB9LCBbXSk7XG4gIC8qKiBJbnRlcnNlY3RzIGludGVyYWN0aW9uIG9iamVjdHMgdXNpbmcgdGhlIGV2ZW50IGlucHV0ICovXG5cbiAgdmFyIGludGVyc2VjdCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChldmVudCwgZmlsdGVyKSB7XG4gICAgLy8gU2tpcCBldmVudCBoYW5kbGluZyB3aGVuIG5vRXZlbnRzIGlzIHNldFxuICAgIGlmIChzdGF0ZS5jdXJyZW50Lm5vRXZlbnRzKSByZXR1cm4gW107XG4gICAgdmFyIHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgdmFyIGhpdHMgPSBbXTsgLy8gQWxsb3cgY2FsbGVycyB0byBlbGltaW5hdGUgZXZlbnQgb2JqZWN0c1xuXG4gICAgdmFyIGV2ZW50c09iamVjdHMgPSBmaWx0ZXIgPyBmaWx0ZXIoc3RhdGUuY3VycmVudC5zY2VuZS5fX2ludGVyYWN0aW9uKSA6IHN0YXRlLmN1cnJlbnQuc2NlbmUuX19pbnRlcmFjdGlvbjsgLy8gSW50ZXJzZWN0IGtub3duIGhhbmRsZXIgb2JqZWN0cyBhbmQgZmlsdGVyIGFnYWluc3QgZHVwbGljYXRlc1xuXG4gICAgdmFyIGludGVyc2VjdHMgPSBkZWZhdWx0UmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdHMoZXZlbnRzT2JqZWN0cywgdHJ1ZSkuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgaWQgPSBtYWtlSWQoaXRlbSk7XG4gICAgICBpZiAoc2Vlbi5oYXMoaWQpKSByZXR1cm4gZmFsc2U7XG4gICAgICBzZWVuLmFkZChpZCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTsgLy8gIzE2MDMxOiAoaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9pc3N1ZXMvMTYwMzEpXG4gICAgLy8gQWxsb3cgY3VzdG9tIHVzZXJsYW5kIGludGVyc2VjdCBzb3J0IG9yZGVyXG5cbiAgICBpZiAocmF5Y2FzdGVyICYmIHJheWNhc3Rlci5maWx0ZXIgJiYgc2hhcmVkU3RhdGUuY3VycmVudCkgaW50ZXJzZWN0cyA9IHJheWNhc3Rlci5maWx0ZXIoaW50ZXJzZWN0cywgc2hhcmVkU3RhdGUuY3VycmVudCk7XG5cbiAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKGludGVyc2VjdHMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOykge1xuICAgICAgdmFyIF9pbnRlcnNlY3QgPSBfc3RlcC52YWx1ZTtcbiAgICAgIHZhciBldmVudE9iamVjdCA9IF9pbnRlcnNlY3Qub2JqZWN0OyAvLyBCdWJibGUgZXZlbnQgdXBcblxuICAgICAgd2hpbGUgKGV2ZW50T2JqZWN0KSB7XG4gICAgICAgIHZhciBoYW5kbGVycyA9IGV2ZW50T2JqZWN0Ll9faGFuZGxlcnM7XG4gICAgICAgIGlmIChoYW5kbGVycykgaGl0cy5wdXNoKF9leHRlbmRzKHt9LCBfaW50ZXJzZWN0LCB7XG4gICAgICAgICAgZXZlbnRPYmplY3Q6IGV2ZW50T2JqZWN0XG4gICAgICAgIH0pKTtcbiAgICAgICAgZXZlbnRPYmplY3QgPSBldmVudE9iamVjdC5wYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGhpdHM7XG4gIH0sIFtdKTtcbiAgLyoqICBDYWxjdWxhdGVzIGNsaWNrIGRlbHRhcyAqL1xuXG4gIHZhciBjYWxjdWxhdGVEaXN0YW5jZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBkeCA9IGV2ZW50LmNsaWVudFggLSBzdGF0ZS5jdXJyZW50LmluaXRpYWxDbGlja1swXTtcbiAgICB2YXIgZHkgPSBldmVudC5jbGllbnRZIC0gc3RhdGUuY3VycmVudC5pbml0aWFsQ2xpY2tbMV07XG4gICAgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSk7XG4gIH0sIFtdKTtcbiAgdmFyIGhvdmVyZWQgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IE1hcCgpO1xuICB9LCBbXSk7XG4gIC8qKiAgSGFuZGxlcyBpbnRlcnNlY3Rpb25zIGJ5IGZvcndhcmRpbmcgdGhlbSB0byBoYW5kbGVycyAqL1xuXG4gIHZhciB0ZW1wID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgdmFyIGhhbmRsZUludGVyc2VjdHMgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnQsIGZuLCBmaWx0ZXIpIHtcbiAgICAvLyBHZXQgZnJlc2ggaW50ZXJzZWN0c1xuICAgIHZhciBpbnRlcnNlY3Rpb25zID0gaW50ZXJzZWN0KGV2ZW50LCBmaWx0ZXIpOyAvLyBJZiB0aGUgaW50ZXJhY3Rpb24gaXMgY2FwdHVyZWQgdGFrZSB0aGF0IGludG8gYWNjb3VudCwgdGhlIGNhcHR1cmVkIGV2ZW50IGhhcyB0byBiZSBwYXJ0IG9mIHRoZSBpbnRlcnNlY3RzXG5cbiAgICBpZiAoc3RhdGUuY3VycmVudC5jYXB0dXJlZCAmJiBldmVudC50eXBlICE9PSAnY2xpY2snICYmIGV2ZW50LnR5cGUgIT09ICd3aGVlbCcpIHtcbiAgICAgIHN0YXRlLmN1cnJlbnQuY2FwdHVyZWQuZm9yRWFjaChmdW5jdGlvbiAoY2FwdHVyZWQpIHtcbiAgICAgICAgaWYgKCFpbnRlcnNlY3Rpb25zLmZpbmQoZnVuY3Rpb24gKGhpdCkge1xuICAgICAgICAgIHJldHVybiBoaXQuZXZlbnRPYmplY3QgPT09IGNhcHR1cmVkLmV2ZW50T2JqZWN0O1xuICAgICAgICB9KSkgaW50ZXJzZWN0aW9ucy5wdXNoKGNhcHR1cmVkKTtcbiAgICAgIH0pO1xuICAgIH0gLy8gSWYgYW55dGhpbmcgaGFzIGJlZW4gZm91bmQsIGZvcndhcmQgaXQgdG8gdGhlIGV2ZW50IGxpc3RlbmVyc1xuXG5cbiAgICBpZiAoaW50ZXJzZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1bnByb2plY3RlZFBvaW50ID0gdGVtcC5zZXQobW91c2UueCwgbW91c2UueSwgMCkudW5wcm9qZWN0KHN0YXRlLmN1cnJlbnQuY2FtZXJhKTtcbiAgICAgICAgdmFyIGRlbHRhID0gZXZlbnQudHlwZSA9PT0gJ2NsaWNrJyA/IGNhbGN1bGF0ZURpc3RhbmNlKGV2ZW50KSA6IDA7XG5cbiAgICAgICAgdmFyIHJlbGVhc2VQb2ludGVyQ2FwdHVyZSA9IGZ1bmN0aW9uIHJlbGVhc2VQb2ludGVyQ2FwdHVyZShpZCkge1xuICAgICAgICAgIHJldHVybiBldmVudC50YXJnZXQucmVsZWFzZVBvaW50ZXJDYXB0dXJlKGlkKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbG9jYWxTdGF0ZSA9IHtcbiAgICAgICAgICBzdG9wcGVkOiBmYWxzZSxcbiAgICAgICAgICBjYXB0dXJlZDogZmFsc2VcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgICAgICB2YXIgaGl0ID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgdmFyIHNldFBvaW50ZXJDYXB0dXJlID0gZnVuY3Rpb24gc2V0UG9pbnRlckNhcHR1cmUoaWQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBoaXQgaXMgZ29pbmcgdG8gYmUgY2FwdHVyZWQgZmxhZyB0aGF0IHdlJ3JlIGluIGNhcHR1cmVkIHN0YXRlXG4gICAgICAgICAgICBpZiAoIWxvY2FsU3RhdGUuY2FwdHVyZWQpIHtcbiAgICAgICAgICAgICAgbG9jYWxTdGF0ZS5jYXB0dXJlZCA9IHRydWU7IC8vIFRoZSBjYXB0dXJlZCBoaXQgYXJyYXkgaXMgcmVzZXQgdG8gY29sbGVjdCBoaXRzXG5cbiAgICAgICAgICAgICAgc3RhdGUuY3VycmVudC5jYXB0dXJlZCA9IFtdO1xuICAgICAgICAgICAgfSAvLyBQdXNoIGhpdHMgdG8gdGhlIGFycmF5XG5cblxuICAgICAgICAgICAgaWYgKHN0YXRlLmN1cnJlbnQuY2FwdHVyZWQpIHN0YXRlLmN1cnJlbnQuY2FwdHVyZWQucHVzaChoaXQpIC8vIENhbGwgdGhlIG9yaWdpbmFsIGV2ZW50IG5vd1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnNldFBvaW50ZXJDYXB0dXJlKGlkKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIHJheWNhc3RFdmVudCA9IF9leHRlbmRzKHt9LCBldmVudCwgaGl0LCB7XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25zOiBpbnRlcnNlY3Rpb25zLFxuICAgICAgICAgICAgc3RvcHBlZDogbG9jYWxTdGF0ZS5zdG9wcGVkLFxuICAgICAgICAgICAgZGVsdGE6IGRlbHRhLFxuICAgICAgICAgICAgdW5wcm9qZWN0ZWRQb2ludDogdW5wcm9qZWN0ZWRQb2ludCxcbiAgICAgICAgICAgIHJheTogZGVmYXVsdFJheWNhc3Rlci5yYXksXG4gICAgICAgICAgICBjYW1lcmE6IHN0YXRlLmN1cnJlbnQuY2FtZXJhLFxuICAgICAgICAgICAgLy8gSGlqYWNrIHN0b3BQcm9wYWdhdGlvbiwgd2hpY2gganVzdCBzZXRzIGEgZmxhZ1xuICAgICAgICAgICAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiByYXljYXN0RXZlbnQuc3RvcHBlZCA9IGxvY2FsU3RhdGUuc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gUG9pbnRlci1jYXB0dXJlIG5lZWRzIHRoZSBoaXQsIG9uIHdoaWNoIHRoZSB1c2VyIG1heSBjYWxsIHN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgICAgICAvLyBUaGlzIG1ha2VzIGl0IGhhcmRlciB0byB1c2UgdGhlIGFjdHVhbCBldmVudCwgYmVjYXVzZSB0aGVuIHdlIGxvb3NlIHRoZSBjb25uZWN0aW9uXG4gICAgICAgICAgICAvLyB0byB0aGUgYWN0dWFsIGhpdCwgd2hpY2ggd291bGQgbWVhbiBpdCdzIHBpY2tpbmcgdXAgYWxsIGludGVyc2VjdHMgLi4uXG4gICAgICAgICAgICB0YXJnZXQ6IF9leHRlbmRzKHt9LCBldmVudC50YXJnZXQsIHtcbiAgICAgICAgICAgICAgc2V0UG9pbnRlckNhcHR1cmU6IHNldFBvaW50ZXJDYXB0dXJlLFxuICAgICAgICAgICAgICByZWxlYXNlUG9pbnRlckNhcHR1cmU6IHJlbGVhc2VQb2ludGVyQ2FwdHVyZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBjdXJyZW50VGFyZ2V0OiBfZXh0ZW5kcyh7fSwgZXZlbnQuY3VycmVudFRhcmdldCwge1xuICAgICAgICAgICAgICBzZXRQb2ludGVyQ2FwdHVyZTogc2V0UG9pbnRlckNhcHR1cmUsXG4gICAgICAgICAgICAgIHJlbGVhc2VQb2ludGVyQ2FwdHVyZTogcmVsZWFzZVBvaW50ZXJDYXB0dXJlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHNvdXJjZUV2ZW50OiBldmVudFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZm4ocmF5Y2FzdEV2ZW50KTsgLy8gRXZlbnQgYnViYmxpbmcgbWF5IG1lIGludGVycnVwdGVkIGJ5IHN0b3BQcm9wYWdhdGlvbiwgYnV0IHRoYXQgc2hvdWxkIG9ubHkgaW5jbHVkZVxuICAgICAgICAgIC8vIGV2ZW50cyB0aGF0IGFyZW4ndCBjYXB0dXJpbmcsIHNpbmNlIHRoZXNlIGFyZSBpbiB0aGUgbWlkZGxlIG9mIGEgZ2VzdHVyZSBhbmQgc2hvdWxkIG5vdFxuICAgICAgICAgIC8vIGJlIGRpc3R1cmJlZCB1bnRpbCB0aGV5IHJlc29sdmUuXG5cbiAgICAgICAgICBpZiAobG9jYWxTdGF0ZS5zdG9wcGVkID09PSB0cnVlICYmIGxvY2FsU3RhdGUuY2FwdHVyZWQgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIFByb3BhZ2F0aW9uIGlzIHN0b3BwZWQsIHJlbW92ZSBhbGwgb3RoZXIgaG92ZXIgcmVjb3Jkc1xuICAgICAgICAgICAgLy8gQW4gZXZlbnQgaGFuZGxlciBpcyBvbmx5IGFsbG93ZWQgdG8gZmx1c2ggb3RoZXIgaGFuZGxlcnMgaWYgaXQgaXMgaG92ZXJlZCBpdHNlbGZcbiAgICAgICAgICAgIGlmIChob3ZlcmVkLnNpemUgJiYgQXJyYXkuZnJvbShob3ZlcmVkLnZhbHVlcygpKS5maW5kKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpLm9iamVjdCA9PT0gaGl0Lm9iamVjdDtcbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgIGhhbmRsZVBvaW50ZXJDYW5jZWwocmF5Y2FzdEV2ZW50LCBbaGl0XSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKGludGVyc2VjdGlvbnMpLCBfc3RlcDI7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfcmV0ID0gX2xvb3AoKTtcblxuICAgICAgICAgIGlmIChfcmV0ID09PSBcImJyZWFrXCIpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9KSgpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnRlcnNlY3Rpb25zO1xuICB9LCBbXSk7XG4gIHZhciBoYW5kbGVQb2ludGVyTW92ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChldmVudCwgcHJlcGFyZSkge1xuICAgIGlmIChwcmVwYXJlID09PSB2b2lkIDApIHtcbiAgICAgIHByZXBhcmUgPSB0cnVlO1xuICAgIH1cblxuICAgIHN0YXRlLmN1cnJlbnQucG9pbnRlci5lbWl0KCdwb2ludGVyTW92ZScsIGV2ZW50KTtcbiAgICBpZiAocHJlcGFyZSkgcHJlcGFyZVJheShldmVudCk7XG4gICAgdmFyIGhpdHMgPSBoYW5kbGVJbnRlcnNlY3RzKGV2ZW50LCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgdmFyIGV2ZW50T2JqZWN0ID0gZGF0YS5ldmVudE9iamVjdDtcbiAgICAgIHZhciBoYW5kbGVycyA9IGV2ZW50T2JqZWN0Ll9faGFuZGxlcnM7IC8vIENoZWNrIHByZXNlbmNlIG9mIGhhbmRsZXJzXG5cbiAgICAgIGlmICghaGFuZGxlcnMpIHJldHVybjsgLy8gQ2FsbCBtb3VzZSBtb3ZlXG5cbiAgICAgIGlmIChoYW5kbGVycy5wb2ludGVyTW92ZSkgaGFuZGxlcnMucG9pbnRlck1vdmUoZGF0YSk7IC8vIENoZWNrIGlmIG1vdXNlIGVudGVyIG9yIG91dCBpcyBwcmVzZW50XG5cbiAgICAgIGlmIChoYW5kbGVycy5wb2ludGVyT3ZlciB8fCBoYW5kbGVycy5wb2ludGVyRW50ZXIgfHwgaGFuZGxlcnMucG9pbnRlck91dCB8fCBoYW5kbGVycy5wb2ludGVyTGVhdmUpIHtcbiAgICAgICAgdmFyIGlkID0gbWFrZUlkKGRhdGEpO1xuICAgICAgICB2YXIgaG92ZXJlZEl0ZW0gPSBob3ZlcmVkLmdldChpZCk7XG5cbiAgICAgICAgaWYgKCFob3ZlcmVkSXRlbSkge1xuICAgICAgICAgIC8vIElmIHRoZSBvYmplY3Qgd2Fzbid0IHByZXZpb3VzbHkgaG92ZXJlZCwgYm9vayBpdCBhbmQgY2FsbCBpdHMgaGFuZGxlclxuICAgICAgICAgIGhvdmVyZWQuc2V0KGlkLCBkYXRhKTtcbiAgICAgICAgICBpZiAoaGFuZGxlcnMucG9pbnRlck92ZXIpIGhhbmRsZXJzLnBvaW50ZXJPdmVyKF9leHRlbmRzKHt9LCBkYXRhLCB7XG4gICAgICAgICAgICB0eXBlOiAncG9pbnRlcm92ZXInXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIGlmIChoYW5kbGVycy5wb2ludGVyRW50ZXIpIGhhbmRsZXJzLnBvaW50ZXJFbnRlcihfZXh0ZW5kcyh7fSwgZGF0YSwge1xuICAgICAgICAgICAgdHlwZTogJ3BvaW50ZXJlbnRlcidcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaG92ZXJlZEl0ZW0uc3RvcHBlZCkge1xuICAgICAgICAgIC8vIElmIHRoZSBvYmplY3Qgd2FzIHByZXZpb3VzbHkgaG92ZXJlZCBhbmQgc3RvcHBlZCwgd2Ugc2hvdWxkbid0IGFsbG93IG90aGVyIGl0ZW1zIHRvIHByb2NlZWRcbiAgICAgICAgICBkYXRhLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgLy8gVGhpcyBpcyBvblBvaW50ZXJNb3ZlLCB3ZSdyZSBvbmx5IGludGVyZXN0ZWQgaW4gZXZlbnRzIHRoYXQgZXhoaWJpdCB0aGlzIHBhcnRpY3VsYXIgZXZlbnRcbiAgICBmdW5jdGlvbiAob2JqZWN0cykge1xuICAgICAgcmV0dXJuIG9iamVjdHMuZmlsdGVyKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIFsnTW92ZScsICdPdmVyJywgJ0VudGVyJywgJ091dCcsICdMZWF2ZSddLnNvbWUoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gb2JqLl9faGFuZGxlcnNbJ3BvaW50ZXInICsgbmFtZV07XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7IC8vIFRha2UgY2FyZSBvZiB1bmhvdmVyXG5cbiAgICBoYW5kbGVQb2ludGVyQ2FuY2VsKGV2ZW50LCBoaXRzLCBwcmVwYXJlKTtcbiAgICByZXR1cm4gaGl0cztcbiAgfSwgW10pO1xuICB2YXIgaGFuZGxlUG9pbnRlckNhbmNlbCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChldmVudCwgaGl0cywgcHJlcGFyZSkge1xuICAgIGlmIChwcmVwYXJlID09PSB2b2lkIDApIHtcbiAgICAgIHByZXBhcmUgPSB0cnVlO1xuICAgIH1cblxuICAgIHN0YXRlLmN1cnJlbnQucG9pbnRlci5lbWl0KCdwb2ludGVyQ2FuY2VsJywgZXZlbnQpO1xuICAgIGlmIChwcmVwYXJlKSBwcmVwYXJlUmF5KGV2ZW50KTtcbiAgICBpZiAoIWhpdHMpIGhpdHMgPSBoYW5kbGVJbnRlcnNlY3RzKGV2ZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcbiAgICBBcnJheS5mcm9tKGhvdmVyZWQudmFsdWVzKCkpLmZvckVhY2goZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIC8vIFdoZW4gbm8gb2JqZWN0cyB3ZXJlIGhpdCBvciB0aGUgdGhlIGhvdmVyZWQgb2JqZWN0IHdhc24ndCBmb3VuZCB1bmRlcm5lYXRoIHRoZSBjdXJzb3JcbiAgICAgIC8vIHdlIGNhbGwgb25Qb2ludGVyT3V0IGFuZCBkZWxldGUgdGhlIG9iamVjdCBmcm9tIHRoZSBob3ZlcmVkLWVsZW1lbnRzIG1hcFxuICAgICAgaWYgKGhpdHMgJiYgKCFoaXRzLmxlbmd0aCB8fCAhaGl0cy5maW5kKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBpLmV2ZW50T2JqZWN0ID09PSBkYXRhLmV2ZW50T2JqZWN0O1xuICAgICAgfSkpKSB7XG4gICAgICAgIHZhciBldmVudE9iamVjdCA9IGRhdGEuZXZlbnRPYmplY3Q7XG4gICAgICAgIHZhciBoYW5kbGVycyA9IGV2ZW50T2JqZWN0Ll9faGFuZGxlcnM7XG5cbiAgICAgICAgaWYgKGhhbmRsZXJzKSB7XG4gICAgICAgICAgaWYgKGhhbmRsZXJzLnBvaW50ZXJPdXQpIGhhbmRsZXJzLnBvaW50ZXJPdXQoX2V4dGVuZHMoe30sIGRhdGEsIHtcbiAgICAgICAgICAgIHR5cGU6ICdwb2ludGVyb3V0J1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBpZiAoaGFuZGxlcnMucG9pbnRlckxlYXZlKSBoYW5kbGVycy5wb2ludGVyTGVhdmUoX2V4dGVuZHMoe30sIGRhdGEsIHtcbiAgICAgICAgICAgIHR5cGU6ICdwb2ludGVybGVhdmUnXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaG92ZXJlZFtcImRlbGV0ZVwiXShtYWtlSWQoZGF0YSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBbXSk7XG4gIHZhciBoYW5kbGVQb2ludGVyID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50LCBwcmVwYXJlKSB7XG4gICAgICBpZiAocHJlcGFyZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHByZXBhcmUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZS5jdXJyZW50LnBvaW50ZXIuZW1pdChuYW1lLCBldmVudCk7XG4gICAgICBpZiAocHJlcGFyZSkgcHJlcGFyZVJheShldmVudCk7XG4gICAgICB2YXIgaGl0cyA9IGhhbmRsZUludGVyc2VjdHMoZXZlbnQsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBldmVudE9iamVjdCA9IGRhdGEuZXZlbnRPYmplY3Q7XG4gICAgICAgIHZhciBoYW5kbGVycyA9IGV2ZW50T2JqZWN0Ll9faGFuZGxlcnM7XG5cbiAgICAgICAgaWYgKGhhbmRsZXJzICYmIGhhbmRsZXJzW25hbWVdKSB7XG4gICAgICAgICAgLy8gRm9yd2FyZCBhbGwgZXZlbnRzIGJhY2sgdG8gdGhlaXIgcmVzcGVjdGl2ZSBoYW5kbGVycyB3aXRoIHRoZSBleGNlcHRpb24gb2YgY2xpY2sgZXZlbnRzLFxuICAgICAgICAgIC8vIHdoaWNoIG11c3QgdXNlIHRoZSBpbml0aWFsIHRhcmdldFxuICAgICAgICAgIGlmIChuYW1lICE9PSAnY2xpY2snICYmIG5hbWUgIT09ICdjb250ZXh0TWVudScgJiYgbmFtZSAhPT0gJ2RvdWJsZUNsaWNrJyB8fCBzdGF0ZS5jdXJyZW50LmluaXRpYWxIaXRzLmluY2x1ZGVzKGV2ZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgaGFuZGxlcnNbbmFtZV0oZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTsgLy8gSWYgYSBjbGljayB5aWVsZHMgbm8gcmVzdWx0cywgcGFzcyBpdCBiYWNrIHRvIHRoZSB1c2VyIGFzIGEgbWlzc1xuXG4gICAgICBpZiAobmFtZSA9PT0gJ3BvaW50ZXJEb3duJykge1xuICAgICAgICBzdGF0ZS5jdXJyZW50LmluaXRpYWxDbGljayA9IFtldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZXTtcbiAgICAgICAgc3RhdGUuY3VycmVudC5pbml0aWFsSGl0cyA9IGhpdHMubWFwKGZ1bmN0aW9uIChoaXQpIHtcbiAgICAgICAgICByZXR1cm4gaGl0LmV2ZW50T2JqZWN0O1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKChuYW1lID09PSAnY2xpY2snIHx8IG5hbWUgPT09ICdjb250ZXh0TWVudScgfHwgbmFtZSA9PT0gJ2RvdWJsZUNsaWNrJykgJiYgIWhpdHMubGVuZ3RoICYmIG9uUG9pbnRlck1pc3NlZCkge1xuICAgICAgICBpZiAoY2FsY3VsYXRlRGlzdGFuY2UoZXZlbnQpIDw9IDIpIG9uUG9pbnRlck1pc3NlZCgpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtvblBvaW50ZXJNaXNzZWRdKTtcbiAgUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgc3RhdGUuY3VycmVudC5ldmVudHMgPSB7XG4gICAgICBvbkNsaWNrOiBoYW5kbGVQb2ludGVyKCdjbGljaycpLFxuICAgICAgb25Db250ZXh0TWVudTogaGFuZGxlUG9pbnRlcignY29udGV4dE1lbnUnKSxcbiAgICAgIG9uRG91YmxlQ2xpY2s6IGhhbmRsZVBvaW50ZXIoJ2RvdWJsZUNsaWNrJyksXG4gICAgICBvbldoZWVsOiBoYW5kbGVQb2ludGVyKCd3aGVlbCcpLFxuICAgICAgb25Qb2ludGVyRG93bjogaGFuZGxlUG9pbnRlcigncG9pbnRlckRvd24nKSxcbiAgICAgIG9uUG9pbnRlclVwOiBoYW5kbGVQb2ludGVyKCdwb2ludGVyVXAnKSxcbiAgICAgIG9uUG9pbnRlckxlYXZlOiBmdW5jdGlvbiBvblBvaW50ZXJMZWF2ZShlKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVQb2ludGVyQ2FuY2VsKGUsIFtdKTtcbiAgICAgIH0sXG4gICAgICBvblBvaW50ZXJNb3ZlOiBoYW5kbGVQb2ludGVyTW92ZSxcbiAgICAgIC8vIG9uR290UG9pbnRlckNhcHR1cmUgaXMgbm90IG5lZWRlZCBhbnkgbG9uZ2VyIGJlY2F1c2UgdGhlIGJlaGF2aW91ciBpcyBoYWNrZWQgaW50b1xuICAgICAgLy8gdGhlIGV2ZW50IGl0c2VsZiAoc2VlIGhhbmRsZUludGVyc2VjdHMpLiBCdXQgaW4gb3JkZXIgZm9yIG5vbi13ZWIgdGFyZ2V0cyB0byBzaW11bGF0ZVxuICAgICAgLy8gaXQgd2Uga2VlcCB0aGUgbGVnYWN5IGV2ZW50LCB3aGljaCBzaW1wbHkgZmxhZ3MgYWxsIGN1cnJlbnQgaW50ZXJzZWN0cyBhcyBjYXB0dXJlZFxuICAgICAgb25Hb3RQb2ludGVyQ2FwdHVyZUxlZ2FjeTogZnVuY3Rpb24gb25Hb3RQb2ludGVyQ2FwdHVyZUxlZ2FjeShlKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5jdXJyZW50LmNhcHR1cmVkID0gaW50ZXJzZWN0KGUpO1xuICAgICAgfSxcbiAgICAgIG9uTG9zdFBvaW50ZXJDYXB0dXJlOiBmdW5jdGlvbiBvbkxvc3RQb2ludGVyQ2FwdHVyZShlKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5jdXJyZW50LmNhcHR1cmVkID0gdW5kZWZpbmVkLCBoYW5kbGVQb2ludGVyQ2FuY2VsKGUpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtvblBvaW50ZXJNaXNzZWRdKTtcbiAgLyoqIEV2ZW50cyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gIC8vIE9ubHkgdHJpZ2dlciB0aGUgY29udGV4dCBwcm92aWRlciB3aGVuIG5lY2Vzc2FyeVxuXG4gIHZhciBzaGFyZWRTdGF0ZSA9IFJlYWN0LnVzZVJlZigpO1xuICBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3N0YXRlJGN1cnJlbnQgPSBzdGF0ZS5jdXJyZW50LFxuICAgICAgICByZWFkeSA9IF9zdGF0ZSRjdXJyZW50LnJlYWR5LFxuICAgICAgICBtYW51YWwgPSBfc3RhdGUkY3VycmVudC5tYW51YWwsXG4gICAgICAgIHZyID0gX3N0YXRlJGN1cnJlbnQudnIsXG4gICAgICAgIG5vRXZlbnRzID0gX3N0YXRlJGN1cnJlbnQubm9FdmVudHMsXG4gICAgICAgIGludmFsaWRhdGVGcmFtZWxvb3AgPSBfc3RhdGUkY3VycmVudC5pbnZhbGlkYXRlRnJhbWVsb29wLFxuICAgICAgICBmcmFtZXMgPSBfc3RhdGUkY3VycmVudC5mcmFtZXMsXG4gICAgICAgIHN1YnNjcmliZXJzID0gX3N0YXRlJGN1cnJlbnQuc3Vic2NyaWJlcnMsXG4gICAgICAgIGNhcHR1cmVkID0gX3N0YXRlJGN1cnJlbnQuY2FwdHVyZWQsXG4gICAgICAgIGluaXRpYWxDbGljayA9IF9zdGF0ZSRjdXJyZW50LmluaXRpYWxDbGljayxcbiAgICAgICAgaW5pdGlhbEhpdHMgPSBfc3RhdGUkY3VycmVudC5pbml0aWFsSGl0cyxcbiAgICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfc3RhdGUkY3VycmVudCwgW1wicmVhZHlcIiwgXCJtYW51YWxcIiwgXCJ2clwiLCBcIm5vRXZlbnRzXCIsIFwiaW52YWxpZGF0ZUZyYW1lbG9vcFwiLCBcImZyYW1lc1wiLCBcInN1YnNjcmliZXJzXCIsIFwiY2FwdHVyZWRcIiwgXCJpbml0aWFsQ2xpY2tcIiwgXCJpbml0aWFsSGl0c1wiXSk7XG5cbiAgICBzaGFyZWRTdGF0ZS5jdXJyZW50ID0gcHJvcHM7XG4gIH0sIFtzaXplLCBkZWZhdWx0Q2FtXSk7IC8vIFVwZGF0ZSBwaXhlbCByYXRpb1xuXG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHZvaWQgKHBpeGVsUmF0aW8gJiYgZ2wuc2V0UGl4ZWxSYXRpbyhwaXhlbFJhdGlvKSk7XG4gIH0sIFtwaXhlbFJhdGlvXSk7IC8vIFVwZGF0ZSBzaGFkb3cgbWFwXG5cbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2hhZG93TWFwKSB7XG4gICAgICBnbC5zaGFkb3dNYXAuZW5hYmxlZCA9IHRydWU7XG4gICAgICBpZiAodHlwZW9mIHNoYWRvd01hcCA9PT0gJ29iamVjdCcpIE9iamVjdC5hc3NpZ24oZ2wsIHNoYWRvd01hcCk7ZWxzZSBnbC5zaGFkb3dNYXAudHlwZSA9IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXA7XG4gICAgfVxuXG4gICAgaWYgKGNvbG9yTWFuYWdlbWVudCkge1xuICAgICAgZ2wudG9uZU1hcHBpbmcgPSBUSFJFRS5BQ0VTRmlsbWljVG9uZU1hcHBpbmc7XG4gICAgICBnbC5vdXRwdXRFbmNvZGluZyA9IFRIUkVFLnNSR0JFbmNvZGluZztcbiAgICB9XG4gIH0sIFtzaGFkb3dNYXAsIGNvbG9yTWFuYWdlbWVudF0pOyAvLyBUaGlzIGNvbXBvbmVudCBpcyBhIGJyaWRnZSBpbnRvIHRoZSB0aHJlZSByZW5kZXIgY29udGV4dCwgd2hlbiBpdCBnZXRzIHJlbmRlcmVkXG4gIC8vIHdlIGtub3cgd2UgYXJlIHJlYWR5IHRvIGNvbXBpbGUgc2hhZGVycywgY2FsbCBzdWJzY3JpYmVycywgZXRjXG5cbiAgdmFyIENhbnZhcyA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIENhbnZhcyhwcm9wcykge1xuICAgIHZhciBhY3RpdmF0ZSA9IGZ1bmN0aW9uIGFjdGl2YXRlKCkge1xuICAgICAgcmV0dXJuIHNldFJlYWR5KHRydWUpO1xuICAgIH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuXG5cbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IG9uQ3JlYXRlZCAmJiBvbkNyZWF0ZWQoc3RhdGUuY3VycmVudCk7XG4gICAgICByZXR1cm4gdm9pZCAocmVzdWx0ICYmIHJlc3VsdC50aGVuID8gcmVzdWx0LnRoZW4oYWN0aXZhdGUpIDogYWN0aXZhdGUoKSk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBwcm9wcy5jaGlsZHJlbjtcbiAgfSwgW10pOyAvLyBSZW5kZXIgdi1kb20gaW50byBzY2VuZVxuXG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmVuZGVyKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDYW52YXMsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KHN0YXRlQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IHNoYXJlZFN0YXRlLmN1cnJlbnRcbiAgICB9LCB0eXBlb2YgY2hpbGRyZW4gPT09ICdmdW5jdGlvbicgPyBjaGlsZHJlbihzdGF0ZS5jdXJyZW50KSA6IGNoaWxkcmVuKSksIGRlZmF1bHRTY2VuZSwgc3RhdGUpO1xuICB9LCBbcmVhZHksIGNoaWxkcmVuLCBzaGFyZWRTdGF0ZS5jdXJyZW50XSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHJlYWR5KSB7XG4gICAgICAvLyBTdGFydCByZW5kZXItbG9vcCwgZWl0aGVyIHZpYSBSQUYgb3Igc2V0QW5pbWF0aW9uTG9vcCBmb3IgVlJcbiAgICAgIGlmICghc3RhdGUuY3VycmVudC52cikge1xuICAgICAgICBpbnZhbGlkYXRlKHN0YXRlKTtcbiAgICAgIH0gZWxzZSBpZiAoKGdsLnhyIHx8IGdsLnZyKSAmJiBnbC5zZXRBbmltYXRpb25Mb29wKSB7XG4gICAgICAgIChnbC54ciB8fCBnbC52cikuZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIGdsLnNldEFuaW1hdGlvbkxvb3AoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVuZGVyR2woc3RhdGUsIHQsIDAsIHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBjb25zb2xlLndhcm4oJ3RoZSBnbCBpbnN0YW5jZSBkb2VzIG5vdCBzdXBwb3J0IFZSIScpO1xuICAgIH1cbiAgfSwgW3JlYWR5LCBpbnZhbGlkYXRlRnJhbWVsb29wXSk7IC8vIERpc3Bvc2UgcmVuZGVyZXIgb24gdW5tb3VudFxuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzdGF0ZS5jdXJyZW50LmdsKSB7XG4gICAgICAgIHN0YXRlLmN1cnJlbnQuZ2wucmVuZGVyTGlzdHMuZGlzcG9zZSgpO1xuICAgICAgICBpZiAoc3RhdGUuY3VycmVudC5nbC5mb3JjZUNvbnRleHRMb3NzKSBzdGF0ZS5jdXJyZW50LmdsLmZvcmNlQ29udGV4dExvc3MoKTtcbiAgICAgICAgZGlzcG9zZShzdGF0ZS5jdXJyZW50LmdsKTtcbiAgICAgIH1cblxuICAgICAgdW5tb3VudENvbXBvbmVudEF0Tm9kZShzdGF0ZS5jdXJyZW50LnNjZW5lLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRpc3Bvc2Uoc3RhdGUuY3VycmVudC5zY2VuZSk7XG4gICAgICAgIGRpc3Bvc2Uoc3RhdGUuY3VycmVudC5yYXljYXN0ZXIpO1xuICAgICAgICBkaXNwb3NlKHN0YXRlLmN1cnJlbnQuY2FtZXJhKTtcbiAgICAgICAgZGlzcG9zZShzdGF0ZS5jdXJyZW50KTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIHN0YXRlLmN1cnJlbnQuZXZlbnRzO1xufTtcblxuZnVuY3Rpb24gZGlzcG9zZShvYmopIHtcbiAgaWYgKG9iai5kaXNwb3NlKSBvYmouZGlzcG9zZSgpO1xuXG4gIGZvciAodmFyIHAgaW4gb2JqKSB7XG4gICAgaWYgKHR5cGVvZiBwID09PSAnb2JqZWN0JyAmJiBwLmRpc3Bvc2UpIHAuZGlzcG9zZSgpO1xuICAgIGRlbGV0ZSBvYmpbcF07XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlQ29udGV4dChjb250ZXh0KSB7XG4gIHZhciByZXN1bHQgPSBSZWFjdC51c2VDb250ZXh0KGNvbnRleHQpO1xuXG4gIGlmICghcmVzdWx0KSB7XG4gICAgY29uc29sZS53YXJuKCdob29rcyBjYW4gb25seSBiZSB1c2VkIHdpdGhpbiB0aGUgY2FudmFzISBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Qtc3ByaW5nL3JlYWN0LXRocmVlLWZpYmVyI2hvb2tzJyk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiB1c2VGcmFtZShjYWxsYmFjaywgcmVuZGVyUHJpb3JpdHkpIHtcbiAgaWYgKHJlbmRlclByaW9yaXR5ID09PSB2b2lkIDApIHtcbiAgICByZW5kZXJQcmlvcml0eSA9IDA7XG4gIH1cblxuICB2YXIgX3VzZUNvbnRleHQgPSB1c2VDb250ZXh0KHN0YXRlQ29udGV4dCksXG4gICAgICBzdWJzY3JpYmUgPSBfdXNlQ29udGV4dC5zdWJzY3JpYmU7IC8vIFVwZGF0ZSByZWZcblxuXG4gIHZhciByZWYgPSBSZWFjdC51c2VSZWYoY2FsbGJhY2spO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB2b2lkIChyZWYuY3VycmVudCA9IGNhbGxiYWNrKTtcbiAgfSwgW2NhbGxiYWNrXSk7IC8vIFN1YnNjcmliZS91bnN1YlxuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVuc3Vic2NyaWJlID0gc3Vic2NyaWJlKHJlZiwgcmVuZGVyUHJpb3JpdHkpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICB9LCBbcmVuZGVyUHJpb3JpdHldKTtcbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB1c2VUaHJlZSgpIHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoc3RhdGVDb250ZXh0KTtcbn1cbmZ1bmN0aW9uIHVzZVVwZGF0ZShjYWxsYmFjaywgZGVwZW5kZW50cywgb3B0aW9uYWxSZWYpIHtcbiAgdmFyIF91c2VDb250ZXh0MiA9IHVzZUNvbnRleHQoc3RhdGVDb250ZXh0KSxcbiAgICAgIGludmFsaWRhdGUgPSBfdXNlQ29udGV4dDIuaW52YWxpZGF0ZTtcblxuICB2YXIgbG9jYWxSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgdmFyIHJlZiA9IG9wdGlvbmFsUmVmID8gb3B0aW9uYWxSZWYgOiBsb2NhbFJlZjtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocmVmLmN1cnJlbnQpIHtcbiAgICAgIGNhbGxiYWNrKHJlZi5jdXJyZW50KTtcbiAgICAgIGludmFsaWRhdGUoKTtcbiAgICB9XG4gIH0sIGRlcGVuZGVudHMpO1xuICByZXR1cm4gcmVmO1xufVxuZnVuY3Rpb24gdXNlUmVzb3VyY2Uob3B0aW9uYWxSZWYpIHtcbiAgdmFyIF91c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKSxcbiAgICAgIF8gPSBfdXNlU3RhdGVbMF0sXG4gICAgICBmb3JjZVVwZGF0ZSA9IF91c2VTdGF0ZVsxXTtcblxuICB2YXIgbG9jYWxSZWYgPSBSZWFjdC51c2VSZWYodW5kZWZpbmVkKTtcbiAgdmFyIHJlZiA9IG9wdGlvbmFsUmVmID8gb3B0aW9uYWxSZWYgOiBsb2NhbFJlZjtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdm9pZCBmb3JjZVVwZGF0ZShmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuICFpO1xuICAgIH0pO1xuICB9LCBbcmVmLmN1cnJlbnRdKTtcbiAgcmV0dXJuIFtyZWYsIHJlZi5jdXJyZW50XTtcbn1cbmZ1bmN0aW9uIHVzZUxvYWRlcihQcm90bywgdXJsLCBleHRlbnNpb25zLCBvblByb2dyZXNzKSB7XG4gIHZhciBsb2FkZXIgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBDb25zdHJ1Y3QgbmV3IGxvYWRlclxuICAgIHZhciB0ZW1wID0gbmV3IFByb3RvKCk7IC8vIFJ1biBsb2FkZXIgZXh0ZW5zaW9uc1xuXG4gICAgaWYgKGV4dGVuc2lvbnMpIGV4dGVuc2lvbnModGVtcCk7XG4gICAgcmV0dXJuIHRlbXA7XG4gIH0sIFtQcm90b10pOyAvLyBVc2Ugc3VzcGVuc2UgdG8gbG9hZCBhc3luYyBhc3NldHNcblxuICB2YXIgcmVzdWx0cyA9IHVzZVByb21pc2UoZnVuY3Rpb24gKFByb3RvLCB1cmwpIHtcbiAgICB2YXIgdXJsQXJyYXkgPSBBcnJheS5pc0FycmF5KHVybCkgPyB1cmwgOiBbdXJsXTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwodXJsQXJyYXkubWFwKGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzLCByZWplY3QpIHtcbiAgICAgICAgcmV0dXJuIGxvYWRlci5sb2FkKHVybCwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICBpZiAoZGF0YS5zY2VuZSkge1xuICAgICAgICAgICAgZGF0YS5ub2RlcyA9IHt9O1xuICAgICAgICAgICAgZGF0YS5tYXRlcmlhbHMgPSB7fTtcbiAgICAgICAgICAgIGRhdGEuc2NlbmUudHJhdmVyc2UoZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICB2YXIgX2V4dGVuZHMyO1xuXG4gICAgICAgICAgICAgIGlmIChvYmoubmFtZSkgZGF0YS5ub2RlcyA9IF9leHRlbmRzKHt9LCBkYXRhLm5vZGVzLCAoX2V4dGVuZHMyID0ge30sIF9leHRlbmRzMltvYmoubmFtZV0gPSBvYmosIF9leHRlbmRzMikpO1xuICAgICAgICAgICAgICBpZiAob2JqLm1hdGVyaWFsICYmICFkYXRhLm1hdGVyaWFsc1tvYmoubWF0ZXJpYWwubmFtZV0pIGRhdGEubWF0ZXJpYWxzW29iai5tYXRlcmlhbC5uYW1lXSA9IG9iai5tYXRlcmlhbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlcyhkYXRhKTtcbiAgICAgICAgfSwgb25Qcm9ncmVzcywgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KSk7XG4gIH0sIFtQcm90bywgdXJsXSk7IC8vIFJldHVybiB0aGUgb2JqZWN0L3NcblxuICByZXR1cm4gQXJyYXkuaXNBcnJheSh1cmwpID8gcmVzdWx0cyA6IHJlc3VsdHNbMF07XG59XG5cbnZhciBkZWZhdWx0U3R5bGVzID0ge1xuICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgd2lkdGg6ICcxMDAlJyxcbiAgaGVpZ2h0OiAnMTAwJScsXG4gIG92ZXJmbG93OiAnaGlkZGVuJ1xufTtcblxuZnVuY3Rpb24gQ29udGVudChfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBzZXRFdmVudHMgPSBfcmVmLnNldEV2ZW50cyxcbiAgICAgIGNvbnRhaW5lciA9IF9yZWYuY29udGFpbmVyLFxuICAgICAgcmVuZGVyZXIgPSBfcmVmLnJlbmRlcmVyLFxuICAgICAgZWZmZWN0cyA9IF9yZWYuZWZmZWN0cyxcbiAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZiwgW1wiY2hpbGRyZW5cIiwgXCJzZXRFdmVudHNcIiwgXCJjb250YWluZXJcIiwgXCJyZW5kZXJlclwiLCBcImVmZmVjdHNcIl0pO1xuXG4gIC8vIENyZWF0ZSByZW5kZXJlclxuICB2YXIgX3VzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUocmVuZGVyZXIpLFxuICAgICAgZ2wgPSBfdXNlU3RhdGVbMF07XG5cbiAgaWYgKCFnbCkgY29uc29sZS53YXJuKCdObyByZW5kZXJlciBjcmVhdGVkIScpOyAvLyBNb3VudCBhbmQgdW5tb3VudCBtYW5hZ2VtZW50XG5cbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZWZmZWN0cyAmJiBlZmZlY3RzKGdsLCBjb250YWluZXIpO1xuICB9LCBbXSk7IC8vIEluaXQgY2FudmFzLCBmZXRjaCBldmVudHMsIGhhbmQgdGhlbSBiYWNrIHRvIHRoZSB3cmFwcGluZyBkaXZcblxuICB2YXIgZXZlbnRzID0gdXNlQ2FudmFzKF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBnbDogZ2xcbiAgfSkpO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB2b2lkIHNldEV2ZW50cyhldmVudHMpO1xuICB9LCBbZXZlbnRzXSk7XG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVzaXplQ29udGFpbmVyID0gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0Lm1lbW8oZnVuY3Rpb24gUmVzaXplQ29udGFpbmVyKHByb3BzKSB7XG4gIHZhciByZW5kZXJlciA9IHByb3BzLnJlbmRlcmVyLFxuICAgICAgZWZmZWN0cyA9IHByb3BzLmVmZmVjdHMsXG4gICAgICBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgdnIgPSBwcm9wcy52cixcbiAgICAgIGdsMiA9IHByb3BzLmdsMixcbiAgICAgIGNvbmN1cnJlbnQgPSBwcm9wcy5jb25jdXJyZW50LFxuICAgICAgc2hhZG93TWFwID0gcHJvcHMuc2hhZG93TWFwLFxuICAgICAgY29sb3JNYW5hZ2VtZW50ID0gcHJvcHMuY29sb3JNYW5hZ2VtZW50LFxuICAgICAgb3J0aG9ncmFwaGljID0gcHJvcHMub3J0aG9ncmFwaGljLFxuICAgICAgaW52YWxpZGF0ZUZyYW1lbG9vcCA9IHByb3BzLmludmFsaWRhdGVGcmFtZWxvb3AsXG4gICAgICB1cGRhdGVEZWZhdWx0Q2FtZXJhID0gcHJvcHMudXBkYXRlRGVmYXVsdENhbWVyYSxcbiAgICAgIG5vRXZlbnRzID0gcHJvcHMubm9FdmVudHMsXG4gICAgICBnbCA9IHByb3BzLmdsLFxuICAgICAgY2FtZXJhID0gcHJvcHMuY2FtZXJhLFxuICAgICAgcmF5Y2FzdGVyID0gcHJvcHMucmF5Y2FzdGVyLFxuICAgICAgcGl4ZWxSYXRpbyA9IHByb3BzLnBpeGVsUmF0aW8sXG4gICAgICBvbkNyZWF0ZWQgPSBwcm9wcy5vbkNyZWF0ZWQsXG4gICAgICBvblBvaW50ZXJNaXNzZWQgPSBwcm9wcy5vblBvaW50ZXJNaXNzZWQsXG4gICAgICBwcmVSZW5kZXIgPSBwcm9wcy5wcmVSZW5kZXIsXG4gICAgICByZXNpemUgPSBwcm9wcy5yZXNpemUsXG4gICAgICBzdHlsZSA9IHByb3BzLnN0eWxlLFxuICAgICAgcmVzdFNwcmVhZCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBbXCJyZW5kZXJlclwiLCBcImVmZmVjdHNcIiwgXCJjaGlsZHJlblwiLCBcInZyXCIsIFwiZ2wyXCIsIFwiY29uY3VycmVudFwiLCBcInNoYWRvd01hcFwiLCBcImNvbG9yTWFuYWdlbWVudFwiLCBcIm9ydGhvZ3JhcGhpY1wiLCBcImludmFsaWRhdGVGcmFtZWxvb3BcIiwgXCJ1cGRhdGVEZWZhdWx0Q2FtZXJhXCIsIFwibm9FdmVudHNcIiwgXCJnbFwiLCBcImNhbWVyYVwiLCBcInJheWNhc3RlclwiLCBcInBpeGVsUmF0aW9cIiwgXCJvbkNyZWF0ZWRcIiwgXCJvblBvaW50ZXJNaXNzZWRcIiwgXCJwcmVSZW5kZXJcIiwgXCJyZXNpemVcIiwgXCJzdHlsZVwiXSk7XG5cbiAgdmFyIGNvbnRhaW5lclJlZiA9IFJlYWN0LnVzZVJlZigpOyAvLyBvbkdvdFBvaW50ZXJDYXB0dXJlTGVnYWN5IGlzIGEgZmFrZSBldmVudCB1c2VkIGJ5IG5vbi13ZWIgdGFyZ2V0cyB0byBzaW11bGF0ZSBwb2luenRlciBjYXB0dXJlXG5cbiAgdmFyIF91c2VTdGF0ZTIgPSBSZWFjdC51c2VTdGF0ZSh7fSksXG4gICAgICBfdXNlU3RhdGUyJCA9IF91c2VTdGF0ZTJbMF0sXG4gICAgICBvbkdvdFBvaW50ZXJDYXB0dXJlTGVnYWN5ID0gX3VzZVN0YXRlMiQub25Hb3RQb2ludGVyQ2FwdHVyZUxlZ2FjeSxcbiAgICAgIGV2ZW50cyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF91c2VTdGF0ZTIkLCBbXCJvbkdvdFBvaW50ZXJDYXB0dXJlTGVnYWN5XCJdKSxcbiAgICAgIHNldEV2ZW50cyA9IF91c2VTdGF0ZTJbMV07XG5cbiAgdmFyIF91c2VNZWFzdXJlID0gdXNlTWVhc3VyZShyZXNpemUgfHwge1xuICAgIHNjcm9sbDogdHJ1ZSxcbiAgICBkZWJvdW5jZToge1xuICAgICAgc2Nyb2xsOiA1MCxcbiAgICAgIHJlc2l6ZTogMFxuICAgIH0sXG4gICAgcG9seWZpbGw6IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICF3aW5kb3cuUmVzaXplT2JzZXJ2ZXIgPyByZXNpemVPYnNlcnZlci5SZXNpemVPYnNlcnZlciA6IHVuZGVmaW5lZFxuICB9KSxcbiAgICAgIGJpbmQgPSBfdXNlTWVhc3VyZVswXSxcbiAgICAgIHNpemUgPSBfdXNlTWVhc3VyZVsxXSxcbiAgICAgIGZvcmNlUmVzaXplID0gX3VzZU1lYXN1cmVbMl07IC8vIEZsYWcgdmlldyByZWFkeSBvbmNlIGl0J3MgYmVlbiBtZWFzdXJlZCBvdXRcblxuXG4gIHZhciByZWFkeUZsYWcgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICB2YXIgcmVhZHkgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmVhZHlGbGFnLmN1cnJlbnQgPSByZWFkeUZsYWcuY3VycmVudCB8fCAhIXNpemUud2lkdGggJiYgISFzaXplLmhlaWdodDtcbiAgfSwgW3NpemVdKTtcbiAgdmFyIHN0YXRlID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNpemU6IHNpemUsXG4gICAgICBmb3JjZVJlc2l6ZTogZm9yY2VSZXNpemUsXG4gICAgICBzZXRFdmVudHM6IHNldEV2ZW50cyxcbiAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyUmVmLmN1cnJlbnRcbiAgICB9O1xuICB9LCBbc2l6ZV0pOyAvLyBBbGxvdyBHYXRzYnksIE5leHQgYW5kIG90aGVyIHNlcnZlciBzaWRlIGFwcHMgdG8gcnVuLiBXaWxsIG91dHB1dCBzdHlsZXMgdG8gcmVkdWNlIGZsaWNrZXJpbmcuXG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX2V4dGVuZHMoe1xuICAgIHN0eWxlOiBfZXh0ZW5kcyh7fSwgZGVmYXVsdFN0eWxlcywgc3R5bGUpXG4gIH0sIHJlc3RTcHJlYWQpLCBwcmVSZW5kZXIpOyAvLyBSZW5kZXIgdGhlIGNhbnZhcyBpbnRvIHRoZSBkb21cblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX2V4dGVuZHMoe1xuICAgIHJlZjogbWVyZ2VSZWZzKFtiaW5kLCBjb250YWluZXJSZWZdKSxcbiAgICBzdHlsZTogX2V4dGVuZHMoe30sIGRlZmF1bHRTdHlsZXMsIHN0eWxlKVxuICB9LCBldmVudHMsIHJlc3RTcHJlYWQpLCBwcmVSZW5kZXIsIHJlYWR5ICYmIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KENvbnRlbnQsIF9leHRlbmRzKHt9LCBwcm9wcywgc3RhdGUpKSk7XG59KTtcblxudmFyIENhbnZhcyA9IC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5tZW1vKGZ1bmN0aW9uIENhbnZhcyhfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIFtcImNoaWxkcmVuXCJdKTtcblxuICB2YXIgY2FudmFzUmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChSZXNpemVDb250YWluZXIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIHJlbmRlcmVyOiBmdW5jdGlvbiByZW5kZXJlcigpIHtcbiAgICAgIGlmIChjYW52YXNSZWYuY3VycmVudCkge1xuICAgICAgICB2YXIgcGFyYW1zID0gX2V4dGVuZHMoe1xuICAgICAgICAgIGFudGlhbGlhczogdHJ1ZSxcbiAgICAgICAgICBhbHBoYTogdHJ1ZVxuICAgICAgICB9LCBwcm9wcy5nbCk7XG5cbiAgICAgICAgdmFyIHRlbXAgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcihfZXh0ZW5kcyh7XG4gICAgICAgICAgcG93ZXJQcmVmZXJlbmNlOiAnaGlnaC1wZXJmb3JtYW5jZScsXG4gICAgICAgICAgLy9zdGVuY2lsOiBmYWxzZSxcbiAgICAgICAgICAvL2RlcHRoOiBmYWxzZSxcbiAgICAgICAgICBjYW52YXM6IGNhbnZhc1JlZi5jdXJyZW50LFxuICAgICAgICAgIGNvbnRleHQ6IHByb3BzLmdsMiA/IGNhbnZhc1JlZi5jdXJyZW50LmdldENvbnRleHQoJ3dlYmdsMicsIHBhcmFtcykgOiB1bmRlZmluZWRcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0ZW1wO1xuICAgICAgfVxuICAgIH0sXG4gICAgcHJlUmVuZGVyOiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiLCB7XG4gICAgICByZWY6IGNhbnZhc1JlZixcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICAgIH1cbiAgICB9KVxuICB9KSwgY2hpbGRyZW4pO1xufSk7XG5cbmV4cG9ydHMuQ2FudmFzID0gQ2FudmFzO1xuZXhwb3J0cy5SZW5kZXJlciA9IFJlbmRlcmVyO1xuZXhwb3J0cy5hZGRBZnRlckVmZmVjdCA9IGFkZEFmdGVyRWZmZWN0O1xuZXhwb3J0cy5hZGRFZmZlY3QgPSBhZGRFZmZlY3Q7XG5leHBvcnRzLmFkZFRhaWwgPSBhZGRUYWlsO1xuZXhwb3J0cy5hcHBseVByb3BzID0gYXBwbHlQcm9wcztcbmV4cG9ydHMuY3JlYXRlUG9ydGFsID0gY3JlYXRlUG9ydGFsO1xuZXhwb3J0cy5leHRlbmQgPSBleHRlbmQ7XG5leHBvcnRzLmZvcmNlUmVzaXplID0gZm9yY2VSZXNpemU7XG5leHBvcnRzLmludmFsaWRhdGUgPSBpbnZhbGlkYXRlO1xuZXhwb3J0cy5pc09ydGhvZ3JhcGhpY0NhbWVyYSA9IGlzT3J0aG9ncmFwaGljQ2FtZXJhO1xuZXhwb3J0cy5yZW5kZXIgPSByZW5kZXI7XG5leHBvcnRzLnJlbmRlckdsID0gcmVuZGVyR2w7XG5leHBvcnRzLnN0YXRlQ29udGV4dCA9IHN0YXRlQ29udGV4dDtcbmV4cG9ydHMudW5tb3VudENvbXBvbmVudEF0Tm9kZSA9IHVubW91bnRDb21wb25lbnRBdE5vZGU7XG5leHBvcnRzLnVzZUNhbnZhcyA9IHVzZUNhbnZhcztcbmV4cG9ydHMudXNlRnJhbWUgPSB1c2VGcmFtZTtcbmV4cG9ydHMudXNlTG9hZGVyID0gdXNlTG9hZGVyO1xuZXhwb3J0cy51c2VSZXNvdXJjZSA9IHVzZVJlc291cmNlO1xuZXhwb3J0cy51c2VUaHJlZSA9IHVzZVRocmVlO1xuZXhwb3J0cy51c2VVcGRhdGUgPSB1c2VVcGRhdGU7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJfaW50ZXJvcERlZmF1bHQiLCJleCIsIl9leHRlbmRzIiwicmVxdWlyZSIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwiX2NvbnN0cnVjdCIsIlRIUkVFIiwiUmVhY3QiLCJSZWFjdF9fZGVmYXVsdCIsIlJlY29uY2lsZXIiLCJzY2hlZHVsZXIiLCJ0aW55RW1pdHRlciIsInVzZVByb21pc2UiLCJ1c2VNZWFzdXJlIiwicmVzaXplT2JzZXJ2ZXIiLCJtZXJnZVJlZnMiLCJfdG9Qcm9wZXJ0eUtleSIsImFyZyIsImtleSIsIl90b1ByaW1pdGl2ZSIsIlN0cmluZyIsImlucHV0IiwiaGludCIsInByaW0iLCJTeW1ib2wiLCJ0b1ByaW1pdGl2ZSIsInVuZGVmaW5lZCIsInJlcyIsImNhbGwiLCJUeXBlRXJyb3IiLCJOdW1iZXIiLCJyb290cyIsIk1hcCIsImVtcHR5T2JqZWN0IiwiaXMiLCJvYmoiLCJhIiwiYXJyIiwiZnVuIiwic3RyIiwibnVtIiwidW5kIiwiQXJyYXkiLCJpc0FycmF5IiwiZXF1IiwiYiIsImkiLCJjcmVhdGVTdWJzIiwiY2FsbGJhY2siLCJzdWJzIiwiaW5kZXgiLCJsZW5ndGgiLCJwdXNoIiwic3BsaWNlIiwiZ2xvYmFsRWZmZWN0cyIsImdsb2JhbEFmdGVyRWZmZWN0cyIsImdsb2JhbFRhaWxFZmZlY3RzIiwiYWRkRWZmZWN0IiwiYWRkQWZ0ZXJFZmZlY3QiLCJhZGRUYWlsIiwicmVuZGVyR2wiLCJzdGF0ZSIsInRpbWVzdGFtcCIsInJlcGVhdCIsInJ1bkdsb2JhbEVmZmVjdHMiLCJmb3JFYWNoIiwiZWZmZWN0IiwiZGVsdGEiLCJjdXJyZW50IiwiY2xvY2siLCJnZXREZWx0YSIsInN1YnNjcmliZXJzIiwic3ViIiwicmVmIiwiZnJhbWVzIiwiTWF0aCIsIm1heCIsImludmFsaWRhdGVGcmFtZWxvb3AiLCJtYW51YWwiLCJnbCIsInJlbmRlciIsInNjZW5lIiwiY2FtZXJhIiwicnVubmluZyIsInJlbmRlckxvb3AiLCJyb290IiwiY29udGFpbmVySW5mbyIsIl9fc3RhdGUiLCJhY3RpdmUiLCJyZWFkeSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImludmFsaWRhdGUiLCJ2ciIsImZvcmNlUmVzaXplIiwiY2F0YWxvZ3VlIiwiZXh0ZW5kIiwib2JqZWN0cyIsImFwcGx5UHJvcHMiLCJpbnN0YW5jZSIsIm5ld1Byb3BzIiwib2xkUHJvcHMiLCJhY2N1bXVsYXRpdmUiLCJjb250YWluZXIiLCJfX2NvbnRhaW5lciIsInNhbWVQcm9wcyIsImtleXMiLCJmaWx0ZXIiLCJoYW5kbGVycyIsInN0YXJ0c1dpdGgiLCJpbmNsdWRlcyIsImxlZnRPdmVycyIsImZpbHRlcmVkUHJvcHMiLCJjb25jYXQiLCJyZWR1Y2UiLCJhY2MiLCJwcm9wIiwiXyIsInJlc3QiLCJtYXAiLCJlbnRyaWVzIiwiX3JlZiIsIl9pbnN0YW5jZSRfX2NvbnRhaW5lciIsInRhcmdldCIsInNwbGl0Iiwic2V0IiwiX2VudHJpZXMkcmV2ZXJzZSIsInJldmVyc2UiLCJfbmFtZSIsInJldmVyc2VFbnRyaWVzIiwic2xpY2UiLCJpc0NvbG9yTWFuYWdlbWVudCIsImNvbG9yTWFuYWdlbWVudCIsImNvcHkiLCJMYXllcnMiLCJfdGFyZ2V0IiwiYXBwbHkiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJDb2xvciIsImNvbnZlcnRTUkdCVG9MaW5lYXIiLCJUZXh0dXJlIiwiZW5jb2RpbmciLCJzUkdCRW5jb2RpbmciLCJpbnZhbGlkYXRlSW5zdGFuY2UiLCJyYXljYXN0IiwiX19oYW5kbGVycyIsIl9faW50ZXJhY3Rpb24iLCJpbmRleE9mIiwiX2V4dGVuZHMyIiwiY2hhckF0IiwidG9Mb3dlckNhc2UiLCJzdWJzdHIiLCJwYXJlbnQiLCJ1cGRhdGVJbnN0YW5jZSIsIm9uVXBkYXRlIiwiY3JlYXRlSW5zdGFuY2UiLCJ0eXBlIiwiX3JlZjIiLCJob3N0Q29udGV4dCIsImludGVybmFsSW5zdGFuY2VIYW5kbGUiLCJfcmVmMiRhcmdzIiwiYXJncyIsInByb3BzIiwidG9VcHBlckNhc2UiLCJkaXNwb3NlIiwib2JqZWN0IiwiX19pbnN0YW5jZSIsImhhcyIsImZuIiwibm9kZSIsInN0YXRlTm9kZSIsIl9fb2JqZWN0cyIsImVuZHNXaXRoIiwiYXR0YWNoIiwiYXBwZW5kQ2hpbGQiLCJwYXJlbnRJbnN0YW5jZSIsImNoaWxkIiwiaXNPYmplY3QzRCIsImFkZCIsImF0dGFjaEFycmF5IiwiYXR0YWNoT2JqZWN0IiwiaW5zZXJ0QmVmb3JlIiwiYmVmb3JlQ2hpbGQiLCJkaXNwYXRjaEV2ZW50IiwicmVzdFNpYmxpbmdzIiwiY2hpbGRyZW4iLCJzaWJsaW5nIiwicmVtb3ZlUmVjdXJzaXZlIiwiYXJyYXkiLCJjbG9uZSIsInJlbW92ZUNoaWxkIiwicmVtb3ZlIiwieCIsInVuc3RhYmxlX3J1bldpdGhQcmlvcml0eSIsInVuc3RhYmxlX0lkbGVQcmlvcml0eSIsInN3aXRjaEluc3RhbmNlIiwiZmliZXIiLCJuZXdJbnN0YW5jZSIsImFsdGVybmF0ZSIsIlJlbmRlcmVyIiwibm93IiwidW5zdGFibGVfbm93Iiwid2FybnNJZk5vdEFjdGluZyIsInN1cHBvcnRzTXV0YXRpb24iLCJpc1ByaW1hcnlSZW5kZXJlciIsInNjaGVkdWxlVGltZW91dCIsInNldFRpbWVvdXQiLCJjYW5jZWxUaW1lb3V0IiwiY2xlYXJUaW1lb3V0Iiwibm9UaW1lb3V0IiwiYXBwZW5kSW5pdGlhbENoaWxkIiwiYXBwZW5kQ2hpbGRUb0NvbnRhaW5lciIsInJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciIsImluc2VydEluQ29udGFpbmVyQmVmb3JlIiwiY29tbWl0VXBkYXRlIiwidXBkYXRlUGF5bG9hZCIsIl9uZXdQcm9wcyRhcmdzIiwiYXJnc05ldyIsInJlc3ROZXciLCJfb2xkUHJvcHMkYXJncyIsImFyZ3NPbGQiLCJyZXN0T2xkIiwiaGFzTmV3QXJncyIsInNvbWUiLCJfcmVmMyIsInZhbCIsImhpZGVJbnN0YW5jZSIsInZpc2libGUiLCJ1bmhpZGVJbnN0YW5jZSIsImhpZGVUZXh0SW5zdGFuY2UiLCJFcnJvciIsImdldFB1YmxpY0luc3RhbmNlIiwiZ2V0Um9vdEhvc3RDb250ZXh0IiwiZ2V0Q2hpbGRIb3N0Q29udGV4dCIsImNyZWF0ZVRleHRJbnN0YW5jZSIsImZpbmFsaXplSW5pdGlhbENoaWxkcmVuIiwicHJlcGFyZVVwZGF0ZSIsInNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWUiLCJwcmVwYXJlRm9yQ29tbWl0IiwicmVzZXRBZnRlckNvbW1pdCIsInNob3VsZFNldFRleHRDb250ZW50IiwiaGFzU3ltYm9sIiwiUkVBQ1RfUE9SVEFMX1RZUEUiLCJlbGVtZW50IiwiZ2V0IiwibmV3Um9vdCIsImNyZWF0ZUNvbnRhaW5lciIsImNvbmN1cnJlbnQiLCJ1cGRhdGVDb250YWluZXIiLCJnZXRQdWJsaWNSb290SW5zdGFuY2UiLCJ1bm1vdW50Q29tcG9uZW50QXROb2RlIiwiY3JlYXRlUG9ydGFsIiwiaW1wbGVtZW50YXRpb24iLCIkJHR5cGVvZiIsImluamVjdEludG9EZXZUb29scyIsImJ1bmRsZVR5cGUiLCJwcm9jZXNzIiwiZmluZEhvc3RJbnN0YW5jZUJ5RmliZXIiLCJ2ZXJzaW9uIiwicmVuZGVyZXJQYWNrYWdlTmFtZSIsIl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UiLCJvIiwiYWxsb3dBcnJheUxpa2UiLCJpdCIsIml0ZXJhdG9yIiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiZG9uZSIsIm5leHQiLCJiaW5kIiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJuIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJmcm9tIiwidGVzdCIsImxlbiIsImFycjIiLCJpc09ydGhvZ3JhcGhpY0NhbWVyYSIsImRlZiIsIm1ha2VJZCIsImV2ZW50IiwiZXZlbnRPYmplY3QiLCJ1dWlkIiwic3RhdGVDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNhbnZhcyIsIm9ydGhvZ3JhcGhpYyIsInJheWNhc3RlciIsInNpemUiLCJwaXhlbFJhdGlvIiwiX3Byb3BzJHZyIiwiX3Byb3BzJGNvbmN1cnJlbnQiLCJfcHJvcHMkc2hhZG93TWFwIiwic2hhZG93TWFwIiwiX3Byb3BzJGNvbG9yTWFuYWdlbWVuIiwiX3Byb3BzJGludmFsaWRhdGVGcmFtIiwiX3Byb3BzJHVwZGF0ZURlZmF1bHRDIiwidXBkYXRlRGVmYXVsdENhbWVyYSIsIl9wcm9wcyRub0V2ZW50cyIsIm5vRXZlbnRzIiwib25DcmVhdGVkIiwib25Qb2ludGVyTWlzc2VkIiwiX3VzZVN0YXRlIiwidXNlU3RhdGUiLCJzZXRSZWFkeSIsIl91c2VTdGF0ZTIiLCJWZWN0b3IyIiwibW91c2UiLCJfdXNlU3RhdGUzIiwicmF5IiwiUmF5Y2FzdGVyIiwicmF5Y2FzdGVyUHJvcHMiLCJkZWZhdWx0UmF5Y2FzdGVyIiwiX3VzZVN0YXRlNCIsIlNjZW5lIiwiZGVmYXVsdFNjZW5lIiwiX3VzZVN0YXRlNSIsImNhbSIsIk9ydGhvZ3JhcGhpY0NhbWVyYSIsIlBlcnNwZWN0aXZlQ2FtZXJhIiwicG9zaXRpb24iLCJ6IiwibG9va0F0IiwiZGVmYXVsdENhbSIsIl9zZXREZWZhdWx0Q2FtZXJhIiwiX3VzZVN0YXRlNiIsIkNsb2NrIiwidXNlUmVmIiwiYXNwZWN0Iiwidmlld3BvcnQiLCJpbml0aWFsQ2xpY2siLCJpbml0aWFsSGl0cyIsInBvaW50ZXIiLCJUaW55RW1pdHRlciIsImNhcHR1cmVkIiwiZXZlbnRzIiwic3Vic2NyaWJlIiwicHJpb3JpdHkiLCJzb3J0IiwicyIsInNldERlZmF1bHRDYW1lcmEiLCJpbnZhbGlkYXRlJDEiLCJpbnRlcnNlY3QiLCJwcmVwYXJlIiwiaGFuZGxlUG9pbnRlck1vdmUiLCJnZXRDdXJyZW50Vmlld3BvcnQiLCJ1c2VDYWxsYmFjayIsIlZlY3RvcjMiLCJfc3RhdGUkY3VycmVudCRzaXplIiwid2lkdGgiLCJoZWlnaHQiLCJkaXN0YW5jZSIsImRpc3RhbmNlVG8iLCJ6b29tIiwiZmFjdG9yIiwiZm92IiwiUEkiLCJoIiwidGFuIiwidyIsInVzZU1lbW8iLCJhc3NpZ24iLCJsZWZ0IiwicmlnaHQiLCJ0b3AiLCJib3R0b20iLCJ1cGRhdGVQcm9qZWN0aW9uTWF0cml4IiwidXBkYXRlTWF0cml4V29ybGQiLCJzZXRTaXplIiwicHJlcGFyZVJheSIsImNsaWVudFgiLCJjbGllbnRZIiwiX3N0YXRlJGN1cnJlbnQkc2l6ZTIiLCJzZXRGcm9tQ2FtZXJhIiwic2VlbiIsIlNldCIsImhpdHMiLCJldmVudHNPYmplY3RzIiwiaW50ZXJzZWN0cyIsImludGVyc2VjdE9iamVjdHMiLCJpdGVtIiwiaWQiLCJzaGFyZWRTdGF0ZSIsIl9pdGVyYXRvciIsIl9zdGVwIiwiX2ludGVyc2VjdCIsImNhbGN1bGF0ZURpc3RhbmNlIiwiZHgiLCJkeSIsInJvdW5kIiwic3FydCIsImhvdmVyZWQiLCJ0ZW1wIiwiaGFuZGxlSW50ZXJzZWN0cyIsImludGVyc2VjdGlvbnMiLCJmaW5kIiwiaGl0IiwidW5wcm9qZWN0ZWRQb2ludCIsInkiLCJ1bnByb2plY3QiLCJyZWxlYXNlUG9pbnRlckNhcHR1cmUiLCJsb2NhbFN0YXRlIiwic3RvcHBlZCIsIl9sb29wIiwiX3N0ZXAyIiwic2V0UG9pbnRlckNhcHR1cmUiLCJyYXljYXN0RXZlbnQiLCJzdG9wUHJvcGFnYXRpb24iLCJjdXJyZW50VGFyZ2V0Iiwic291cmNlRXZlbnQiLCJ2YWx1ZXMiLCJoYW5kbGVQb2ludGVyQ2FuY2VsIiwiX2l0ZXJhdG9yMiIsIl9yZXQiLCJlbWl0IiwiZGF0YSIsInBvaW50ZXJNb3ZlIiwicG9pbnRlck92ZXIiLCJwb2ludGVyRW50ZXIiLCJwb2ludGVyT3V0IiwicG9pbnRlckxlYXZlIiwiaG92ZXJlZEl0ZW0iLCJoYW5kbGVQb2ludGVyIiwib25DbGljayIsIm9uQ29udGV4dE1lbnUiLCJvbkRvdWJsZUNsaWNrIiwib25XaGVlbCIsIm9uUG9pbnRlckRvd24iLCJvblBvaW50ZXJVcCIsIm9uUG9pbnRlckxlYXZlIiwiZSIsIm9uUG9pbnRlck1vdmUiLCJvbkdvdFBvaW50ZXJDYXB0dXJlTGVnYWN5Iiwib25Mb3N0UG9pbnRlckNhcHR1cmUiLCJfc3RhdGUkY3VycmVudCIsInVzZUxheW91dEVmZmVjdCIsInNldFBpeGVsUmF0aW8iLCJlbmFibGVkIiwiUENGU29mdFNoYWRvd01hcCIsInRvbmVNYXBwaW5nIiwiQUNFU0ZpbG1pY1RvbmVNYXBwaW5nIiwib3V0cHV0RW5jb2RpbmciLCJDYW52YXMiLCJhY3RpdmF0ZSIsInVzZUVmZmVjdCIsInJlc3VsdCIsInRoZW4iLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCJ4ciIsInNldEFuaW1hdGlvbkxvb3AiLCJ0IiwiY29uc29sZSIsIndhcm4iLCJyZW5kZXJMaXN0cyIsImZvcmNlQ29udGV4dExvc3MiLCJwIiwidXNlQ29udGV4dCIsImNvbnRleHQiLCJ1c2VGcmFtZSIsInJlbmRlclByaW9yaXR5IiwiX3VzZUNvbnRleHQiLCJ1bnN1YnNjcmliZSIsInVzZVRocmVlIiwidXNlVXBkYXRlIiwiZGVwZW5kZW50cyIsIm9wdGlvbmFsUmVmIiwiX3VzZUNvbnRleHQyIiwibG9jYWxSZWYiLCJ1c2VSZXNvdXJjZSIsImZvcmNlVXBkYXRlIiwidXNlTG9hZGVyIiwiUHJvdG8iLCJ1cmwiLCJleHRlbnNpb25zIiwib25Qcm9ncmVzcyIsImxvYWRlciIsInJlc3VsdHMiLCJ1cmxBcnJheSIsIlByb21pc2UiLCJhbGwiLCJyZWplY3QiLCJsb2FkIiwibm9kZXMiLCJtYXRlcmlhbHMiLCJ0cmF2ZXJzZSIsIm1hdGVyaWFsIiwiZXJyb3IiLCJtZXNzYWdlIiwiZGVmYXVsdFN0eWxlcyIsIm92ZXJmbG93IiwiQ29udGVudCIsInNldEV2ZW50cyIsInJlbmRlcmVyIiwiZWZmZWN0cyIsIlJlc2l6ZUNvbnRhaW5lciIsIm1lbW8iLCJnbDIiLCJwcmVSZW5kZXIiLCJyZXNpemUiLCJzdHlsZSIsInJlc3RTcHJlYWQiLCJjb250YWluZXJSZWYiLCJfdXNlU3RhdGUyJCIsIl91c2VNZWFzdXJlIiwic2Nyb2xsIiwiZGVib3VuY2UiLCJwb2x5ZmlsbCIsIndpbmRvdyIsIlJlc2l6ZU9ic2VydmVyIiwicmVhZHlGbGFnIiwiY2FudmFzUmVmIiwicGFyYW1zIiwiYW50aWFsaWFzIiwiYWxwaGEiLCJXZWJHTFJlbmRlcmVyIiwicG93ZXJQcmVmZXJlbmNlIiwiY2FudmFzIiwiZ2V0Q29udGV4dCIsImRpc3BsYXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-three-fiber/web.cjs.js\n'
      );

      /***/
    },
};
