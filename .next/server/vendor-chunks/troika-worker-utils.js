/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/troika-worker-utils";
exports.ids = ["vendor-chunks/troika-worker-utils"];
exports.modules = {
  /***/ "(ssr)/./node_modules/troika-worker-utils/dist/troika-worker-utils.umd.js":
    /*!**************************************************************************!*\
  !*** ./node_modules/troika-worker-utils/dist/troika-worker-utils.umd.js ***!
  \**************************************************************************/
    /***/ function (__unused_webpack_module, exports) {
      eval(
        "(function (global, factory) {\n   true ? factory(exports) :\n  0;\n}(this, (function (exports) { 'use strict';\n\n  /**\n   * Lightweight thenable implementation that is entirely self-contained within a single\n   * function with no external dependencies so it can be easily shipped across to a WorkerModule.\n   *\n   * This implementation conforms fully to the Promises/A+ spec so it can safely interoperate\n   * with other thenable implementations. https://github.com/promises-aplus/promises-spec\n   *\n   * *However*, it is _not_ a full implementation of ES2015 Promises, e.g. it does not\n   * have the same constructor signature and does not expose a `catch` method or the static\n   * `resolve`/`reject`/`all`/`race` initializer methods. If you need to hand a Thenable\n   * instance off to consuming code that may expect a true Promise, you'll want to wrap it\n   * in a native-or-polyfilled Promise first.\n   *\n   * (Why yet another Promises/A+ implementation? Great question. We needed a polyfill-like\n   * thing that was (a) wrapped in a single function for easy serialization across to a Worker,\n   * and (b) was as small as possible -- at ~900B minified (~500B gzipped) this is the smallest\n   * implementation I've found. And also, exercises like this are challenging and fun.)\n   */\n  function BespokeThenable() {\n    var state = 0; // 0=pending, 1=fulfilled, -1=rejected\n    var queue = [];\n    var value;\n    var scheduled = 0;\n    var completeCalled = 0;\n\n    function then(onResolve, onReject) {\n      var nextThenable = BespokeThenable();\n\n      function handleNext() {\n        var cb = state > 0 ? onResolve : onReject;\n        if (isFn(cb)) {\n          try {\n            var result = cb(value);\n            if (result === nextThenable) {\n              recursiveError();\n            }\n            var resultThen = getThenableThen(result);\n            if (resultThen) {\n              resultThen.call(result, nextThenable.resolve, nextThenable.reject);\n            } else {\n              nextThenable.resolve(result);\n            }\n          } catch (err) {\n            nextThenable.reject(err);\n          }\n        } else {\n          nextThenable[state > 0 ? 'resolve' : 'reject'](value);\n        }\n      }\n\n      queue.push(handleNext);\n      if (state) {\n        scheduleQueueFlush();\n      }\n      return nextThenable\n    }\n\n    var resolve = oneTime(function (val) {\n      if (!completeCalled) {\n        complete(1, val);\n      }\n    });\n\n    var reject = oneTime(function (reason) {\n      if (!completeCalled) {\n        complete(-1, reason);\n      }\n    });\n\n    function complete(st, val) {\n      completeCalled++;\n      var ignoreThrow = 0;\n      try {\n        if (val === thenableObj) {\n          recursiveError();\n        }\n        var valThen = st > 0 && getThenableThen(val);\n        if (valThen) {\n          valThen.call(val, oneTime(function (v) {\n            ignoreThrow++;\n            complete(1, v);\n          }), oneTime(function (v) {\n            ignoreThrow++;\n            complete(-1, v);\n          }));\n        } else {\n          state = st;\n          value = val;\n          scheduleQueueFlush();\n        }\n      } catch(e) {\n        if (!state && !ignoreThrow) {\n          complete(-1, e);\n        }\n      }\n    }\n\n    function scheduleQueueFlush() {\n      if (!scheduled) {\n        setTimeout(flushQueue, 0); //TODO setImmediate or postMessage approach if available?\n        scheduled = 1;\n      }\n    }\n\n    function flushQueue() {\n      var q = queue;\n      scheduled = 0;\n      queue = [];\n      q.forEach(callIt);\n    }\n\n    function callIt(fn) {\n      fn();\n    }\n\n    function getThenableThen(val) {\n      var valThen = val && (isFn(val) || typeof val === 'object') && val.then;\n      return isFn(valThen) && valThen\n    }\n\n    function oneTime(fn) {\n      var called = 0;\n      return function() {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        if (!called++) {\n          fn.apply(this, args);\n        }\n      }\n    }\n\n    function recursiveError() {\n      throw new TypeError('Chaining cycle detected')\n    }\n\n    var isFn = function (v) { return typeof v === 'function'; };\n\n    var thenableObj = {\n      then: then,\n      resolve: resolve,\n      reject: reject\n    };\n    return thenableObj\n  }\n\n\n  /**\n   * Thenable implementation that uses a native Promise under the covers. This implementation\n   * is preferred if Promise is available, for better performance and dev tools integration.\n   * @constructor\n   */\n  function NativePromiseThenable() {\n    var resolve, reject;\n    var promise = new Promise(function (res, rej) {\n      resolve = res;\n      reject = rej;\n    });\n    return {\n      then: promise.then.bind(promise),\n      resolve: resolve,\n      reject: reject\n    }\n  }\n\n  /**\n   * Promise.all() impl:\n   */\n  BespokeThenable.all = NativePromiseThenable.all = function(items) {\n    var resultCount = 0;\n    var results = [];\n    var out = DefaultThenable();\n    if (items.length === 0) {\n      out.resolve([]);\n    } else {\n      items.forEach(function (item, i) {\n        var itemThenable = DefaultThenable();\n        itemThenable.resolve(item);\n        itemThenable.then(function (res) {\n          resultCount++;\n          results[i] = res;\n          if (resultCount === items.length) {\n            out.resolve(results);\n          }\n        }, out.reject);\n      });\n    }\n    return out\n  };\n\n\n  /**\n   * Choose the best Thenable implementation and export it as the default.\n   */\n  var DefaultThenable = typeof Promise === 'function' ? NativePromiseThenable : BespokeThenable;\n\n  /**\n   * Main content for the worker that handles the loading and execution of\n   * modules within it.\n   */\n  function workerBootstrap() {\n    var modules = Object.create(null);\n\n    // Handle messages for registering a module\n    function registerModule(ref, callback) {\n      var id = ref.id;\n      var name = ref.name;\n      var dependencies = ref.dependencies; if ( dependencies === void 0 ) dependencies = [];\n      var init = ref.init; if ( init === void 0 ) init = function(){};\n      var getTransferables = ref.getTransferables; if ( getTransferables === void 0 ) getTransferables = null;\n\n      // Only register once\n      if (modules[id]) { return }\n\n      try {\n        // If any dependencies are modules, ensure they're registered and grab their value\n        dependencies = dependencies.map(function (dep) {\n          if (dep && dep.isWorkerModule) {\n            registerModule(dep, function (depResult) {\n              if (depResult instanceof Error) { throw depResult }\n            });\n            dep = modules[dep.id].value;\n          }\n          return dep\n        });\n\n        // Rehydrate functions\n        init = rehydrate((\"<\" + name + \">.init\"), init);\n        if (getTransferables) {\n          getTransferables = rehydrate((\"<\" + name + \">.getTransferables\"), getTransferables);\n        }\n\n        // Initialize the module and store its value\n        var value = null;\n        if (typeof init === 'function') {\n          value = init.apply(void 0, dependencies);\n        } else {\n          console.error('worker module init function failed to rehydrate');\n        }\n        modules[id] = {\n          id: id,\n          value: value,\n          getTransferables: getTransferables\n        };\n        callback(value);\n      } catch(err) {\n        if (!(err && err.noLog)) {\n          console.error(err);\n        }\n        callback(err);\n      }\n    }\n\n    // Handle messages for calling a registered module's result function\n    function callModule(ref, callback) {\n      var ref$1;\n\n      var id = ref.id;\n      var args = ref.args;\n      if (!modules[id] || typeof modules[id].value !== 'function') {\n        callback(new Error((\"Worker module \" + id + \": not found or its 'init' did not return a function\")));\n      }\n      try {\n        var result = (ref$1 = modules[id]).value.apply(ref$1, args);\n        if (result && typeof result.then === 'function') {\n          result.then(handleResult, function (rej) { return callback(rej instanceof Error ? rej : new Error('' + rej)); });\n        } else {\n          handleResult(result);\n        }\n      } catch(err) {\n        callback(err);\n      }\n      function handleResult(result) {\n        try {\n          var tx = modules[id].getTransferables && modules[id].getTransferables(result);\n          if (!tx || !Array.isArray(tx) || !tx.length) {\n            tx = undefined; //postMessage is very picky about not passing null or empty transferables\n          }\n          callback(result, tx);\n        } catch(err) {\n          console.error(err);\n          callback(err);\n        }\n      }\n    }\n\n    function rehydrate(name, str) {\n      var result = void 0;\n      self.troikaDefine = function (r) { return result = r; };\n      var url = URL.createObjectURL(\n        new Blob(\n          [(\"/** \" + (name.replace(/\\*/g, '')) + \" **/\\n\\ntroikaDefine(\\n\" + str + \"\\n)\")],\n          {type: 'application/javascript'}\n        )\n      );\n      try {\n        importScripts(url);\n      } catch(err) {\n        console.error(err);\n      }\n      URL.revokeObjectURL(url);\n      delete self.troikaDefine;\n      return result\n    }\n\n    // Handler for all messages within the worker\n    self.addEventListener('message', function (e) {\n      var ref = e.data;\n      var messageId = ref.messageId;\n      var action = ref.action;\n      var data = ref.data;\n      try {\n        // Module registration\n        if (action === 'registerModule') {\n          registerModule(data, function (result) {\n            if (result instanceof Error) {\n              postMessage({\n                messageId: messageId,\n                success: false,\n                error: result.message\n              });\n            } else {\n              postMessage({\n                messageId: messageId,\n                success: true,\n                result: {isCallable: typeof result === 'function'}\n              });\n            }\n          });\n        }\n        // Invocation\n        if (action === 'callModule') {\n          callModule(data, function (result, transferables) {\n            if (result instanceof Error) {\n              postMessage({\n                messageId: messageId,\n                success: false,\n                error: result.message\n              });\n            } else {\n              postMessage({\n                messageId: messageId,\n                success: true,\n                result: result\n              }, transferables || undefined);\n            }\n          });\n        }\n      } catch(err) {\n        postMessage({\n          messageId: messageId,\n          success: false,\n          error: err.stack\n        });\n      }\n    });\n  }\n\n  /**\n   * Fallback for `defineWorkerModule` that behaves identically but runs in the main\n   * thread, for when the execution environment doesn't support web workers or they\n   * are disallowed due to e.g. CSP security restrictions.\n   */\n  function defineMainThreadModule(options) {\n    var moduleFunc = function() {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      return moduleFunc._getInitResult().then(function (initResult) {\n        if (typeof initResult === 'function') {\n          return initResult.apply(void 0, args)\n        } else {\n          throw new Error('Worker module function was called but `init` did not return a callable function')\n        }\n      })\n    };\n    moduleFunc._getInitResult = function() {\n      // We can ignore getTransferables in main thread. TODO workerId?\n      var dependencies = options.dependencies;\n      var init = options.init;\n\n      // Resolve dependencies\n      dependencies = Array.isArray(dependencies) ? dependencies.map(function (dep) { return dep && dep._getInitResult ? dep._getInitResult() : dep; }\n      ) : [];\n\n      // Invoke init with the resolved dependencies\n      var initThenable = DefaultThenable.all(dependencies).then(function (deps) {\n        return init.apply(null, deps)\n      });\n\n      // Cache the resolved promise for subsequent calls\n      moduleFunc._getInitResult = function () { return initThenable; };\n\n      return initThenable\n    };\n    return moduleFunc\n  }\n\n  var supportsWorkers = function () {\n    var supported = false;\n\n    // Only attempt worker initialization in browsers; elsewhere it would just be\n    // noise e.g. loading into a Node environment for SSR.\n    if (typeof window !== 'undefined' && typeof window.document !== 'undefined') {\n      try {\n        // TODO additional checks for things like importScripts within the worker?\n        //  Would need to be an async check.\n        var worker = new Worker(\n          URL.createObjectURL(\n            new Blob([''], { type: 'application/javascript' })\n          )\n        );\n        worker.terminate();\n        supported = true;\n      } catch (err) {\n        console.log((\"Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [\" + (err.message) + \"]\"));\n      }\n    }\n\n    // Cached result\n    supportsWorkers = function () { return supported; };\n    return supported\n  };\n\n  var _workerModuleId = 0;\n  var _messageId = 0;\n  var _allowInitAsString = false;\n  var workers = Object.create(null);\n  var openRequests = Object.create(null);\n  openRequests._count = 0;\n\n\n  /**\n   * Define a module of code that will be executed with a web worker. This provides a simple\n   * interface for moving chunks of logic off the main thread, and managing their dependencies\n   * among one another.\n   *\n   * @param {object} options\n   * @param {function} options.init - The main function that initializes the module. This will be run\n   *        within the worker, and will be passed the resolved dependencies as arguments. Its\n   *        return value becomes the module's content, which can then be used by other modules\n   *        that depend on it. This function can perform any logic using those dependencies, but\n   *        must not depend on anything from its parent closures.\n   * @param {array} [options.dependencies] - Provides any dependencies required by the init function:\n   *        - Primitives like strings, numbers, booleans\n   *        - Raw functions; these will be stringified and rehydrated within the worker so they\n   *          must not depend on anything from their parent closures\n   *        - Other worker modules; these will be resolved within the worker, and therefore modules\n   *          that provide functions can be called without having to cross the worker/main thread\n   *          boundary.\n   * @param {function} [options.getTransferables] - An optional function that will be run in the worker\n   *        just before posting the response value from a module call back to the main thread.\n   *        It will be passed that response value, and if it returns an array then that will be\n   *        used as the \"transferables\" parameter to `postMessage`. Use this if there are values\n   *        in the response that can/should be transfered rather than cloned.\n   * @param {string} [options.name] - A descriptive name for this module; this can be useful for\n   *        debugging but is not currently used for anything else.\n   * @param {string} [options.workerId] - By default all modules will run in the same dedicated worker,\n   *        but if you want to use multiple workers you can pass a `workerId` to indicate a specific\n   *        worker to spawn. Note that each worker is completely standalone and no data or state will\n   *        be shared between them. If a worker module is used as a dependency by worker modules\n   *        using different `workerId`s, then that dependency will be re-registered in each worker.\n   * @return {function(...[*]): {then}}\n   */\n  function defineWorkerModule(options) {\n    if ((!options || typeof options.init !== 'function') && !_allowInitAsString) {\n      throw new Error('requires `options.init` function')\n    }\n    var dependencies = options.dependencies;\n    var init = options.init;\n    var getTransferables = options.getTransferables;\n    var workerId = options.workerId;\n\n    if (!supportsWorkers()) {\n      return defineMainThreadModule(options)\n    }\n\n    if (workerId == null) {\n      workerId = '#default';\n    }\n    var id = \"workerModule\" + (++_workerModuleId);\n    var name = options.name || id;\n    var registrationThenable = null;\n\n    dependencies = dependencies && dependencies.map(function (dep) {\n      // Wrap raw functions as worker modules with no dependencies\n      if (typeof dep === 'function' && !dep.workerModuleData) {\n        _allowInitAsString = true;\n        dep = defineWorkerModule({\n          workerId: workerId,\n          name: (\"<\" + name + \"> function dependency: \" + (dep.name)),\n          init: (\"function(){return (\\n\" + (stringifyFunction(dep)) + \"\\n)}\")\n        });\n        _allowInitAsString = false;\n      }\n      // Grab postable data for worker modules\n      if (dep && dep.workerModuleData) {\n        dep = dep.workerModuleData;\n      }\n      return dep\n    });\n\n    function moduleFunc() {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      // Register this module if needed\n      if (!registrationThenable) {\n        registrationThenable = callWorker(workerId,'registerModule', moduleFunc.workerModuleData);\n      }\n\n      // Invoke the module, returning a thenable\n      return registrationThenable.then(function (ref) {\n        var isCallable = ref.isCallable;\n\n        if (isCallable) {\n          return callWorker(workerId,'callModule', {id: id, args: args})\n        } else {\n          throw new Error('Worker module function was called but `init` did not return a callable function')\n        }\n      })\n    }\n    moduleFunc.workerModuleData = {\n      isWorkerModule: true,\n      id: id,\n      name: name,\n      dependencies: dependencies,\n      init: stringifyFunction(init),\n      getTransferables: getTransferables && stringifyFunction(getTransferables)\n    };\n    return moduleFunc\n  }\n\n  /**\n   * Stringifies a function into a form that can be deserialized in the worker\n   * @param fn\n   */\n  function stringifyFunction(fn) {\n    var str = fn.toString();\n    // If it was defined in object method/property format, it needs to be modified\n    if (!/^function/.test(str) && /^\\w+\\s*\\(/.test(str)) {\n      str = 'function ' + str;\n    }\n    return str\n  }\n\n\n  function getWorker(workerId) {\n    var worker = workers[workerId];\n    if (!worker) {\n      // Bootstrap the worker's content\n      var bootstrap = stringifyFunction(workerBootstrap);\n\n      // Create the worker from the bootstrap function content\n      worker = workers[workerId] = new Worker(\n        URL.createObjectURL(\n          new Blob(\n            [(\"/** Worker Module Bootstrap: \" + (workerId.replace(/\\*/g, '')) + \" **/\\n\\n;(\" + bootstrap + \")()\")],\n            {type: 'application/javascript'}\n          )\n        )\n      );\n\n      // Single handler for response messages from the worker\n      worker.onmessage = function (e) {\n        var response = e.data;\n        var msgId = response.messageId;\n        var callback = openRequests[msgId];\n        if (!callback) {\n          throw new Error('WorkerModule response with empty or unknown messageId')\n        }\n        delete openRequests[msgId];\n        openRequests.count--;\n        callback(response);\n      };\n    }\n    return worker\n  }\n\n  // Issue a call to the worker with a callback to handle the response\n  function callWorker(workerId, action, data) {\n    var thenable = DefaultThenable();\n    var messageId = ++_messageId;\n    openRequests[messageId] = function (response) {\n      if (response.success) {\n        thenable.resolve(response.result);\n      } else {\n        thenable.reject(new Error((\"Error in worker \" + action + \" call: \" + (response.error))));\n      }\n    };\n    openRequests._count++;\n    if (openRequests.count > 1000) { //detect leaks\n      console.warn('Large number of open WorkerModule requests, some may not be returning');\n    }\n    getWorker(workerId).postMessage({\n      messageId: messageId,\n      action: action,\n      data: data\n    });\n    return thenable\n  }\n\n  /**\n   * Just the {@link Thenable} function wrapped as a worker module. If another worker\n   * module needs Thenable as a dependency, it's better to pass this module rather than\n   * the raw function in its `dependencies` array so it only gets registered once.\n   */\n  var ThenableWorkerModule = defineWorkerModule({\n    name: 'Thenable',\n    dependencies: [DefaultThenable],\n    init: function(Thenable) {\n      return Thenable\n    }\n  });\n\n  exports.Thenable = DefaultThenable;\n  exports.ThenableWorkerModule = ThenableWorkerModule;\n  exports.defineWorkerModule = defineWorkerModule;\n  exports.stringifyFunction = stringifyFunction;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHJvaWthLXdvcmtlci11dGlscy9kaXN0L3Ryb2lrYS13b3JrZXItdXRpbHMudW1kLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsRUFBRSxLQUE0RDtBQUM5RCxFQUFFLENBQ21FO0FBQ3JFLENBQUMsNkJBQTZCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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LENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vYS1wcm9qLWNhbm5vbi1sb2wvLi9ub2RlX21vZHVsZXMvdHJvaWthLXdvcmtlci11dGlscy9kaXN0L3Ryb2lrYS13b3JrZXItdXRpbHMudW1kLmpzPzlhNDYiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLnRyb2lrYV93b3JrZXJfdXRpbHMgPSB7fSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBMaWdodHdlaWdodCB0aGVuYWJsZSBpbXBsZW1lbnRhdGlvbiB0aGF0IGlzIGVudGlyZWx5IHNlbGYtY29udGFpbmVkIHdpdGhpbiBhIHNpbmdsZVxuICAgKiBmdW5jdGlvbiB3aXRoIG5vIGV4dGVybmFsIGRlcGVuZGVuY2llcyBzbyBpdCBjYW4gYmUgZWFzaWx5IHNoaXBwZWQgYWNyb3NzIHRvIGEgV29ya2VyTW9kdWxlLlxuICAgKlxuICAgKiBUaGlzIGltcGxlbWVudGF0aW9uIGNvbmZvcm1zIGZ1bGx5IHRvIHRoZSBQcm9taXNlcy9BKyBzcGVjIHNvIGl0IGNhbiBzYWZlbHkgaW50ZXJvcGVyYXRlXG4gICAqIHdpdGggb3RoZXIgdGhlbmFibGUgaW1wbGVtZW50YXRpb25zLiBodHRwczovL2dpdGh1Yi5jb20vcHJvbWlzZXMtYXBsdXMvcHJvbWlzZXMtc3BlY1xuICAgKlxuICAgKiAqSG93ZXZlciosIGl0IGlzIF9ub3RfIGEgZnVsbCBpbXBsZW1lbnRhdGlvbiBvZiBFUzIwMTUgUHJvbWlzZXMsIGUuZy4gaXQgZG9lcyBub3RcbiAgICogaGF2ZSB0aGUgc2FtZSBjb25zdHJ1Y3RvciBzaWduYXR1cmUgYW5kIGRvZXMgbm90IGV4cG9zZSBhIGBjYXRjaGAgbWV0aG9kIG9yIHRoZSBzdGF0aWNcbiAgICogYHJlc29sdmVgL2ByZWplY3RgL2BhbGxgL2ByYWNlYCBpbml0aWFsaXplciBtZXRob2RzLiBJZiB5b3UgbmVlZCB0byBoYW5kIGEgVGhlbmFibGVcbiAgICogaW5zdGFuY2Ugb2ZmIHRvIGNvbnN1bWluZyBjb2RlIHRoYXQgbWF5IGV4cGVjdCBhIHRydWUgUHJvbWlzZSwgeW91J2xsIHdhbnQgdG8gd3JhcCBpdFxuICAgKiBpbiBhIG5hdGl2ZS1vci1wb2x5ZmlsbGVkIFByb21pc2UgZmlyc3QuXG4gICAqXG4gICAqIChXaHkgeWV0IGFub3RoZXIgUHJvbWlzZXMvQSsgaW1wbGVtZW50YXRpb24/IEdyZWF0IHF1ZXN0aW9uLiBXZSBuZWVkZWQgYSBwb2x5ZmlsbC1saWtlXG4gICAqIHRoaW5nIHRoYXQgd2FzIChhKSB3cmFwcGVkIGluIGEgc2luZ2xlIGZ1bmN0aW9uIGZvciBlYXN5IHNlcmlhbGl6YXRpb24gYWNyb3NzIHRvIGEgV29ya2VyLFxuICAgKiBhbmQgKGIpIHdhcyBhcyBzbWFsbCBhcyBwb3NzaWJsZSAtLSBhdCB+OTAwQiBtaW5pZmllZCAofjUwMEIgZ3ppcHBlZCkgdGhpcyBpcyB0aGUgc21hbGxlc3RcbiAgICogaW1wbGVtZW50YXRpb24gSSd2ZSBmb3VuZC4gQW5kIGFsc28sIGV4ZXJjaXNlcyBsaWtlIHRoaXMgYXJlIGNoYWxsZW5naW5nIGFuZCBmdW4uKVxuICAgKi9cbiAgZnVuY3Rpb24gQmVzcG9rZVRoZW5hYmxlKCkge1xuICAgIHZhciBzdGF0ZSA9IDA7IC8vIDA9cGVuZGluZywgMT1mdWxmaWxsZWQsIC0xPXJlamVjdGVkXG4gICAgdmFyIHF1ZXVlID0gW107XG4gICAgdmFyIHZhbHVlO1xuICAgIHZhciBzY2hlZHVsZWQgPSAwO1xuICAgIHZhciBjb21wbGV0ZUNhbGxlZCA9IDA7XG5cbiAgICBmdW5jdGlvbiB0aGVuKG9uUmVzb2x2ZSwgb25SZWplY3QpIHtcbiAgICAgIHZhciBuZXh0VGhlbmFibGUgPSBCZXNwb2tlVGhlbmFibGUoKTtcblxuICAgICAgZnVuY3Rpb24gaGFuZGxlTmV4dCgpIHtcbiAgICAgICAgdmFyIGNiID0gc3RhdGUgPiAwID8gb25SZXNvbHZlIDogb25SZWplY3Q7XG4gICAgICAgIGlmIChpc0ZuKGNiKSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gY2IodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbmV4dFRoZW5hYmxlKSB7XG4gICAgICAgICAgICAgIHJlY3Vyc2l2ZUVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0VGhlbiA9IGdldFRoZW5hYmxlVGhlbihyZXN1bHQpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdFRoZW4pIHtcbiAgICAgICAgICAgICAgcmVzdWx0VGhlbi5jYWxsKHJlc3VsdCwgbmV4dFRoZW5hYmxlLnJlc29sdmUsIG5leHRUaGVuYWJsZS5yZWplY3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV4dFRoZW5hYmxlLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIG5leHRUaGVuYWJsZS5yZWplY3QoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dFRoZW5hYmxlW3N0YXRlID4gMCA/ICdyZXNvbHZlJyA6ICdyZWplY3QnXSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcXVldWUucHVzaChoYW5kbGVOZXh0KTtcbiAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICBzY2hlZHVsZVF1ZXVlRmx1c2goKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXh0VGhlbmFibGVcbiAgICB9XG5cbiAgICB2YXIgcmVzb2x2ZSA9IG9uZVRpbWUoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgaWYgKCFjb21wbGV0ZUNhbGxlZCkge1xuICAgICAgICBjb21wbGV0ZSgxLCB2YWwpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlamVjdCA9IG9uZVRpbWUoZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgaWYgKCFjb21wbGV0ZUNhbGxlZCkge1xuICAgICAgICBjb21wbGV0ZSgtMSwgcmVhc29uKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlKHN0LCB2YWwpIHtcbiAgICAgIGNvbXBsZXRlQ2FsbGVkKys7XG4gICAgICB2YXIgaWdub3JlVGhyb3cgPSAwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHZhbCA9PT0gdGhlbmFibGVPYmopIHtcbiAgICAgICAgICByZWN1cnNpdmVFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWxUaGVuID0gc3QgPiAwICYmIGdldFRoZW5hYmxlVGhlbih2YWwpO1xuICAgICAgICBpZiAodmFsVGhlbikge1xuICAgICAgICAgIHZhbFRoZW4uY2FsbCh2YWwsIG9uZVRpbWUoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIGlnbm9yZVRocm93Kys7XG4gICAgICAgICAgICBjb21wbGV0ZSgxLCB2KTtcbiAgICAgICAgICB9KSwgb25lVGltZShmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgaWdub3JlVGhyb3crKztcbiAgICAgICAgICAgIGNvbXBsZXRlKC0xLCB2KTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUgPSBzdDtcbiAgICAgICAgICB2YWx1ZSA9IHZhbDtcbiAgICAgICAgICBzY2hlZHVsZVF1ZXVlRmx1c2goKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGlmICghc3RhdGUgJiYgIWlnbm9yZVRocm93KSB7XG4gICAgICAgICAgY29tcGxldGUoLTEsIGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVRdWV1ZUZsdXNoKCkge1xuICAgICAgaWYgKCFzY2hlZHVsZWQpIHtcbiAgICAgICAgc2V0VGltZW91dChmbHVzaFF1ZXVlLCAwKTsgLy9UT0RPIHNldEltbWVkaWF0ZSBvciBwb3N0TWVzc2FnZSBhcHByb2FjaCBpZiBhdmFpbGFibGU/XG4gICAgICAgIHNjaGVkdWxlZCA9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmx1c2hRdWV1ZSgpIHtcbiAgICAgIHZhciBxID0gcXVldWU7XG4gICAgICBzY2hlZHVsZWQgPSAwO1xuICAgICAgcXVldWUgPSBbXTtcbiAgICAgIHEuZm9yRWFjaChjYWxsSXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGxJdChmbikge1xuICAgICAgZm4oKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUaGVuYWJsZVRoZW4odmFsKSB7XG4gICAgICB2YXIgdmFsVGhlbiA9IHZhbCAmJiAoaXNGbih2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSAmJiB2YWwudGhlbjtcbiAgICAgIHJldHVybiBpc0ZuKHZhbFRoZW4pICYmIHZhbFRoZW5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbmVUaW1lKGZuKSB7XG4gICAgICB2YXIgY2FsbGVkID0gMDtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICBpZiAoIWNhbGxlZCsrKSB7XG4gICAgICAgICAgZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVFcnJvcigpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NoYWluaW5nIGN5Y2xlIGRldGVjdGVkJylcbiAgICB9XG5cbiAgICB2YXIgaXNGbiA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiB0eXBlb2YgdiA9PT0gJ2Z1bmN0aW9uJzsgfTtcblxuICAgIHZhciB0aGVuYWJsZU9iaiA9IHtcbiAgICAgIHRoZW46IHRoZW4sXG4gICAgICByZXNvbHZlOiByZXNvbHZlLFxuICAgICAgcmVqZWN0OiByZWplY3RcbiAgICB9O1xuICAgIHJldHVybiB0aGVuYWJsZU9ialxuICB9XG5cblxuICAvKipcbiAgICogVGhlbmFibGUgaW1wbGVtZW50YXRpb24gdGhhdCB1c2VzIGEgbmF0aXZlIFByb21pc2UgdW5kZXIgdGhlIGNvdmVycy4gVGhpcyBpbXBsZW1lbnRhdGlvblxuICAgKiBpcyBwcmVmZXJyZWQgaWYgUHJvbWlzZSBpcyBhdmFpbGFibGUsIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UgYW5kIGRldiB0b29scyBpbnRlZ3JhdGlvbi5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBOYXRpdmVQcm9taXNlVGhlbmFibGUoKSB7XG4gICAgdmFyIHJlc29sdmUsIHJlamVjdDtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXMsIHJlaikge1xuICAgICAgcmVzb2x2ZSA9IHJlcztcbiAgICAgIHJlamVjdCA9IHJlajtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgdGhlbjogcHJvbWlzZS50aGVuLmJpbmQocHJvbWlzZSksXG4gICAgICByZXNvbHZlOiByZXNvbHZlLFxuICAgICAgcmVqZWN0OiByZWplY3RcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJvbWlzZS5hbGwoKSBpbXBsOlxuICAgKi9cbiAgQmVzcG9rZVRoZW5hYmxlLmFsbCA9IE5hdGl2ZVByb21pc2VUaGVuYWJsZS5hbGwgPSBmdW5jdGlvbihpdGVtcykge1xuICAgIHZhciByZXN1bHRDb3VudCA9IDA7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICB2YXIgb3V0ID0gRGVmYXVsdFRoZW5hYmxlKCk7XG4gICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgb3V0LnJlc29sdmUoW10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgICAgIHZhciBpdGVtVGhlbmFibGUgPSBEZWZhdWx0VGhlbmFibGUoKTtcbiAgICAgICAgaXRlbVRoZW5hYmxlLnJlc29sdmUoaXRlbSk7XG4gICAgICAgIGl0ZW1UaGVuYWJsZS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICByZXN1bHRDb3VudCsrO1xuICAgICAgICAgIHJlc3VsdHNbaV0gPSByZXM7XG4gICAgICAgICAgaWYgKHJlc3VsdENvdW50ID09PSBpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG91dC5yZXNvbHZlKHJlc3VsdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgb3V0LnJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dFxuICB9O1xuXG5cbiAgLyoqXG4gICAqIENob29zZSB0aGUgYmVzdCBUaGVuYWJsZSBpbXBsZW1lbnRhdGlvbiBhbmQgZXhwb3J0IGl0IGFzIHRoZSBkZWZhdWx0LlxuICAgKi9cbiAgdmFyIERlZmF1bHRUaGVuYWJsZSA9IHR5cGVvZiBQcm9taXNlID09PSAnZnVuY3Rpb24nID8gTmF0aXZlUHJvbWlzZVRoZW5hYmxlIDogQmVzcG9rZVRoZW5hYmxlO1xuXG4gIC8qKlxuICAgKiBNYWluIGNvbnRlbnQgZm9yIHRoZSB3b3JrZXIgdGhhdCBoYW5kbGVzIHRoZSBsb2FkaW5nIGFuZCBleGVjdXRpb24gb2ZcbiAgICogbW9kdWxlcyB3aXRoaW4gaXQuXG4gICAqL1xuICBmdW5jdGlvbiB3b3JrZXJCb290c3RyYXAoKSB7XG4gICAgdmFyIG1vZHVsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgLy8gSGFuZGxlIG1lc3NhZ2VzIGZvciByZWdpc3RlcmluZyBhIG1vZHVsZVxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyTW9kdWxlKHJlZiwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBpZCA9IHJlZi5pZDtcbiAgICAgIHZhciBuYW1lID0gcmVmLm5hbWU7XG4gICAgICB2YXIgZGVwZW5kZW5jaWVzID0gcmVmLmRlcGVuZGVuY2llczsgaWYgKCBkZXBlbmRlbmNpZXMgPT09IHZvaWQgMCApIGRlcGVuZGVuY2llcyA9IFtdO1xuICAgICAgdmFyIGluaXQgPSByZWYuaW5pdDsgaWYgKCBpbml0ID09PSB2b2lkIDAgKSBpbml0ID0gZnVuY3Rpb24oKXt9O1xuICAgICAgdmFyIGdldFRyYW5zZmVyYWJsZXMgPSByZWYuZ2V0VHJhbnNmZXJhYmxlczsgaWYgKCBnZXRUcmFuc2ZlcmFibGVzID09PSB2b2lkIDAgKSBnZXRUcmFuc2ZlcmFibGVzID0gbnVsbDtcblxuICAgICAgLy8gT25seSByZWdpc3RlciBvbmNlXG4gICAgICBpZiAobW9kdWxlc1tpZF0pIHsgcmV0dXJuIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gSWYgYW55IGRlcGVuZGVuY2llcyBhcmUgbW9kdWxlcywgZW5zdXJlIHRoZXkncmUgcmVnaXN0ZXJlZCBhbmQgZ3JhYiB0aGVpciB2YWx1ZVxuICAgICAgICBkZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXMubWFwKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgICAgICBpZiAoZGVwICYmIGRlcC5pc1dvcmtlck1vZHVsZSkge1xuICAgICAgICAgICAgcmVnaXN0ZXJNb2R1bGUoZGVwLCBmdW5jdGlvbiAoZGVwUmVzdWx0KSB7XG4gICAgICAgICAgICAgIGlmIChkZXBSZXN1bHQgaW5zdGFuY2VvZiBFcnJvcikgeyB0aHJvdyBkZXBSZXN1bHQgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZXAgPSBtb2R1bGVzW2RlcC5pZF0udmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkZXBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmVoeWRyYXRlIGZ1bmN0aW9uc1xuICAgICAgICBpbml0ID0gcmVoeWRyYXRlKChcIjxcIiArIG5hbWUgKyBcIj4uaW5pdFwiKSwgaW5pdCk7XG4gICAgICAgIGlmIChnZXRUcmFuc2ZlcmFibGVzKSB7XG4gICAgICAgICAgZ2V0VHJhbnNmZXJhYmxlcyA9IHJlaHlkcmF0ZSgoXCI8XCIgKyBuYW1lICsgXCI+LmdldFRyYW5zZmVyYWJsZXNcIiksIGdldFRyYW5zZmVyYWJsZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgbW9kdWxlIGFuZCBzdG9yZSBpdHMgdmFsdWVcbiAgICAgICAgdmFyIHZhbHVlID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBpbml0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFsdWUgPSBpbml0LmFwcGx5KHZvaWQgMCwgZGVwZW5kZW5jaWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCd3b3JrZXIgbW9kdWxlIGluaXQgZnVuY3Rpb24gZmFpbGVkIHRvIHJlaHlkcmF0ZScpO1xuICAgICAgICB9XG4gICAgICAgIG1vZHVsZXNbaWRdID0ge1xuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgZ2V0VHJhbnNmZXJhYmxlczogZ2V0VHJhbnNmZXJhYmxlc1xuICAgICAgICB9O1xuICAgICAgICBjYWxsYmFjayh2YWx1ZSk7XG4gICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICBpZiAoIShlcnIgJiYgZXJyLm5vTG9nKSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEhhbmRsZSBtZXNzYWdlcyBmb3IgY2FsbGluZyBhIHJlZ2lzdGVyZWQgbW9kdWxlJ3MgcmVzdWx0IGZ1bmN0aW9uXG4gICAgZnVuY3Rpb24gY2FsbE1vZHVsZShyZWYsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgcmVmJDE7XG5cbiAgICAgIHZhciBpZCA9IHJlZi5pZDtcbiAgICAgIHZhciBhcmdzID0gcmVmLmFyZ3M7XG4gICAgICBpZiAoIW1vZHVsZXNbaWRdIHx8IHR5cGVvZiBtb2R1bGVzW2lkXS52YWx1ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoKFwiV29ya2VyIG1vZHVsZSBcIiArIGlkICsgXCI6IG5vdCBmb3VuZCBvciBpdHMgJ2luaXQnIGRpZCBub3QgcmV0dXJuIGEgZnVuY3Rpb25cIikpKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAocmVmJDEgPSBtb2R1bGVzW2lkXSkudmFsdWUuYXBwbHkocmVmJDEsIGFyZ3MpO1xuICAgICAgICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJlc3VsdC50aGVuKGhhbmRsZVJlc3VsdCwgZnVuY3Rpb24gKHJlaikgeyByZXR1cm4gY2FsbGJhY2socmVqIGluc3RhbmNlb2YgRXJyb3IgPyByZWogOiBuZXcgRXJyb3IoJycgKyByZWopKTsgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFuZGxlUmVzdWx0KHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBoYW5kbGVSZXN1bHQocmVzdWx0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHR4ID0gbW9kdWxlc1tpZF0uZ2V0VHJhbnNmZXJhYmxlcyAmJiBtb2R1bGVzW2lkXS5nZXRUcmFuc2ZlcmFibGVzKHJlc3VsdCk7XG4gICAgICAgICAgaWYgKCF0eCB8fCAhQXJyYXkuaXNBcnJheSh0eCkgfHwgIXR4Lmxlbmd0aCkge1xuICAgICAgICAgICAgdHggPSB1bmRlZmluZWQ7IC8vcG9zdE1lc3NhZ2UgaXMgdmVyeSBwaWNreSBhYm91dCBub3QgcGFzc2luZyBudWxsIG9yIGVtcHR5IHRyYW5zZmVyYWJsZXNcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2socmVzdWx0LCB0eCk7XG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWh5ZHJhdGUobmFtZSwgc3RyKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdm9pZCAwO1xuICAgICAgc2VsZi50cm9pa2FEZWZpbmUgPSBmdW5jdGlvbiAocikgeyByZXR1cm4gcmVzdWx0ID0gcjsgfTtcbiAgICAgIHZhciB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKFxuICAgICAgICBuZXcgQmxvYihcbiAgICAgICAgICBbKFwiLyoqIFwiICsgKG5hbWUucmVwbGFjZSgvXFwqL2csICcnKSkgKyBcIiAqKi9cXG5cXG50cm9pa2FEZWZpbmUoXFxuXCIgKyBzdHIgKyBcIlxcbilcIildLFxuICAgICAgICAgIHt0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCd9XG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICB0cnkge1xuICAgICAgICBpbXBvcnRTY3JpcHRzKHVybCk7XG4gICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICB9XG4gICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG4gICAgICBkZWxldGUgc2VsZi50cm9pa2FEZWZpbmU7XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlciBmb3IgYWxsIG1lc3NhZ2VzIHdpdGhpbiB0aGUgd29ya2VyXG4gICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciByZWYgPSBlLmRhdGE7XG4gICAgICB2YXIgbWVzc2FnZUlkID0gcmVmLm1lc3NhZ2VJZDtcbiAgICAgIHZhciBhY3Rpb24gPSByZWYuYWN0aW9uO1xuICAgICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIE1vZHVsZSByZWdpc3RyYXRpb25cbiAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ3JlZ2lzdGVyTW9kdWxlJykge1xuICAgICAgICAgIHJlZ2lzdGVyTW9kdWxlKGRhdGEsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZUlkOiBtZXNzYWdlSWQsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IHJlc3VsdC5tZXNzYWdlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VJZDogbWVzc2FnZUlkLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiB7aXNDYWxsYWJsZTogdHlwZW9mIHJlc3VsdCA9PT0gJ2Z1bmN0aW9uJ31cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW52b2NhdGlvblxuICAgICAgICBpZiAoYWN0aW9uID09PSAnY2FsbE1vZHVsZScpIHtcbiAgICAgICAgICBjYWxsTW9kdWxlKGRhdGEsIGZ1bmN0aW9uIChyZXN1bHQsIHRyYW5zZmVyYWJsZXMpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZUlkOiBtZXNzYWdlSWQsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IHJlc3VsdC5tZXNzYWdlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VJZDogbWVzc2FnZUlkLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHRcbiAgICAgICAgICAgICAgfSwgdHJhbnNmZXJhYmxlcyB8fCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICBwb3N0TWVzc2FnZSh7XG4gICAgICAgICAgbWVzc2FnZUlkOiBtZXNzYWdlSWQsXG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IGVyci5zdGFja1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGYWxsYmFjayBmb3IgYGRlZmluZVdvcmtlck1vZHVsZWAgdGhhdCBiZWhhdmVzIGlkZW50aWNhbGx5IGJ1dCBydW5zIGluIHRoZSBtYWluXG4gICAqIHRocmVhZCwgZm9yIHdoZW4gdGhlIGV4ZWN1dGlvbiBlbnZpcm9ubWVudCBkb2Vzbid0IHN1cHBvcnQgd2ViIHdvcmtlcnMgb3IgdGhleVxuICAgKiBhcmUgZGlzYWxsb3dlZCBkdWUgdG8gZS5nLiBDU1Agc2VjdXJpdHkgcmVzdHJpY3Rpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gZGVmaW5lTWFpblRocmVhZE1vZHVsZShvcHRpb25zKSB7XG4gICAgdmFyIG1vZHVsZUZ1bmMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICByZXR1cm4gbW9kdWxlRnVuYy5fZ2V0SW5pdFJlc3VsdCgpLnRoZW4oZnVuY3Rpb24gKGluaXRSZXN1bHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbml0UmVzdWx0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGluaXRSZXN1bHQuYXBwbHkodm9pZCAwLCBhcmdzKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya2VyIG1vZHVsZSBmdW5jdGlvbiB3YXMgY2FsbGVkIGJ1dCBgaW5pdGAgZGlkIG5vdCByZXR1cm4gYSBjYWxsYWJsZSBmdW5jdGlvbicpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfTtcbiAgICBtb2R1bGVGdW5jLl9nZXRJbml0UmVzdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBXZSBjYW4gaWdub3JlIGdldFRyYW5zZmVyYWJsZXMgaW4gbWFpbiB0aHJlYWQuIFRPRE8gd29ya2VySWQ/XG4gICAgICB2YXIgZGVwZW5kZW5jaWVzID0gb3B0aW9ucy5kZXBlbmRlbmNpZXM7XG4gICAgICB2YXIgaW5pdCA9IG9wdGlvbnMuaW5pdDtcblxuICAgICAgLy8gUmVzb2x2ZSBkZXBlbmRlbmNpZXNcbiAgICAgIGRlcGVuZGVuY2llcyA9IEFycmF5LmlzQXJyYXkoZGVwZW5kZW5jaWVzKSA/IGRlcGVuZGVuY2llcy5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gZGVwICYmIGRlcC5fZ2V0SW5pdFJlc3VsdCA/IGRlcC5fZ2V0SW5pdFJlc3VsdCgpIDogZGVwOyB9XG4gICAgICApIDogW107XG5cbiAgICAgIC8vIEludm9rZSBpbml0IHdpdGggdGhlIHJlc29sdmVkIGRlcGVuZGVuY2llc1xuICAgICAgdmFyIGluaXRUaGVuYWJsZSA9IERlZmF1bHRUaGVuYWJsZS5hbGwoZGVwZW5kZW5jaWVzKS50aGVuKGZ1bmN0aW9uIChkZXBzKSB7XG4gICAgICAgIHJldHVybiBpbml0LmFwcGx5KG51bGwsIGRlcHMpXG4gICAgICB9KTtcblxuICAgICAgLy8gQ2FjaGUgdGhlIHJlc29sdmVkIHByb21pc2UgZm9yIHN1YnNlcXVlbnQgY2FsbHNcbiAgICAgIG1vZHVsZUZ1bmMuX2dldEluaXRSZXN1bHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpbml0VGhlbmFibGU7IH07XG5cbiAgICAgIHJldHVybiBpbml0VGhlbmFibGVcbiAgICB9O1xuICAgIHJldHVybiBtb2R1bGVGdW5jXG4gIH1cblxuICB2YXIgc3VwcG9ydHNXb3JrZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdXBwb3J0ZWQgPSBmYWxzZTtcblxuICAgIC8vIE9ubHkgYXR0ZW1wdCB3b3JrZXIgaW5pdGlhbGl6YXRpb24gaW4gYnJvd3NlcnM7IGVsc2V3aGVyZSBpdCB3b3VsZCBqdXN0IGJlXG4gICAgLy8gbm9pc2UgZS5nLiBsb2FkaW5nIGludG8gYSBOb2RlIGVudmlyb25tZW50IGZvciBTU1IuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUT0RPIGFkZGl0aW9uYWwgY2hlY2tzIGZvciB0aGluZ3MgbGlrZSBpbXBvcnRTY3JpcHRzIHdpdGhpbiB0aGUgd29ya2VyP1xuICAgICAgICAvLyAgV291bGQgbmVlZCB0byBiZSBhbiBhc3luYyBjaGVjay5cbiAgICAgICAgdmFyIHdvcmtlciA9IG5ldyBXb3JrZXIoXG4gICAgICAgICAgVVJMLmNyZWF0ZU9iamVjdFVSTChcbiAgICAgICAgICAgIG5ldyBCbG9iKFsnJ10sIHsgdHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnIH0pXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICB3b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5sb2coKFwiVHJvaWthIGNyZWF0ZVdvcmtlck1vZHVsZTogd2ViIHdvcmtlcnMgbm90IGFsbG93ZWQ7IGZhbGxpbmcgYmFjayB0byBtYWluIHRocmVhZCBleGVjdXRpb24uIENhdXNlOiBbXCIgKyAoZXJyLm1lc3NhZ2UpICsgXCJdXCIpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDYWNoZWQgcmVzdWx0XG4gICAgc3VwcG9ydHNXb3JrZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc3VwcG9ydGVkOyB9O1xuICAgIHJldHVybiBzdXBwb3J0ZWRcbiAgfTtcblxuICB2YXIgX3dvcmtlck1vZHVsZUlkID0gMDtcbiAgdmFyIF9tZXNzYWdlSWQgPSAwO1xuICB2YXIgX2FsbG93SW5pdEFzU3RyaW5nID0gZmFsc2U7XG4gIHZhciB3b3JrZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIG9wZW5SZXF1ZXN0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIG9wZW5SZXF1ZXN0cy5fY291bnQgPSAwO1xuXG5cbiAgLyoqXG4gICAqIERlZmluZSBhIG1vZHVsZSBvZiBjb2RlIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aXRoIGEgd2ViIHdvcmtlci4gVGhpcyBwcm92aWRlcyBhIHNpbXBsZVxuICAgKiBpbnRlcmZhY2UgZm9yIG1vdmluZyBjaHVua3Mgb2YgbG9naWMgb2ZmIHRoZSBtYWluIHRocmVhZCwgYW5kIG1hbmFnaW5nIHRoZWlyIGRlcGVuZGVuY2llc1xuICAgKiBhbW9uZyBvbmUgYW5vdGhlci5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucy5pbml0IC0gVGhlIG1haW4gZnVuY3Rpb24gdGhhdCBpbml0aWFsaXplcyB0aGUgbW9kdWxlLiBUaGlzIHdpbGwgYmUgcnVuXG4gICAqICAgICAgICB3aXRoaW4gdGhlIHdvcmtlciwgYW5kIHdpbGwgYmUgcGFzc2VkIHRoZSByZXNvbHZlZCBkZXBlbmRlbmNpZXMgYXMgYXJndW1lbnRzLiBJdHNcbiAgICogICAgICAgIHJldHVybiB2YWx1ZSBiZWNvbWVzIHRoZSBtb2R1bGUncyBjb250ZW50LCB3aGljaCBjYW4gdGhlbiBiZSB1c2VkIGJ5IG90aGVyIG1vZHVsZXNcbiAgICogICAgICAgIHRoYXQgZGVwZW5kIG9uIGl0LiBUaGlzIGZ1bmN0aW9uIGNhbiBwZXJmb3JtIGFueSBsb2dpYyB1c2luZyB0aG9zZSBkZXBlbmRlbmNpZXMsIGJ1dFxuICAgKiAgICAgICAgbXVzdCBub3QgZGVwZW5kIG9uIGFueXRoaW5nIGZyb20gaXRzIHBhcmVudCBjbG9zdXJlcy5cbiAgICogQHBhcmFtIHthcnJheX0gW29wdGlvbnMuZGVwZW5kZW5jaWVzXSAtIFByb3ZpZGVzIGFueSBkZXBlbmRlbmNpZXMgcmVxdWlyZWQgYnkgdGhlIGluaXQgZnVuY3Rpb246XG4gICAqICAgICAgICAtIFByaW1pdGl2ZXMgbGlrZSBzdHJpbmdzLCBudW1iZXJzLCBib29sZWFuc1xuICAgKiAgICAgICAgLSBSYXcgZnVuY3Rpb25zOyB0aGVzZSB3aWxsIGJlIHN0cmluZ2lmaWVkIGFuZCByZWh5ZHJhdGVkIHdpdGhpbiB0aGUgd29ya2VyIHNvIHRoZXlcbiAgICogICAgICAgICAgbXVzdCBub3QgZGVwZW5kIG9uIGFueXRoaW5nIGZyb20gdGhlaXIgcGFyZW50IGNsb3N1cmVzXG4gICAqICAgICAgICAtIE90aGVyIHdvcmtlciBtb2R1bGVzOyB0aGVzZSB3aWxsIGJlIHJlc29sdmVkIHdpdGhpbiB0aGUgd29ya2VyLCBhbmQgdGhlcmVmb3JlIG1vZHVsZXNcbiAgICogICAgICAgICAgdGhhdCBwcm92aWRlIGZ1bmN0aW9ucyBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgaGF2aW5nIHRvIGNyb3NzIHRoZSB3b3JrZXIvbWFpbiB0aHJlYWRcbiAgICogICAgICAgICAgYm91bmRhcnkuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmdldFRyYW5zZmVyYWJsZXNdIC0gQW4gb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIHJ1biBpbiB0aGUgd29ya2VyXG4gICAqICAgICAgICBqdXN0IGJlZm9yZSBwb3N0aW5nIHRoZSByZXNwb25zZSB2YWx1ZSBmcm9tIGEgbW9kdWxlIGNhbGwgYmFjayB0byB0aGUgbWFpbiB0aHJlYWQuXG4gICAqICAgICAgICBJdCB3aWxsIGJlIHBhc3NlZCB0aGF0IHJlc3BvbnNlIHZhbHVlLCBhbmQgaWYgaXQgcmV0dXJucyBhbiBhcnJheSB0aGVuIHRoYXQgd2lsbCBiZVxuICAgKiAgICAgICAgdXNlZCBhcyB0aGUgXCJ0cmFuc2ZlcmFibGVzXCIgcGFyYW1ldGVyIHRvIGBwb3N0TWVzc2FnZWAuIFVzZSB0aGlzIGlmIHRoZXJlIGFyZSB2YWx1ZXNcbiAgICogICAgICAgIGluIHRoZSByZXNwb25zZSB0aGF0IGNhbi9zaG91bGQgYmUgdHJhbnNmZXJlZCByYXRoZXIgdGhhbiBjbG9uZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5uYW1lXSAtIEEgZGVzY3JpcHRpdmUgbmFtZSBmb3IgdGhpcyBtb2R1bGU7IHRoaXMgY2FuIGJlIHVzZWZ1bCBmb3JcbiAgICogICAgICAgIGRlYnVnZ2luZyBidXQgaXMgbm90IGN1cnJlbnRseSB1c2VkIGZvciBhbnl0aGluZyBlbHNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMud29ya2VySWRdIC0gQnkgZGVmYXVsdCBhbGwgbW9kdWxlcyB3aWxsIHJ1biBpbiB0aGUgc2FtZSBkZWRpY2F0ZWQgd29ya2VyLFxuICAgKiAgICAgICAgYnV0IGlmIHlvdSB3YW50IHRvIHVzZSBtdWx0aXBsZSB3b3JrZXJzIHlvdSBjYW4gcGFzcyBhIGB3b3JrZXJJZGAgdG8gaW5kaWNhdGUgYSBzcGVjaWZpY1xuICAgKiAgICAgICAgd29ya2VyIHRvIHNwYXduLiBOb3RlIHRoYXQgZWFjaCB3b3JrZXIgaXMgY29tcGxldGVseSBzdGFuZGFsb25lIGFuZCBubyBkYXRhIG9yIHN0YXRlIHdpbGxcbiAgICogICAgICAgIGJlIHNoYXJlZCBiZXR3ZWVuIHRoZW0uIElmIGEgd29ya2VyIG1vZHVsZSBpcyB1c2VkIGFzIGEgZGVwZW5kZW5jeSBieSB3b3JrZXIgbW9kdWxlc1xuICAgKiAgICAgICAgdXNpbmcgZGlmZmVyZW50IGB3b3JrZXJJZGBzLCB0aGVuIHRoYXQgZGVwZW5kZW5jeSB3aWxsIGJlIHJlLXJlZ2lzdGVyZWQgaW4gZWFjaCB3b3JrZXIuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9uKC4uLlsqXSk6IHt0aGVufX1cbiAgICovXG4gIGZ1bmN0aW9uIGRlZmluZVdvcmtlck1vZHVsZShvcHRpb25zKSB7XG4gICAgaWYgKCghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucy5pbml0ICE9PSAnZnVuY3Rpb24nKSAmJiAhX2FsbG93SW5pdEFzU3RyaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVzIGBvcHRpb25zLmluaXRgIGZ1bmN0aW9uJylcbiAgICB9XG4gICAgdmFyIGRlcGVuZGVuY2llcyA9IG9wdGlvbnMuZGVwZW5kZW5jaWVzO1xuICAgIHZhciBpbml0ID0gb3B0aW9ucy5pbml0O1xuICAgIHZhciBnZXRUcmFuc2ZlcmFibGVzID0gb3B0aW9ucy5nZXRUcmFuc2ZlcmFibGVzO1xuICAgIHZhciB3b3JrZXJJZCA9IG9wdGlvbnMud29ya2VySWQ7XG5cbiAgICBpZiAoIXN1cHBvcnRzV29ya2VycygpKSB7XG4gICAgICByZXR1cm4gZGVmaW5lTWFpblRocmVhZE1vZHVsZShvcHRpb25zKVxuICAgIH1cblxuICAgIGlmICh3b3JrZXJJZCA9PSBudWxsKSB7XG4gICAgICB3b3JrZXJJZCA9ICcjZGVmYXVsdCc7XG4gICAgfVxuICAgIHZhciBpZCA9IFwid29ya2VyTW9kdWxlXCIgKyAoKytfd29ya2VyTW9kdWxlSWQpO1xuICAgIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lIHx8IGlkO1xuICAgIHZhciByZWdpc3RyYXRpb25UaGVuYWJsZSA9IG51bGw7XG5cbiAgICBkZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXMgJiYgZGVwZW5kZW5jaWVzLm1hcChmdW5jdGlvbiAoZGVwKSB7XG4gICAgICAvLyBXcmFwIHJhdyBmdW5jdGlvbnMgYXMgd29ya2VyIG1vZHVsZXMgd2l0aCBubyBkZXBlbmRlbmNpZXNcbiAgICAgIGlmICh0eXBlb2YgZGVwID09PSAnZnVuY3Rpb24nICYmICFkZXAud29ya2VyTW9kdWxlRGF0YSkge1xuICAgICAgICBfYWxsb3dJbml0QXNTdHJpbmcgPSB0cnVlO1xuICAgICAgICBkZXAgPSBkZWZpbmVXb3JrZXJNb2R1bGUoe1xuICAgICAgICAgIHdvcmtlcklkOiB3b3JrZXJJZCxcbiAgICAgICAgICBuYW1lOiAoXCI8XCIgKyBuYW1lICsgXCI+IGZ1bmN0aW9uIGRlcGVuZGVuY3k6IFwiICsgKGRlcC5uYW1lKSksXG4gICAgICAgICAgaW5pdDogKFwiZnVuY3Rpb24oKXtyZXR1cm4gKFxcblwiICsgKHN0cmluZ2lmeUZ1bmN0aW9uKGRlcCkpICsgXCJcXG4pfVwiKVxuICAgICAgICB9KTtcbiAgICAgICAgX2FsbG93SW5pdEFzU3RyaW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBHcmFiIHBvc3RhYmxlIGRhdGEgZm9yIHdvcmtlciBtb2R1bGVzXG4gICAgICBpZiAoZGVwICYmIGRlcC53b3JrZXJNb2R1bGVEYXRhKSB7XG4gICAgICAgIGRlcCA9IGRlcC53b3JrZXJNb2R1bGVEYXRhO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlcFxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbW9kdWxlRnVuYygpIHtcbiAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAvLyBSZWdpc3RlciB0aGlzIG1vZHVsZSBpZiBuZWVkZWRcbiAgICAgIGlmICghcmVnaXN0cmF0aW9uVGhlbmFibGUpIHtcbiAgICAgICAgcmVnaXN0cmF0aW9uVGhlbmFibGUgPSBjYWxsV29ya2VyKHdvcmtlcklkLCdyZWdpc3Rlck1vZHVsZScsIG1vZHVsZUZ1bmMud29ya2VyTW9kdWxlRGF0YSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEludm9rZSB0aGUgbW9kdWxlLCByZXR1cm5pbmcgYSB0aGVuYWJsZVxuICAgICAgcmV0dXJuIHJlZ2lzdHJhdGlvblRoZW5hYmxlLnRoZW4oZnVuY3Rpb24gKHJlZikge1xuICAgICAgICB2YXIgaXNDYWxsYWJsZSA9IHJlZi5pc0NhbGxhYmxlO1xuXG4gICAgICAgIGlmIChpc0NhbGxhYmxlKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxXb3JrZXIod29ya2VySWQsJ2NhbGxNb2R1bGUnLCB7aWQ6IGlkLCBhcmdzOiBhcmdzfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtlciBtb2R1bGUgZnVuY3Rpb24gd2FzIGNhbGxlZCBidXQgYGluaXRgIGRpZCBub3QgcmV0dXJuIGEgY2FsbGFibGUgZnVuY3Rpb24nKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICBtb2R1bGVGdW5jLndvcmtlck1vZHVsZURhdGEgPSB7XG4gICAgICBpc1dvcmtlck1vZHVsZTogdHJ1ZSxcbiAgICAgIGlkOiBpZCxcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBkZXBlbmRlbmNpZXM6IGRlcGVuZGVuY2llcyxcbiAgICAgIGluaXQ6IHN0cmluZ2lmeUZ1bmN0aW9uKGluaXQpLFxuICAgICAgZ2V0VHJhbnNmZXJhYmxlczogZ2V0VHJhbnNmZXJhYmxlcyAmJiBzdHJpbmdpZnlGdW5jdGlvbihnZXRUcmFuc2ZlcmFibGVzKVxuICAgIH07XG4gICAgcmV0dXJuIG1vZHVsZUZ1bmNcbiAgfVxuXG4gIC8qKlxuICAgKiBTdHJpbmdpZmllcyBhIGZ1bmN0aW9uIGludG8gYSBmb3JtIHRoYXQgY2FuIGJlIGRlc2VyaWFsaXplZCBpbiB0aGUgd29ya2VyXG4gICAqIEBwYXJhbSBmblxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaW5naWZ5RnVuY3Rpb24oZm4pIHtcbiAgICB2YXIgc3RyID0gZm4udG9TdHJpbmcoKTtcbiAgICAvLyBJZiBpdCB3YXMgZGVmaW5lZCBpbiBvYmplY3QgbWV0aG9kL3Byb3BlcnR5IGZvcm1hdCwgaXQgbmVlZHMgdG8gYmUgbW9kaWZpZWRcbiAgICBpZiAoIS9eZnVuY3Rpb24vLnRlc3Qoc3RyKSAmJiAvXlxcdytcXHMqXFwoLy50ZXN0KHN0cikpIHtcbiAgICAgIHN0ciA9ICdmdW5jdGlvbiAnICsgc3RyO1xuICAgIH1cbiAgICByZXR1cm4gc3RyXG4gIH1cblxuXG4gIGZ1bmN0aW9uIGdldFdvcmtlcih3b3JrZXJJZCkge1xuICAgIHZhciB3b3JrZXIgPSB3b3JrZXJzW3dvcmtlcklkXTtcbiAgICBpZiAoIXdvcmtlcikge1xuICAgICAgLy8gQm9vdHN0cmFwIHRoZSB3b3JrZXIncyBjb250ZW50XG4gICAgICB2YXIgYm9vdHN0cmFwID0gc3RyaW5naWZ5RnVuY3Rpb24od29ya2VyQm9vdHN0cmFwKTtcblxuICAgICAgLy8gQ3JlYXRlIHRoZSB3b3JrZXIgZnJvbSB0aGUgYm9vdHN0cmFwIGZ1bmN0aW9uIGNvbnRlbnRcbiAgICAgIHdvcmtlciA9IHdvcmtlcnNbd29ya2VySWRdID0gbmV3IFdvcmtlcihcbiAgICAgICAgVVJMLmNyZWF0ZU9iamVjdFVSTChcbiAgICAgICAgICBuZXcgQmxvYihcbiAgICAgICAgICAgIFsoXCIvKiogV29ya2VyIE1vZHVsZSBCb290c3RyYXA6IFwiICsgKHdvcmtlcklkLnJlcGxhY2UoL1xcKi9nLCAnJykpICsgXCIgKiovXFxuXFxuOyhcIiArIGJvb3RzdHJhcCArIFwiKSgpXCIpXSxcbiAgICAgICAgICAgIHt0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCd9XG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICApO1xuXG4gICAgICAvLyBTaW5nbGUgaGFuZGxlciBmb3IgcmVzcG9uc2UgbWVzc2FnZXMgZnJvbSB0aGUgd29ya2VyXG4gICAgICB3b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHJlc3BvbnNlID0gZS5kYXRhO1xuICAgICAgICB2YXIgbXNnSWQgPSByZXNwb25zZS5tZXNzYWdlSWQ7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IG9wZW5SZXF1ZXN0c1ttc2dJZF07XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtlck1vZHVsZSByZXNwb25zZSB3aXRoIGVtcHR5IG9yIHVua25vd24gbWVzc2FnZUlkJylcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgb3BlblJlcXVlc3RzW21zZ0lkXTtcbiAgICAgICAgb3BlblJlcXVlc3RzLmNvdW50LS07XG4gICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB3b3JrZXJcbiAgfVxuXG4gIC8vIElzc3VlIGEgY2FsbCB0byB0aGUgd29ya2VyIHdpdGggYSBjYWxsYmFjayB0byBoYW5kbGUgdGhlIHJlc3BvbnNlXG4gIGZ1bmN0aW9uIGNhbGxXb3JrZXIod29ya2VySWQsIGFjdGlvbiwgZGF0YSkge1xuICAgIHZhciB0aGVuYWJsZSA9IERlZmF1bHRUaGVuYWJsZSgpO1xuICAgIHZhciBtZXNzYWdlSWQgPSArK19tZXNzYWdlSWQ7XG4gICAgb3BlblJlcXVlc3RzW21lc3NhZ2VJZF0gPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgIHRoZW5hYmxlLnJlc29sdmUocmVzcG9uc2UucmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoZW5hYmxlLnJlamVjdChuZXcgRXJyb3IoKFwiRXJyb3IgaW4gd29ya2VyIFwiICsgYWN0aW9uICsgXCIgY2FsbDogXCIgKyAocmVzcG9uc2UuZXJyb3IpKSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgb3BlblJlcXVlc3RzLl9jb3VudCsrO1xuICAgIGlmIChvcGVuUmVxdWVzdHMuY291bnQgPiAxMDAwKSB7IC8vZGV0ZWN0IGxlYWtzXG4gICAgICBjb25zb2xlLndhcm4oJ0xhcmdlIG51bWJlciBvZiBvcGVuIFdvcmtlck1vZHVsZSByZXF1ZXN0cywgc29tZSBtYXkgbm90IGJlIHJldHVybmluZycpO1xuICAgIH1cbiAgICBnZXRXb3JrZXIod29ya2VySWQpLnBvc3RNZXNzYWdlKHtcbiAgICAgIG1lc3NhZ2VJZDogbWVzc2FnZUlkLFxuICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoZW5hYmxlXG4gIH1cblxuICAvKipcbiAgICogSnVzdCB0aGUge0BsaW5rIFRoZW5hYmxlfSBmdW5jdGlvbiB3cmFwcGVkIGFzIGEgd29ya2VyIG1vZHVsZS4gSWYgYW5vdGhlciB3b3JrZXJcbiAgICogbW9kdWxlIG5lZWRzIFRoZW5hYmxlIGFzIGEgZGVwZW5kZW5jeSwgaXQncyBiZXR0ZXIgdG8gcGFzcyB0aGlzIG1vZHVsZSByYXRoZXIgdGhhblxuICAgKiB0aGUgcmF3IGZ1bmN0aW9uIGluIGl0cyBgZGVwZW5kZW5jaWVzYCBhcnJheSBzbyBpdCBvbmx5IGdldHMgcmVnaXN0ZXJlZCBvbmNlLlxuICAgKi9cbiAgdmFyIFRoZW5hYmxlV29ya2VyTW9kdWxlID0gZGVmaW5lV29ya2VyTW9kdWxlKHtcbiAgICBuYW1lOiAnVGhlbmFibGUnLFxuICAgIGRlcGVuZGVuY2llczogW0RlZmF1bHRUaGVuYWJsZV0sXG4gICAgaW5pdDogZnVuY3Rpb24oVGhlbmFibGUpIHtcbiAgICAgIHJldHVybiBUaGVuYWJsZVxuICAgIH1cbiAgfSk7XG5cbiAgZXhwb3J0cy5UaGVuYWJsZSA9IERlZmF1bHRUaGVuYWJsZTtcbiAgZXhwb3J0cy5UaGVuYWJsZVdvcmtlck1vZHVsZSA9IFRoZW5hYmxlV29ya2VyTW9kdWxlO1xuICBleHBvcnRzLmRlZmluZVdvcmtlck1vZHVsZSA9IGRlZmluZVdvcmtlck1vZHVsZTtcbiAgZXhwb3J0cy5zdHJpbmdpZnlGdW5jdGlvbiA9IHN0cmluZ2lmeUZ1bmN0aW9uO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/troika-worker-utils/dist/troika-worker-utils.umd.js\n"
      );

      /***/
    },
};
