/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/troika-three-utils";
exports.ids = ["vendor-chunks/troika-three-utils"];
exports.modules = {
  /***/ "(ssr)/./node_modules/troika-three-utils/dist/troika-three-utils.umd.js":
    /*!************************************************************************!*\
  !*** ./node_modules/troika-three-utils/dist/troika-three-utils.umd.js ***!
  \************************************************************************/
    /***/ function (__unused_webpack_module, exports, __webpack_require__) {
      eval(
        '(function (global, factory) {\n   true ? factory(exports, __webpack_require__(/*! three */ "(ssr)/./node_modules/three/build/three.js")) :\n  0;\n}(this, (function (exports, three) { \'use strict\';\n\n  /**\n   * Regular expression for matching the `void main() {` opener line in GLSL.\n   * @type {RegExp}\n   */\n  var voidMainRegExp = /\\bvoid\\s+main\\s*\\(\\s*\\)\\s*{/g;\n\n  /**\n   * Recursively expands all `#include <xyz>` statements within string of shader code.\n   * Copied from three\'s WebGLProgram#parseIncludes for external use.\n   *\n   * @param {string} source - The GLSL source code to evaluate\n   * @return {string} The GLSL code with all includes expanded\n   */\n  function expandShaderIncludes( source ) {\n    var pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n    function replace(match, include) {\n      var chunk = three.ShaderChunk[include];\n      return chunk ? expandShaderIncludes(chunk) : match\n    }\n    return source.replace( pattern, replace )\n  }\n\n  // Local assign polyfill to avoid importing troika-core\n  var assign = Object.assign || function(/*target, ...sources*/) {\n    var arguments$1 = arguments;\n\n    var target = arguments[0];\n    for (var i = 1, len = arguments.length; i < len; i++) {\n      var source = arguments$1[i];\n      if (source) {\n        for (var prop in source) {\n          if (source.hasOwnProperty(prop)) {\n            target[prop] = source[prop];\n          }\n        }\n      }\n    }\n    return target\n  };\n\n\n  var epoch = Date.now();\n  var CACHE = new WeakMap(); //threejs requires WeakMap internally so should be safe to assume support\n\n\n  /**\n   * A utility for creating a custom shader material derived from another material\'s\n   * shaders. This allows you to inject custom shader logic and transforms into the\n   * builtin ThreeJS materials without having to recreate them from scratch.\n   *\n   * @param {THREE.Material} baseMaterial - the original material to derive from\n   *\n   * @param {Object} options - How the base material should be modified.\n   * @param {Object} options.defines - Custom `defines` for the material\n   * @param {Object} options.extensions - Custom `extensions` for the material, e.g. `{derivatives: true}`\n   * @param {Object} options.uniforms - Custom `uniforms` for use in the modified shader. These can\n   *        be accessed and manipulated via the resulting material\'s `uniforms` property, just like\n   *        in a ShaderMaterial. You do not need to repeat the base material\'s own uniforms here.\n   * @param {String} options.timeUniform - If specified, a uniform of this name will be injected into\n   *        both shaders, and it will automatically be updated on each render frame with a number of\n   *        elapsed milliseconds. The "zero" epoch time is not significant so don\'t rely on this as a\n   *        true calendar time.\n   * @param {String} options.vertexDefs - Custom GLSL code to inject into the vertex shader\'s top-level\n   *        definitions, above the `void main()` function.\n   * @param {String} options.vertexMainIntro - Custom GLSL code to inject at the top of the vertex\n   *        shader\'s `void main` function.\n   * @param {String} options.vertexMainOutro - Custom GLSL code to inject at the end of the vertex\n   *        shader\'s `void main` function.\n   * @param {String} options.vertexTransform - Custom GLSL code to manipulate the `position`, `normal`,\n   *        and/or `uv` vertex attributes. This code will be wrapped within a standalone function with\n   *        those attributes exposed by their normal names as read/write values.\n   * @param {String} options.fragmentDefs - Custom GLSL code to inject into the fragment shader\'s top-level\n   *        definitions, above the `void main()` function.\n   * @param {String} options.fragmentMainIntro - Custom GLSL code to inject at the top of the fragment\n   *        shader\'s `void main` function.\n   * @param {String} options.fragmentMainOutro - Custom GLSL code to inject at the end of the fragment\n   *        shader\'s `void main` function. You can manipulate `gl_FragColor` here but keep in mind it goes\n   *        after any of ThreeJS\'s color postprocessing shader chunks (tonemapping, fog, etc.), so if you\n   *        want those to apply to your changes use `fragmentColorTransform` instead.\n   * @param {String} options.fragmentColorTransform - Custom GLSL code to manipulate the `gl_FragColor`\n   *        output value. Will be injected near the end of the `void main` function, but before any\n   *        of ThreeJS\'s color postprocessing shader chunks (tonemapping, fog, etc.), and before the\n   *        `fragmentMainOutro`.\n   * @param {function<{vertexShader,fragmentShader}>:{vertexShader,fragmentShader}} options.customRewriter - A function\n   *        for performing custom rewrites of the full shader code. Useful if you need to do something\n   *        special that\'s not covered by the other builtin options. This function will be executed before\n   *        any other transforms are applied.\n   *\n   * @return {THREE.Material}\n   *\n   * The returned material will also have two new methods, `getDepthMaterial()` and `getDistanceMaterial()`,\n   * which can be called to get a variant of the derived material for use in shadow casting. If the\n   * target mesh is expected to cast shadows, then you can assign these to the mesh\'s `customDepthMaterial`\n   * (for directional and spot lights) and/or `customDistanceMaterial` (for point lights) properties to\n   * allow the cast shadow to honor your derived shader\'s vertex transforms and discarded fragments. These\n   * will also set a custom `#define IS_DEPTH_MATERIAL` or `#define IS_DISTANCE_MATERIAL` that you can look\n   * for in your derived shaders with `#ifdef` to customize their behavior for the depth or distance\n   * scenarios, e.g. skipping antialiasing or expensive shader logic.\n   */\n  function createDerivedMaterial(baseMaterial, options) {\n    // First check the cache to see if we\'ve already derived from this baseMaterial using\n    // this unique set of options, and if so just return a clone instead of a new subclass\n    // which is faster and allows their shader program to be shared when rendering.\n    var optionsHash = getOptionsHash(options);\n    var cached = CACHE.get(baseMaterial);\n    if (!cached) {\n      cached = Object.create(null);\n      CACHE.set(baseMaterial, cached);\n    }\n    if (cached[optionsHash]) {\n      return cached[optionsHash].clone()\n    }\n\n    // Even if baseMaterial is changing, use a consistent id in shader rewrites based on the\n    // optionsHash. This makes it more likely that deriving from base materials of the same\n    // type/class, e.g. multiple instances of MeshStandardMaterial, will produce identical\n    // rewritten shader code so they can share a single WebGLProgram behind the scenes.\n    var id = getIdForOptionsHash(optionsHash);\n    var privateDerivedShadersProp = "_derivedShaders" + id;\n    var privateBeforeCompileProp = "_onBeforeCompile" + id;\n    var distanceMaterialTpl, depthMaterialTpl;\n\n    // Private onBeforeCompile handler that injects the modified shaders and uniforms when\n    // the renderer switches to this material\'s program\n    function onBeforeCompile(shaderInfo) {\n      baseMaterial.onBeforeCompile.call(this, shaderInfo);\n\n      // Upgrade the shaders, caching the result\n      var ref = this[privateDerivedShadersProp] || (this[privateDerivedShadersProp] = {vertex: {}, fragment: {}});\n      var vertex = ref.vertex;\n      var fragment = ref.fragment;\n      if (vertex.source !== shaderInfo.vertexShader || fragment.source !== shaderInfo.fragmentShader) {\n        var upgraded = upgradeShaders(shaderInfo, options, id);\n        vertex.source = shaderInfo.vertexShader;\n        vertex.result = upgraded.vertexShader;\n        fragment.source = shaderInfo.fragmentShader;\n        fragment.result = upgraded.fragmentShader;\n      }\n\n      // Inject upgraded shaders and uniforms into the program\n      shaderInfo.vertexShader = vertex.result;\n      shaderInfo.fragmentShader = fragment.result;\n      assign(shaderInfo.uniforms, this.uniforms);\n\n      // Inject auto-updating time uniform if requested\n      if (options.timeUniform) {\n        shaderInfo.uniforms[options.timeUniform] = {\n          get value() {return Date.now() - epoch}\n        };\n      }\n\n      // Users can still add their own handlers on top of ours\n      if (this[privateBeforeCompileProp]) {\n        this[privateBeforeCompileProp](shaderInfo);\n      }\n    }\n\n    function DerivedMaterial() {\n      baseMaterial.constructor.apply(this, arguments);\n      this._listeners = undefined; //don\'t inherit EventDispatcher listeners\n    }\n    DerivedMaterial.prototype = Object.create(baseMaterial, {\n      constructor: {value: DerivedMaterial},\n      isDerivedMaterial: {value: true},\n      baseMaterial: {value: baseMaterial},\n\n      onBeforeCompile: {\n        get: function get() {\n          return onBeforeCompile\n        },\n        set: function set(fn) {\n          this[privateBeforeCompileProp] = fn;\n        }\n      },\n\n      copy: {\n        value: function (source) {\n          baseMaterial.copy.call(this, source);\n          if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {\n            this.extensions = assign({}, source.extensions);\n            this.defines = assign({}, source.defines);\n            this.uniforms = three.UniformsUtils.clone(source.uniforms);\n          }\n          return this\n        }\n      },\n\n      /**\n       * Utility to get a MeshDepthMaterial that will honor this derived material\'s vertex\n       * transformations and discarded fragments.\n       */\n      getDepthMaterial: {value: function() {\n        var depthMaterial = this._depthMaterial;\n        if (!depthMaterial) {\n          if (!depthMaterialTpl) {\n            depthMaterialTpl = createDerivedMaterial(\n              baseMaterial.isDerivedMaterial\n                ? baseMaterial.getDepthMaterial()\n                : new three.MeshDepthMaterial({depthPacking: three.RGBADepthPacking}),\n              options\n            );\n            depthMaterialTpl.defines.IS_DEPTH_MATERIAL = \'\';\n          }\n          depthMaterial = this._depthMaterial = depthMaterialTpl.clone();\n          depthMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n        }\n        return depthMaterial\n      }},\n\n      /**\n       * Utility to get a MeshDistanceMaterial that will honor this derived material\'s vertex\n       * transformations and discarded fragments.\n       */\n      getDistanceMaterial: {value: function() {\n        var distanceMaterial = this._distanceMaterial;\n        if (!distanceMaterial) {\n          if (!distanceMaterialTpl) {\n            distanceMaterialTpl = createDerivedMaterial(\n              baseMaterial.isDerivedMaterial\n                ? baseMaterial.getDistanceMaterial()\n                : new three.MeshDistanceMaterial(),\n              options\n            );\n            distanceMaterialTpl.defines.IS_DISTANCE_MATERIAL = \'\';\n          }\n          distanceMaterial = this._distanceMaterial = distanceMaterialTpl.clone();\n          distanceMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n        }\n        return distanceMaterial\n      }},\n\n      dispose: {value: function value() {\n        var ref = this;\n        var _depthMaterial = ref._depthMaterial;\n        var _distanceMaterial = ref._distanceMaterial;\n        if (_depthMaterial) { _depthMaterial.dispose(); }\n        if (_distanceMaterial) { _distanceMaterial.dispose(); }\n        baseMaterial.dispose.call(this);\n      }}\n    });\n\n    var material = new DerivedMaterial();\n    material.copy(baseMaterial);\n\n    // Merge uniforms, defines, and extensions\n    material.uniforms = assign(three.UniformsUtils.clone(baseMaterial.uniforms || {}), options.uniforms);\n    material.defines = assign({}, baseMaterial.defines, options.defines);\n    material.defines[("TROIKA_DERIVED_MATERIAL_" + id)] = \'\'; //force a program change from the base material\n    material.extensions = assign({}, baseMaterial.extensions, options.extensions);\n\n    cached[optionsHash] = material;\n    return material.clone() //return a clone so changes made to it don\'t affect the cached object\n  }\n\n\n  function upgradeShaders(ref, options, id) {\n    var vertexShader = ref.vertexShader;\n    var fragmentShader = ref.fragmentShader;\n\n    var vertexDefs = options.vertexDefs;\n    var vertexMainIntro = options.vertexMainIntro;\n    var vertexMainOutro = options.vertexMainOutro;\n    var vertexTransform = options.vertexTransform;\n    var fragmentDefs = options.fragmentDefs;\n    var fragmentMainIntro = options.fragmentMainIntro;\n    var fragmentMainOutro = options.fragmentMainOutro;\n    var fragmentColorTransform = options.fragmentColorTransform;\n    var customRewriter = options.customRewriter;\n    var timeUniform = options.timeUniform;\n\n    vertexDefs = vertexDefs || \'\';\n    vertexMainIntro = vertexMainIntro || \'\';\n    vertexMainOutro = vertexMainOutro || \'\';\n    fragmentDefs = fragmentDefs || \'\';\n    fragmentMainIntro = fragmentMainIntro || \'\';\n    fragmentMainOutro = fragmentMainOutro || \'\';\n\n    // Expand includes if needed\n    if (vertexTransform || customRewriter) {\n      vertexShader = expandShaderIncludes(vertexShader);\n    }\n    if (fragmentColorTransform || customRewriter) {\n      // We need to be able to find postprocessing chunks after include expansion in order to\n      // put them after the fragmentColorTransform, so mark them with comments first. Even if\n      // this particular derivation doesn\'t have a fragmentColorTransform, other derivations may,\n      // so we still mark them.\n      fragmentShader = fragmentShader.replace(\n        /^[ \\t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,\n        \'\\n//!BEGIN_POST_CHUNK $1\\n$&\\n//!END_POST_CHUNK\\n\'\n      );\n      fragmentShader = expandShaderIncludes(fragmentShader);\n    }\n\n    // Apply custom rewriter function\n    if (customRewriter) {\n      var res = customRewriter({vertexShader: vertexShader, fragmentShader: fragmentShader});\n      vertexShader = res.vertexShader;\n      fragmentShader = res.fragmentShader;\n    }\n\n    // The fragmentColorTransform needs to go before any postprocessing chunks, so extract\n    // those and re-insert them into the outro in the correct place:\n    if (fragmentColorTransform) {\n      var postChunks = [];\n      fragmentShader = fragmentShader.replace(\n        /^\\/\\/!BEGIN_POST_CHUNK[^]+?^\\/\\/!END_POST_CHUNK/gm, // [^]+? = non-greedy match of any chars including newlines\n        function (match) {\n          postChunks.push(match);\n          return \'\'\n        }\n      );\n      fragmentMainOutro = fragmentColorTransform + "\\n" + (postChunks.join(\'\\n\')) + "\\n" + fragmentMainOutro;\n    }\n\n    // Inject auto-updating time uniform if requested\n    if (timeUniform) {\n      var code = "\\nuniform float " + timeUniform + ";\\n";\n      vertexDefs = code + vertexDefs;\n      fragmentDefs = code + fragmentDefs;\n    }\n\n    // Inject a function for the vertexTransform and rename all usages of position/normal/uv\n    if (vertexTransform) {\n      vertexDefs = vertexDefs + "\\nvec3 troika_position_" + id + ";\\nvec3 troika_normal_" + id + ";\\nvec2 troika_uv_" + id + ";\\nvoid troikaVertexTransform" + id + "(inout vec3 position, inout vec3 normal, inout vec2 uv) {\\n  " + vertexTransform + "\\n}\\n";\n      vertexMainIntro = "\\ntroika_position_" + id + " = vec3(position);\\ntroika_normal_" + id + " = vec3(normal);\\ntroika_uv_" + id + " = vec2(uv);\\ntroikaVertexTransform" + id + "(troika_position_" + id + ", troika_normal_" + id + ", troika_uv_" + id + ");\\n" + vertexMainIntro + "\\n";\n      vertexShader = vertexShader.replace(/\\b(position|normal|uv)\\b/g, function (match, match1, index, fullStr) {\n        return /\\battribute\\s+vec[23]\\s+$/.test(fullStr.substr(0, index)) ? match1 : ("troika_" + match1 + "_" + id)\n      });\n    }\n\n    // Inject defs and intro/outro snippets\n    vertexShader = injectIntoShaderCode(vertexShader, id, vertexDefs, vertexMainIntro, vertexMainOutro);\n    fragmentShader = injectIntoShaderCode(fragmentShader, id, fragmentDefs, fragmentMainIntro, fragmentMainOutro);\n\n    return {\n      vertexShader: vertexShader,\n      fragmentShader: fragmentShader\n    }\n  }\n\n  function injectIntoShaderCode(shaderCode, id, defs, intro, outro) {\n    if (intro || outro || defs) {\n      shaderCode = shaderCode.replace(voidMainRegExp, ("\\n" + defs + "\\nvoid troikaOrigMain" + id + "() {")\n      );\n      shaderCode += "\\nvoid main() {\\n  " + intro + "\\n  troikaOrigMain" + id + "();\\n  " + outro + "\\n}";\n    }\n    return shaderCode\n  }\n\n  function getOptionsHash(options) {\n    return JSON.stringify(options, optionsJsonReplacer)\n  }\n\n  function optionsJsonReplacer(key, value) {\n    return key === \'uniforms\' ? undefined : typeof value === \'function\' ? value.toString() : value\n  }\n\n  var _idCtr = 0;\n  var optionsHashesToIds = new Map();\n  function getIdForOptionsHash(optionsHash) {\n    var id = optionsHashesToIds.get(optionsHash);\n    if (id == null) {\n      optionsHashesToIds.set(optionsHash, (id = ++_idCtr));\n    }\n    return id\n  }\n\n  // Copied from threejs WebGLPrograms.js so we can resolve builtin materials to their shaders\n  // TODO how can we keep this from getting stale?\n  var MATERIAL_TYPES_TO_SHADERS = {\n    MeshDepthMaterial: \'depth\',\n    MeshDistanceMaterial: \'distanceRGBA\',\n    MeshNormalMaterial: \'normal\',\n    MeshBasicMaterial: \'basic\',\n    MeshLambertMaterial: \'lambert\',\n    MeshPhongMaterial: \'phong\',\n    MeshToonMaterial: \'phong\',\n    MeshStandardMaterial: \'physical\',\n    MeshPhysicalMaterial: \'physical\',\n    MeshMatcapMaterial: \'matcap\',\n    LineBasicMaterial: \'basic\',\n    LineDashedMaterial: \'dashed\',\n    PointsMaterial: \'points\',\n    ShadowMaterial: \'shadow\',\n    SpriteMaterial: \'sprite\'\n  };\n\n  /**\n   * Given a Three.js `Material` instance, find the shaders/uniforms that will be\n   * used to render that material.\n   *\n   * @param material - the Material instance\n   * @return {object} - the material\'s shader info: `{uniforms:{}, fragmentShader:\'\', vertexShader:\'\'}`\n   */\n  function getShadersForMaterial(material) {\n    var builtinType = MATERIAL_TYPES_TO_SHADERS[material.type];\n    return builtinType ? three.ShaderLib[builtinType] : material //TODO fallback for unknown type?\n  }\n\n  /**\n   * Find all uniforms and their types within a shader code string.\n   *\n   * @param {string} shader - The shader code to parse\n   * @return {object} mapping of uniform names to their glsl type\n   */\n  function getShaderUniformTypes(shader) {\n    var uniformRE = /\\buniform\\s+(int|float|vec[234])\\s+([A-Za-z_][\\w]*)/g;\n    var uniforms = Object.create(null);\n    var match;\n    while ((match = uniformRE.exec(shader)) !== null) {\n      uniforms[match[2]] = match[1];\n    }\n    return uniforms\n  }\n\n  /**\n   * @class ShaderFloatArray\n   *\n   * When writing a custom WebGL shader, sometimes you need to pass it an array of floating\n   * point numbers that it can read from. Unfortunately this is very difficult to do in WebGL,\n   * because:\n   *\n   *   - GLSL "array" uniforms can only be of a constant length.\n   *   - Textures can only hold floating point numbers in WebGL1 if the `OES_texture_float`\n   *     extension is available.\n   *\n   * ShaderFloatArray is an array-like abstraction that encodes its floating point data into\n   * an RGBA texture\'s four Uint8 components, and provides the corresponding ThreeJS uniforms\n   * and GLSL code for you to put in your custom shader to query the float values by array index.\n   *\n   * This should generally only be used within a fragment shader, as some environments (e.g. iOS)\n   * only allow texture lookups in fragment shaders.\n   *\n   * TODO:\n   *   - Fix texture to fill both dimensions so we don\'t easily hit max texture size limits\n   *   - Use a float texture if the extension is available so we can skip the encoding process\n   */\n  var ShaderFloatArray = function ShaderFloatArray(name) {\n    this.name = name;\n    this.textureUniform = "dataTex_" + name;\n    this.textureSizeUniform = "dataTexSize_" + name;\n    this.multiplierUniform = "dataMultiplier_" + name;\n\n    /**\n     * @property dataSizeUniform - the name of the GLSL uniform that will hold the\n     * length of the data array.\n     * @type {string}\n     */\n    this.dataSizeUniform = "dataSize_" + name;\n\n    /**\n     * @property readFunction - the name of the GLSL function that should be called to\n     * read data out of the array by index.\n     * @type {string}\n     */\n    this.readFunction = "readData_" + name;\n\n    this._raw = new Float32Array(0);\n    this._texture = new three.DataTexture(new Uint8Array(0), 0, 1);\n    this._length = 0;\n    this._multiplier = 1;\n  };\n\n  var prototypeAccessors = { length: { configurable: true } };\n\n  /**\n   * @property length - the current length of the data array\n   * @type {number}\n   */\n  prototypeAccessors.length.set = function (value) {\n    if (value !== this._length) {\n      // Find nearest power-of-2 that holds the new length\n      var size = Math.pow(2, Math.ceil(Math.log2(value)));\n      var raw = this._raw;\n      if (size < raw.length) {\n        this._raw = raw.subarray(0, size);\n      }\n      else if(size > raw.length) {\n        this._raw = new Float32Array(size);\n        this._raw.set(raw);\n      }\n      this._length = value;\n    }\n  };\n  prototypeAccessors.length.get = function () {\n    return this._length\n  };\n\n  /**\n   * Add a value to the end of the data array\n   * @param {number} value\n   */\n  ShaderFloatArray.prototype.push = function push (value) {\n    return this.set(this.length++, value)\n  };\n\n  /**\n   * Replace the existing data with that from a new array\n   * @param {ArrayLike<number>} array\n   */\n  ShaderFloatArray.prototype.setArray = function setArray (array) {\n    this.length = array.length;\n    this._raw.set(array);\n    this._needsRepack = true;\n  };\n\n  /**\n   * Get the current value at index\n   * @param {number} index\n   * @return {number}\n   */\n  ShaderFloatArray.prototype.get = function get (index) {\n    return this._raw[index]\n  };\n\n  ShaderFloatArray.prototype.set = function set (index, value) {\n    if (index + 1 > this._length) {\n      this.length = index + 1;\n    }\n    if (value !== this._raw[index]) {\n      this._raw[index] = value;\n      encodeFloatToFourInts(\n        value / this._multiplier,\n        this._texture.image.data,\n        index * 4\n      );\n      this._needsMultCheck = true;\n    }\n  };\n\n  /**\n   * Make a copy of this ShaderFloatArray\n   * @return {ShaderFloatArray}\n   */\n  ShaderFloatArray.prototype.clone = function clone () {\n    var clone = new ShaderFloatArray(this.name);\n    clone.setArray(this._raw);\n    return clone\n  };\n\n  /**\n   * Retrieve the set of Uniforms that must to be added to the target ShaderMaterial or\n   * DerivedMaterial, to feed the GLSL code generated by {@link #getShaderHeaderCode}.\n   * @return {Object}\n   */\n  ShaderFloatArray.prototype.getShaderUniforms = function getShaderUniforms () {\n      var obj;\n\n    var me = this;\n    return ( obj = {}, obj[this.textureUniform] = {get value() {\n        me._sync();\n        return me._texture\n      }}, obj[this.textureSizeUniform] = {get value() {\n        me._sync();\n        return me._texture.image.width\n      }}, obj[this.dataSizeUniform] = {get value() {\n        me._sync();\n        return me.length\n      }}, obj[this.multiplierUniform] = {get value() {\n        me._sync();\n        return me._multiplier\n      }}, obj )\n  };\n\n  /**\n   * Retrieve the GLSL code that must be injected into the shader\'s definitions area to\n   * enable reading from the data array. This exposes a function with a name matching\n   * the {@link #readFunction} property, which other shader code can call to read values\n   * from the array by their index.\n   * @return {string}\n   */\n  ShaderFloatArray.prototype.getShaderHeaderCode = function getShaderHeaderCode () {\n    var ref = this;\n      var textureUniform = ref.textureUniform;\n      var textureSizeUniform = ref.textureSizeUniform;\n      var dataSizeUniform = ref.dataSizeUniform;\n      var multiplierUniform = ref.multiplierUniform;\n      var readFunction = ref.readFunction;\n    return ("\\nuniform sampler2D " + textureUniform + ";\\nuniform float " + textureSizeUniform + ";\\nuniform float " + dataSizeUniform + ";\\nuniform float " + multiplierUniform + ";\\n\\nfloat " + readFunction + "(float index) {\\n  vec2 texUV = vec2((index + 0.5) / " + textureSizeUniform + ", 0.5);\\n  vec4 pixel = texture2D(" + textureUniform + ", texUV);\\n  return dot(pixel, 1.0 / vec4(1.0, 255.0, 65025.0, 16581375.0)) * " + multiplierUniform + ";\\n}\\n")\n  };\n\n  /**\n   * @private Synchronize any pending changes to the underlying DataTexture\n   */\n  ShaderFloatArray.prototype._sync = function _sync () {\n    var tex = this._texture;\n    var raw = this._raw;\n    var needsRepack = this._needsRepack;\n\n    // If the size of the raw array changed, resize the texture to match\n    if (raw.length !== tex.image.width) {\n      tex.image = {\n        data: new Uint8Array(raw.length * 4),\n        width: raw.length,\n        height: 1\n      };\n      needsRepack = true;\n    }\n\n    // If the values changed, check the multiplier. This should be a value by which\n    // all the values are divided to constrain them to the [0,1] range required by\n    // the Uint8 packing algorithm. We pick the nearest power of 2 that holds the\n    // maximum value for greatest accuracy.\n    if (needsRepack || this._needsMultCheck) {\n      var maxVal = this._raw.reduce(function (a, b) { return Math.max(a, b); }, 0);\n      var mult = Math.pow(2, Math.ceil(Math.log2(maxVal)));\n      if (mult !== this._multiplier) {\n        this._multiplier = mult;\n        needsRepack = true;\n      }\n      tex.needsUpdate = true;\n      this._needsMultCheck = false;\n    }\n\n    // If things changed in a way we need to repack, do so\n    if (needsRepack) {\n      for (var i = 0, len = raw.length, mult$1 = this._multiplier; i < len; i++) {\n        encodeFloatToFourInts(raw[i] / mult$1, tex.image.data, i * 4);\n      }\n      this._needsRepack = false;\n    }\n  };\n\n  Object.defineProperties( ShaderFloatArray.prototype, prototypeAccessors );\n\n\n\n  /**\n   * Encode a floating point number into a set of four 8-bit integers.\n   * Also see the companion decoder function #decodeFloatFromFourInts.\n   *\n   * This is adapted to JavaScript from the basic approach at\n   * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\n   * but writes out integers in the range 0-255 instead of floats in the range 0-1\n   * so they can be more easily used in a Uint8Array for standard WebGL rgba textures.\n   *\n   * Some precision will necessarily be lost during the encoding and decoding process.\n   * Testing shows that the maximum precision error is ~1.18e-10 which should be good\n   * enough for most cases.\n   *\n   * @param {Number} value - the floating point number to encode. Must be in the range [0, 1]\n   *        otherwise the results will be incorrect.\n   * @param {Array|Uint8Array} array - an array into which the four ints should be written\n   * @param {Number} startIndex - index in the output array at which to start writing the ints\n   * @return {Array|Uint8Array}\n   */\n  function encodeFloatToFourInts(value, array, startIndex) {\n    // This is adapted to JS from the basic approach at\n    // http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\n    // but writes to a Uint8Array instead of floats. Input values must be in\n    // the range [0, 1]. The maximum error after encoding and decoding is ~1.18e-10\n    var enc0 = 255 * value;\n    var enc1 = 255 * (enc0 % 1);\n    var enc2 = 255 * (enc1 % 1);\n    var enc3 = 255 * (enc2 % 1);\n\n    enc0 = enc0 & 255;\n    enc1 = enc1 & 255;\n    enc2 = enc2 & 255;\n    enc3 = Math.round(enc3) & 255;\n\n    array[startIndex] = enc0;\n    array[startIndex + 1] = enc1;\n    array[startIndex + 2] = enc2;\n    array[startIndex + 3] = enc3;\n    return array\n  }\n\n  /*\n  Input geometry is a cylinder with r=1, height in y dimension from 0 to 1,\n  divided into a reasonable number of height segments.\n  */\n\n  var vertexDefs = "\\nuniform vec3 pointA;\\nuniform vec3 controlA;\\nuniform vec3 controlB;\\nuniform vec3 pointB;\\nuniform float radius;\\nvarying float bezierT;\\n\\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\\n  float t2 = 1.0 - t;\\n  float b0 = t2 * t2 * t2;\\n  float b1 = 3.0 * t * t2 * t2;\\n  float b2 = 3.0 * t * t * t2;\\n  float b3 = t * t * t;\\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\\n}\\n\\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\\n  float t2 = 1.0 - t;\\n  return -3.0 * p1 * t2 * t2 +\\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\\n    3.0 * p2 * t * t;\\n}\\n";\n\n  var vertexTransform = "\\nfloat t = position.y;\\nbezierT = t;\\nvec3 bezierCenterPos = cubicBezier(pointA, controlA, controlB, pointB, t);\\nvec3 bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\\n\\n// Make \\"sideways\\" always perpendicular to the camera ray; this ensures that any twists\\n// in the cylinder occur where you won\'t see them: \\nvec3 viewDirection = normalMatrix * vec3(0.0, 0.0, 1.0);\\nif (bezierDir == viewDirection) {\\n  bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t == 1.0 ? t - 0.0001 : t + 0.0001));\\n}\\nvec3 sideways = normalize(cross(bezierDir, viewDirection));\\nvec3 upish = normalize(cross(sideways, bezierDir));\\n\\n// Build a matrix for transforming this disc in the cylinder:\\nmat4 discTx;\\ndiscTx[0].xyz = sideways * radius;\\ndiscTx[1].xyz = bezierDir * radius;\\ndiscTx[2].xyz = upish * radius;\\ndiscTx[3].xyz = bezierCenterPos;\\ndiscTx[3][3] = 1.0;\\n\\n// Apply transform, ignoring original y\\nposition = (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\\nnormal = normalize(mat3(discTx) * normal);\\n";\n\n  var fragmentDefs = "\\nuniform vec3 dashing;\\nvarying float bezierT;\\n";\n\n  var fragmentMainIntro = "\\nif (dashing.x + dashing.y > 0.0) {\\n  float dashFrac = mod(bezierT - dashing.z, dashing.x + dashing.y);\\n  if (dashFrac > dashing.x) {\\n    discard;\\n  }\\n}\\n";\n\n  // Debugging: separate color for each of the 6 sides:\n  // const fragmentColorTransform = `\n  // float sideNum = floor(vUV.x * 6.0);\n  // vec3 mixColor = sideNum < 1.0 ? vec3(1.0, 0.0, 0.0) :\n  //   sideNum < 2.0 ? vec3(0.0, 1.0, 1.0) :\n  //   sideNum < 3.0 ? vec3(1.0, 1.0, 0.0) :\n  //   sideNum < 4.0 ? vec3(0.0, 0.0, 1.0) :\n  //   sideNum < 5.0 ? vec3(0.0, 1.0, 0.0) :\n  //   vec3(1.0, 0.0, 1.0);\n  // gl_FragColor.xyz = mix(gl_FragColor.xyz, mixColor, 0.5);\n  // `\n\n\n\n  function createBezierMeshMaterial(baseMaterial) {\n    return createDerivedMaterial(\n      baseMaterial,\n      {\n        uniforms: {\n          pointA: {value: new three.Vector3()},\n          controlA: {value: new three.Vector3()},\n          controlB: {value: new three.Vector3()},\n          pointB: {value: new three.Vector3()},\n          radius: {value: 0.01},\n          dashing: {value: new three.Vector3()} //on, off, offset\n        },\n        vertexDefs: vertexDefs,\n        vertexTransform: vertexTransform,\n        fragmentDefs: fragmentDefs,\n        fragmentMainIntro: fragmentMainIntro\n      }\n    )\n  }\n\n  var geometry = null;\n\n  var defaultBaseMaterial = new three.MeshStandardMaterial({color: 0xffffff, side: three.DoubleSide});\n\n\n  /**\n   * A ThreeJS `Mesh` that bends a tube shape along a 3D cubic bezier path. The bending is done\n   * by deforming a straight cylindrical geometry in the vertex shader based on a set of four\n   * control point uniforms. It patches the necessary GLSL into the mesh\'s assigned `material`\n   * automatically.\n   *\n   * The cubiz bezier path is determined by its four `Vector3` properties:\n   * - `pointA`\n   * - `controlA`\n   * - `controlB`\n   * - `pointB`\n   *\n   * The tube\'s radius is controlled by its `radius` property, which defaults to `0.01`.\n   *\n   * You can also give the tube a dashed appearance with two properties:\n   *\n   * - `dashArray` - an array of two numbers, defining the length of "on" and "off" parts of\n   *   the dash. Each is a 0-1 ratio of the entire path\'s length. (Actually this is the `t` length\n   *   used as input to the cubic bezier function, not its visible length.)\n   * - `dashOffset` - offset of where the dash starts. You can animate this to make the dashes move.\n   *\n   * Note that the dashes will appear like a hollow tube, not solid. This will be more apparent on\n   * thicker tubes.\n   *\n   * TODO: proper geometry bounding sphere and raycasting\n   * TODO: allow control of the geometry\'s segment counts\n   */\n  var BezierMesh = /*@__PURE__*/(function (Mesh) {\n    function BezierMesh() {\n      Mesh.call(\n        this, BezierMesh.getGeometry(),\n        defaultBaseMaterial\n      );\n\n      this.pointA = new three.Vector3();\n      this.controlA = new three.Vector3();\n      this.controlB = new three.Vector3();\n      this.pointB = new three.Vector3();\n      this.radius = 0.01;\n      this.dashArray = new three.Vector2();\n      this.dashOffset = 0;\n\n      // TODO - disabling frustum culling until I figure out how to customize the\n      //  geometry\'s bounding sphere that gets used\n      this.frustumCulled = false;\n    }\n\n    if ( Mesh ) BezierMesh.__proto__ = Mesh;\n    BezierMesh.prototype = Object.create( Mesh && Mesh.prototype );\n    BezierMesh.prototype.constructor = BezierMesh;\n\n    var prototypeAccessors = { material: { configurable: true },customDepthMaterial: { configurable: true },customDistanceMaterial: { configurable: true } };\n\n    // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n    // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n    BezierMesh.getGeometry = function getGeometry () {\n      return geometry || (geometry =\n        new three.CylinderBufferGeometry(1, 1, 1, 6, 64).translate(0, 0.5, 0)\n      )\n    };\n\n    prototypeAccessors.material.get = function () {\n      var derivedMaterial = this._derivedMaterial;\n      var baseMaterial = this._baseMaterial || defaultBaseMaterial;\n      if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\n        derivedMaterial = this._derivedMaterial = createBezierMeshMaterial(baseMaterial);\n        // dispose the derived material when its base material is disposed:\n        baseMaterial.addEventListener(\'dispose\', function onDispose() {\n          baseMaterial.removeEventListener(\'dispose\', onDispose);\n          derivedMaterial.dispose();\n        });\n      }\n      return derivedMaterial\n    };\n    prototypeAccessors.material.set = function (baseMaterial) {\n      this._baseMaterial = baseMaterial;\n    };\n\n    // Create and update material for shadows upon request:\n    prototypeAccessors.customDepthMaterial.get = function () {\n      return this.material.getDepthMaterial()\n    };\n    prototypeAccessors.customDistanceMaterial.get = function () {\n      return this.material.getDistanceMaterial()\n    };\n\n    BezierMesh.prototype.onBeforeRender = function onBeforeRender (shaderInfo) {\n      var ref = this.material;\n      var uniforms = ref.uniforms;\n      var ref$1 = this;\n      var pointA = ref$1.pointA;\n      var controlA = ref$1.controlA;\n      var controlB = ref$1.controlB;\n      var pointB = ref$1.pointB;\n      var radius = ref$1.radius;\n      var dashArray = ref$1.dashArray;\n      var dashOffset = ref$1.dashOffset;\n      uniforms.pointA.value.copy(pointA);\n      uniforms.controlA.value.copy(controlA);\n      uniforms.controlB.value.copy(controlB);\n      uniforms.pointB.value.copy(pointB);\n      uniforms.radius.value = radius;\n      uniforms.dashing.value.set(dashArray.x, dashArray.y, dashOffset || 0);\n    };\n\n    BezierMesh.prototype.raycast = function raycast (raycaster, intersects) {\n      // TODO - just fail for now\n    };\n\n    Object.defineProperties( BezierMesh.prototype, prototypeAccessors );\n\n    return BezierMesh;\n  }(three.Mesh));\n\n  exports.BezierMesh = BezierMesh;\n  exports.ShaderFloatArray = ShaderFloatArray;\n  exports.createDerivedMaterial = createDerivedMaterial;\n  exports.expandShaderIncludes = expandShaderIncludes;\n  exports.getShaderUniformTypes = getShaderUniformTypes;\n  exports.getShadersForMaterial = getShadersForMaterial;\n  exports.voidMainRegExp = voidMainRegExp;\n\n  Object.defineProperty(exports, \'__esModule\', { value: true });\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHJvaWthLXRocmVlLXV0aWxzL2Rpc3QvdHJvaWthLXRocmVlLXV0aWxzLnVtZC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLEVBQUUsS0FBNEQsb0JBQW9CLG1CQUFPLENBQUMsd0RBQU87QUFDakcsRUFBRSxDQUNnRjtBQUNsRixDQUFDLG9DQUFvQzs7QUFFckM7QUFDQSx1REFBdUQ7QUFDdkQsWUFBWTtBQUNaO0FBQ0EsbURBQW1EOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsNkJBQTZCOzs7QUFHN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVEsa0VBQWtFLGtCQUFrQjtBQUN6RyxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVLDRCQUE0QixHQUFHLDhCQUE4QjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWlELGFBQWE7O0FBRTlELENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vYS1wcm9qLWNhbm5vbi1sb2wvLi9ub2RlX21vZHVsZXMvdHJvaWthLXRocmVlLXV0aWxzL2Rpc3QvdHJvaWthLXRocmVlLXV0aWxzLnVtZC5qcz8yYWE2Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgndGhyZWUnKSkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ3RocmVlJ10sIGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC50cm9pa2FfdGhyZWVfdXRpbHMgPSB7fSwgZ2xvYmFsLlRIUkVFKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cywgdGhyZWUpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBSZWd1bGFyIGV4cHJlc3Npb24gZm9yIG1hdGNoaW5nIHRoZSBgdm9pZCBtYWluKCkge2Agb3BlbmVyIGxpbmUgaW4gR0xTTC5cbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICovXG4gIHZhciB2b2lkTWFpblJlZ0V4cCA9IC9cXGJ2b2lkXFxzK21haW5cXHMqXFwoXFxzKlxcKVxccyp7L2c7XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IGV4cGFuZHMgYWxsIGAjaW5jbHVkZSA8eHl6PmAgc3RhdGVtZW50cyB3aXRoaW4gc3RyaW5nIG9mIHNoYWRlciBjb2RlLlxuICAgKiBDb3BpZWQgZnJvbSB0aHJlZSdzIFdlYkdMUHJvZ3JhbSNwYXJzZUluY2x1ZGVzIGZvciBleHRlcm5hbCB1c2UuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgLSBUaGUgR0xTTCBzb3VyY2UgY29kZSB0byBldmFsdWF0ZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBHTFNMIGNvZGUgd2l0aCBhbGwgaW5jbHVkZXMgZXhwYW5kZWRcbiAgICovXG4gIGZ1bmN0aW9uIGV4cGFuZFNoYWRlckluY2x1ZGVzKCBzb3VyY2UgKSB7XG4gICAgdmFyIHBhdHRlcm4gPSAvXlsgXFx0XSojaW5jbHVkZSArPChbXFx3XFxkLi9dKyk+L2dtO1xuICAgIGZ1bmN0aW9uIHJlcGxhY2UobWF0Y2gsIGluY2x1ZGUpIHtcbiAgICAgIHZhciBjaHVuayA9IHRocmVlLlNoYWRlckNodW5rW2luY2x1ZGVdO1xuICAgICAgcmV0dXJuIGNodW5rID8gZXhwYW5kU2hhZGVySW5jbHVkZXMoY2h1bmspIDogbWF0Y2hcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZS5yZXBsYWNlKCBwYXR0ZXJuLCByZXBsYWNlIClcbiAgfVxuXG4gIC8vIExvY2FsIGFzc2lnbiBwb2x5ZmlsbCB0byBhdm9pZCBpbXBvcnRpbmcgdHJvaWthLWNvcmVcbiAgdmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24oLyp0YXJnZXQsIC4uLnNvdXJjZXMqLykge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIHZhciB0YXJnZXQgPSBhcmd1bWVudHNbMF07XG4gICAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50cyQxW2ldO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldFxuICB9O1xuXG5cbiAgdmFyIGVwb2NoID0gRGF0ZS5ub3coKTtcbiAgdmFyIENBQ0hFID0gbmV3IFdlYWtNYXAoKTsgLy90aHJlZWpzIHJlcXVpcmVzIFdlYWtNYXAgaW50ZXJuYWxseSBzbyBzaG91bGQgYmUgc2FmZSB0byBhc3N1bWUgc3VwcG9ydFxuXG5cbiAgLyoqXG4gICAqIEEgdXRpbGl0eSBmb3IgY3JlYXRpbmcgYSBjdXN0b20gc2hhZGVyIG1hdGVyaWFsIGRlcml2ZWQgZnJvbSBhbm90aGVyIG1hdGVyaWFsJ3NcbiAgICogc2hhZGVycy4gVGhpcyBhbGxvd3MgeW91IHRvIGluamVjdCBjdXN0b20gc2hhZGVyIGxvZ2ljIGFuZCB0cmFuc2Zvcm1zIGludG8gdGhlXG4gICAqIGJ1aWx0aW4gVGhyZWVKUyBtYXRlcmlhbHMgd2l0aG91dCBoYXZpbmcgdG8gcmVjcmVhdGUgdGhlbSBmcm9tIHNjcmF0Y2guXG4gICAqXG4gICAqIEBwYXJhbSB7VEhSRUUuTWF0ZXJpYWx9IGJhc2VNYXRlcmlhbCAtIHRoZSBvcmlnaW5hbCBtYXRlcmlhbCB0byBkZXJpdmUgZnJvbVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIEhvdyB0aGUgYmFzZSBtYXRlcmlhbCBzaG91bGQgYmUgbW9kaWZpZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmRlZmluZXMgLSBDdXN0b20gYGRlZmluZXNgIGZvciB0aGUgbWF0ZXJpYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuZXh0ZW5zaW9ucyAtIEN1c3RvbSBgZXh0ZW5zaW9uc2AgZm9yIHRoZSBtYXRlcmlhbCwgZS5nLiBge2Rlcml2YXRpdmVzOiB0cnVlfWBcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMudW5pZm9ybXMgLSBDdXN0b20gYHVuaWZvcm1zYCBmb3IgdXNlIGluIHRoZSBtb2RpZmllZCBzaGFkZXIuIFRoZXNlIGNhblxuICAgKiAgICAgICAgYmUgYWNjZXNzZWQgYW5kIG1hbmlwdWxhdGVkIHZpYSB0aGUgcmVzdWx0aW5nIG1hdGVyaWFsJ3MgYHVuaWZvcm1zYCBwcm9wZXJ0eSwganVzdCBsaWtlXG4gICAqICAgICAgICBpbiBhIFNoYWRlck1hdGVyaWFsLiBZb3UgZG8gbm90IG5lZWQgdG8gcmVwZWF0IHRoZSBiYXNlIG1hdGVyaWFsJ3Mgb3duIHVuaWZvcm1zIGhlcmUuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnRpbWVVbmlmb3JtIC0gSWYgc3BlY2lmaWVkLCBhIHVuaWZvcm0gb2YgdGhpcyBuYW1lIHdpbGwgYmUgaW5qZWN0ZWQgaW50b1xuICAgKiAgICAgICAgYm90aCBzaGFkZXJzLCBhbmQgaXQgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIHVwZGF0ZWQgb24gZWFjaCByZW5kZXIgZnJhbWUgd2l0aCBhIG51bWJlciBvZlxuICAgKiAgICAgICAgZWxhcHNlZCBtaWxsaXNlY29uZHMuIFRoZSBcInplcm9cIiBlcG9jaCB0aW1lIGlzIG5vdCBzaWduaWZpY2FudCBzbyBkb24ndCByZWx5IG9uIHRoaXMgYXMgYVxuICAgKiAgICAgICAgdHJ1ZSBjYWxlbmRhciB0aW1lLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy52ZXJ0ZXhEZWZzIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBpbmplY3QgaW50byB0aGUgdmVydGV4IHNoYWRlcidzIHRvcC1sZXZlbFxuICAgKiAgICAgICAgZGVmaW5pdGlvbnMsIGFib3ZlIHRoZSBgdm9pZCBtYWluKClgIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy52ZXJ0ZXhNYWluSW50cm8gLSBDdXN0b20gR0xTTCBjb2RlIHRvIGluamVjdCBhdCB0aGUgdG9wIG9mIHRoZSB2ZXJ0ZXhcbiAgICogICAgICAgIHNoYWRlcidzIGB2b2lkIG1haW5gIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy52ZXJ0ZXhNYWluT3V0cm8gLSBDdXN0b20gR0xTTCBjb2RlIHRvIGluamVjdCBhdCB0aGUgZW5kIG9mIHRoZSB2ZXJ0ZXhcbiAgICogICAgICAgIHNoYWRlcidzIGB2b2lkIG1haW5gIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy52ZXJ0ZXhUcmFuc2Zvcm0gLSBDdXN0b20gR0xTTCBjb2RlIHRvIG1hbmlwdWxhdGUgdGhlIGBwb3NpdGlvbmAsIGBub3JtYWxgLFxuICAgKiAgICAgICAgYW5kL29yIGB1dmAgdmVydGV4IGF0dHJpYnV0ZXMuIFRoaXMgY29kZSB3aWxsIGJlIHdyYXBwZWQgd2l0aGluIGEgc3RhbmRhbG9uZSBmdW5jdGlvbiB3aXRoXG4gICAqICAgICAgICB0aG9zZSBhdHRyaWJ1dGVzIGV4cG9zZWQgYnkgdGhlaXIgbm9ybWFsIG5hbWVzIGFzIHJlYWQvd3JpdGUgdmFsdWVzLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5mcmFnbWVudERlZnMgLSBDdXN0b20gR0xTTCBjb2RlIHRvIGluamVjdCBpbnRvIHRoZSBmcmFnbWVudCBzaGFkZXIncyB0b3AtbGV2ZWxcbiAgICogICAgICAgIGRlZmluaXRpb25zLCBhYm92ZSB0aGUgYHZvaWQgbWFpbigpYCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuZnJhZ21lbnRNYWluSW50cm8gLSBDdXN0b20gR0xTTCBjb2RlIHRvIGluamVjdCBhdCB0aGUgdG9wIG9mIHRoZSBmcmFnbWVudFxuICAgKiAgICAgICAgc2hhZGVyJ3MgYHZvaWQgbWFpbmAgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmZyYWdtZW50TWFpbk91dHJvIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBpbmplY3QgYXQgdGhlIGVuZCBvZiB0aGUgZnJhZ21lbnRcbiAgICogICAgICAgIHNoYWRlcidzIGB2b2lkIG1haW5gIGZ1bmN0aW9uLiBZb3UgY2FuIG1hbmlwdWxhdGUgYGdsX0ZyYWdDb2xvcmAgaGVyZSBidXQga2VlcCBpbiBtaW5kIGl0IGdvZXNcbiAgICogICAgICAgIGFmdGVyIGFueSBvZiBUaHJlZUpTJ3MgY29sb3IgcG9zdHByb2Nlc3Npbmcgc2hhZGVyIGNodW5rcyAodG9uZW1hcHBpbmcsIGZvZywgZXRjLiksIHNvIGlmIHlvdVxuICAgKiAgICAgICAgd2FudCB0aG9zZSB0byBhcHBseSB0byB5b3VyIGNoYW5nZXMgdXNlIGBmcmFnbWVudENvbG9yVHJhbnNmb3JtYCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5mcmFnbWVudENvbG9yVHJhbnNmb3JtIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBtYW5pcHVsYXRlIHRoZSBgZ2xfRnJhZ0NvbG9yYFxuICAgKiAgICAgICAgb3V0cHV0IHZhbHVlLiBXaWxsIGJlIGluamVjdGVkIG5lYXIgdGhlIGVuZCBvZiB0aGUgYHZvaWQgbWFpbmAgZnVuY3Rpb24sIGJ1dCBiZWZvcmUgYW55XG4gICAqICAgICAgICBvZiBUaHJlZUpTJ3MgY29sb3IgcG9zdHByb2Nlc3Npbmcgc2hhZGVyIGNodW5rcyAodG9uZW1hcHBpbmcsIGZvZywgZXRjLiksIGFuZCBiZWZvcmUgdGhlXG4gICAqICAgICAgICBgZnJhZ21lbnRNYWluT3V0cm9gLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uPHt2ZXJ0ZXhTaGFkZXIsZnJhZ21lbnRTaGFkZXJ9Pjp7dmVydGV4U2hhZGVyLGZyYWdtZW50U2hhZGVyfX0gb3B0aW9ucy5jdXN0b21SZXdyaXRlciAtIEEgZnVuY3Rpb25cbiAgICogICAgICAgIGZvciBwZXJmb3JtaW5nIGN1c3RvbSByZXdyaXRlcyBvZiB0aGUgZnVsbCBzaGFkZXIgY29kZS4gVXNlZnVsIGlmIHlvdSBuZWVkIHRvIGRvIHNvbWV0aGluZ1xuICAgKiAgICAgICAgc3BlY2lhbCB0aGF0J3Mgbm90IGNvdmVyZWQgYnkgdGhlIG90aGVyIGJ1aWx0aW4gb3B0aW9ucy4gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGV4ZWN1dGVkIGJlZm9yZVxuICAgKiAgICAgICAgYW55IG90aGVyIHRyYW5zZm9ybXMgYXJlIGFwcGxpZWQuXG4gICAqXG4gICAqIEByZXR1cm4ge1RIUkVFLk1hdGVyaWFsfVxuICAgKlxuICAgKiBUaGUgcmV0dXJuZWQgbWF0ZXJpYWwgd2lsbCBhbHNvIGhhdmUgdHdvIG5ldyBtZXRob2RzLCBgZ2V0RGVwdGhNYXRlcmlhbCgpYCBhbmQgYGdldERpc3RhbmNlTWF0ZXJpYWwoKWAsXG4gICAqIHdoaWNoIGNhbiBiZSBjYWxsZWQgdG8gZ2V0IGEgdmFyaWFudCBvZiB0aGUgZGVyaXZlZCBtYXRlcmlhbCBmb3IgdXNlIGluIHNoYWRvdyBjYXN0aW5nLiBJZiB0aGVcbiAgICogdGFyZ2V0IG1lc2ggaXMgZXhwZWN0ZWQgdG8gY2FzdCBzaGFkb3dzLCB0aGVuIHlvdSBjYW4gYXNzaWduIHRoZXNlIHRvIHRoZSBtZXNoJ3MgYGN1c3RvbURlcHRoTWF0ZXJpYWxgXG4gICAqIChmb3IgZGlyZWN0aW9uYWwgYW5kIHNwb3QgbGlnaHRzKSBhbmQvb3IgYGN1c3RvbURpc3RhbmNlTWF0ZXJpYWxgIChmb3IgcG9pbnQgbGlnaHRzKSBwcm9wZXJ0aWVzIHRvXG4gICAqIGFsbG93IHRoZSBjYXN0IHNoYWRvdyB0byBob25vciB5b3VyIGRlcml2ZWQgc2hhZGVyJ3MgdmVydGV4IHRyYW5zZm9ybXMgYW5kIGRpc2NhcmRlZCBmcmFnbWVudHMuIFRoZXNlXG4gICAqIHdpbGwgYWxzbyBzZXQgYSBjdXN0b20gYCNkZWZpbmUgSVNfREVQVEhfTUFURVJJQUxgIG9yIGAjZGVmaW5lIElTX0RJU1RBTkNFX01BVEVSSUFMYCB0aGF0IHlvdSBjYW4gbG9va1xuICAgKiBmb3IgaW4geW91ciBkZXJpdmVkIHNoYWRlcnMgd2l0aCBgI2lmZGVmYCB0byBjdXN0b21pemUgdGhlaXIgYmVoYXZpb3IgZm9yIHRoZSBkZXB0aCBvciBkaXN0YW5jZVxuICAgKiBzY2VuYXJpb3MsIGUuZy4gc2tpcHBpbmcgYW50aWFsaWFzaW5nIG9yIGV4cGVuc2l2ZSBzaGFkZXIgbG9naWMuXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVEZXJpdmVkTWF0ZXJpYWwoYmFzZU1hdGVyaWFsLCBvcHRpb25zKSB7XG4gICAgLy8gRmlyc3QgY2hlY2sgdGhlIGNhY2hlIHRvIHNlZSBpZiB3ZSd2ZSBhbHJlYWR5IGRlcml2ZWQgZnJvbSB0aGlzIGJhc2VNYXRlcmlhbCB1c2luZ1xuICAgIC8vIHRoaXMgdW5pcXVlIHNldCBvZiBvcHRpb25zLCBhbmQgaWYgc28ganVzdCByZXR1cm4gYSBjbG9uZSBpbnN0ZWFkIG9mIGEgbmV3IHN1YmNsYXNzXG4gICAgLy8gd2hpY2ggaXMgZmFzdGVyIGFuZCBhbGxvd3MgdGhlaXIgc2hhZGVyIHByb2dyYW0gdG8gYmUgc2hhcmVkIHdoZW4gcmVuZGVyaW5nLlxuICAgIHZhciBvcHRpb25zSGFzaCA9IGdldE9wdGlvbnNIYXNoKG9wdGlvbnMpO1xuICAgIHZhciBjYWNoZWQgPSBDQUNIRS5nZXQoYmFzZU1hdGVyaWFsKTtcbiAgICBpZiAoIWNhY2hlZCkge1xuICAgICAgY2FjaGVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIENBQ0hFLnNldChiYXNlTWF0ZXJpYWwsIGNhY2hlZCk7XG4gICAgfVxuICAgIGlmIChjYWNoZWRbb3B0aW9uc0hhc2hdKSB7XG4gICAgICByZXR1cm4gY2FjaGVkW29wdGlvbnNIYXNoXS5jbG9uZSgpXG4gICAgfVxuXG4gICAgLy8gRXZlbiBpZiBiYXNlTWF0ZXJpYWwgaXMgY2hhbmdpbmcsIHVzZSBhIGNvbnNpc3RlbnQgaWQgaW4gc2hhZGVyIHJld3JpdGVzIGJhc2VkIG9uIHRoZVxuICAgIC8vIG9wdGlvbnNIYXNoLiBUaGlzIG1ha2VzIGl0IG1vcmUgbGlrZWx5IHRoYXQgZGVyaXZpbmcgZnJvbSBiYXNlIG1hdGVyaWFscyBvZiB0aGUgc2FtZVxuICAgIC8vIHR5cGUvY2xhc3MsIGUuZy4gbXVsdGlwbGUgaW5zdGFuY2VzIG9mIE1lc2hTdGFuZGFyZE1hdGVyaWFsLCB3aWxsIHByb2R1Y2UgaWRlbnRpY2FsXG4gICAgLy8gcmV3cml0dGVuIHNoYWRlciBjb2RlIHNvIHRoZXkgY2FuIHNoYXJlIGEgc2luZ2xlIFdlYkdMUHJvZ3JhbSBiZWhpbmQgdGhlIHNjZW5lcy5cbiAgICB2YXIgaWQgPSBnZXRJZEZvck9wdGlvbnNIYXNoKG9wdGlvbnNIYXNoKTtcbiAgICB2YXIgcHJpdmF0ZURlcml2ZWRTaGFkZXJzUHJvcCA9IFwiX2Rlcml2ZWRTaGFkZXJzXCIgKyBpZDtcbiAgICB2YXIgcHJpdmF0ZUJlZm9yZUNvbXBpbGVQcm9wID0gXCJfb25CZWZvcmVDb21waWxlXCIgKyBpZDtcbiAgICB2YXIgZGlzdGFuY2VNYXRlcmlhbFRwbCwgZGVwdGhNYXRlcmlhbFRwbDtcblxuICAgIC8vIFByaXZhdGUgb25CZWZvcmVDb21waWxlIGhhbmRsZXIgdGhhdCBpbmplY3RzIHRoZSBtb2RpZmllZCBzaGFkZXJzIGFuZCB1bmlmb3JtcyB3aGVuXG4gICAgLy8gdGhlIHJlbmRlcmVyIHN3aXRjaGVzIHRvIHRoaXMgbWF0ZXJpYWwncyBwcm9ncmFtXG4gICAgZnVuY3Rpb24gb25CZWZvcmVDb21waWxlKHNoYWRlckluZm8pIHtcbiAgICAgIGJhc2VNYXRlcmlhbC5vbkJlZm9yZUNvbXBpbGUuY2FsbCh0aGlzLCBzaGFkZXJJbmZvKTtcblxuICAgICAgLy8gVXBncmFkZSB0aGUgc2hhZGVycywgY2FjaGluZyB0aGUgcmVzdWx0XG4gICAgICB2YXIgcmVmID0gdGhpc1twcml2YXRlRGVyaXZlZFNoYWRlcnNQcm9wXSB8fCAodGhpc1twcml2YXRlRGVyaXZlZFNoYWRlcnNQcm9wXSA9IHt2ZXJ0ZXg6IHt9LCBmcmFnbWVudDoge319KTtcbiAgICAgIHZhciB2ZXJ0ZXggPSByZWYudmVydGV4O1xuICAgICAgdmFyIGZyYWdtZW50ID0gcmVmLmZyYWdtZW50O1xuICAgICAgaWYgKHZlcnRleC5zb3VyY2UgIT09IHNoYWRlckluZm8udmVydGV4U2hhZGVyIHx8IGZyYWdtZW50LnNvdXJjZSAhPT0gc2hhZGVySW5mby5mcmFnbWVudFNoYWRlcikge1xuICAgICAgICB2YXIgdXBncmFkZWQgPSB1cGdyYWRlU2hhZGVycyhzaGFkZXJJbmZvLCBvcHRpb25zLCBpZCk7XG4gICAgICAgIHZlcnRleC5zb3VyY2UgPSBzaGFkZXJJbmZvLnZlcnRleFNoYWRlcjtcbiAgICAgICAgdmVydGV4LnJlc3VsdCA9IHVwZ3JhZGVkLnZlcnRleFNoYWRlcjtcbiAgICAgICAgZnJhZ21lbnQuc291cmNlID0gc2hhZGVySW5mby5mcmFnbWVudFNoYWRlcjtcbiAgICAgICAgZnJhZ21lbnQucmVzdWx0ID0gdXBncmFkZWQuZnJhZ21lbnRTaGFkZXI7XG4gICAgICB9XG5cbiAgICAgIC8vIEluamVjdCB1cGdyYWRlZCBzaGFkZXJzIGFuZCB1bmlmb3JtcyBpbnRvIHRoZSBwcm9ncmFtXG4gICAgICBzaGFkZXJJbmZvLnZlcnRleFNoYWRlciA9IHZlcnRleC5yZXN1bHQ7XG4gICAgICBzaGFkZXJJbmZvLmZyYWdtZW50U2hhZGVyID0gZnJhZ21lbnQucmVzdWx0O1xuICAgICAgYXNzaWduKHNoYWRlckluZm8udW5pZm9ybXMsIHRoaXMudW5pZm9ybXMpO1xuXG4gICAgICAvLyBJbmplY3QgYXV0by11cGRhdGluZyB0aW1lIHVuaWZvcm0gaWYgcmVxdWVzdGVkXG4gICAgICBpZiAob3B0aW9ucy50aW1lVW5pZm9ybSkge1xuICAgICAgICBzaGFkZXJJbmZvLnVuaWZvcm1zW29wdGlvbnMudGltZVVuaWZvcm1dID0ge1xuICAgICAgICAgIGdldCB2YWx1ZSgpIHtyZXR1cm4gRGF0ZS5ub3coKSAtIGVwb2NofVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBVc2VycyBjYW4gc3RpbGwgYWRkIHRoZWlyIG93biBoYW5kbGVycyBvbiB0b3Agb2Ygb3Vyc1xuICAgICAgaWYgKHRoaXNbcHJpdmF0ZUJlZm9yZUNvbXBpbGVQcm9wXSkge1xuICAgICAgICB0aGlzW3ByaXZhdGVCZWZvcmVDb21waWxlUHJvcF0oc2hhZGVySW5mbyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRGVyaXZlZE1hdGVyaWFsKCkge1xuICAgICAgYmFzZU1hdGVyaWFsLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB0aGlzLl9saXN0ZW5lcnMgPSB1bmRlZmluZWQ7IC8vZG9uJ3QgaW5oZXJpdCBFdmVudERpc3BhdGNoZXIgbGlzdGVuZXJzXG4gICAgfVxuICAgIERlcml2ZWRNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2VNYXRlcmlhbCwge1xuICAgICAgY29uc3RydWN0b3I6IHt2YWx1ZTogRGVyaXZlZE1hdGVyaWFsfSxcbiAgICAgIGlzRGVyaXZlZE1hdGVyaWFsOiB7dmFsdWU6IHRydWV9LFxuICAgICAgYmFzZU1hdGVyaWFsOiB7dmFsdWU6IGJhc2VNYXRlcmlhbH0sXG5cbiAgICAgIG9uQmVmb3JlQ29tcGlsZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gb25CZWZvcmVDb21waWxlXG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGZuKSB7XG4gICAgICAgICAgdGhpc1twcml2YXRlQmVmb3JlQ29tcGlsZVByb3BdID0gZm47XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGNvcHk6IHtcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgICBiYXNlTWF0ZXJpYWwuY29weS5jYWxsKHRoaXMsIHNvdXJjZSk7XG4gICAgICAgICAgaWYgKCFiYXNlTWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCAmJiAhYmFzZU1hdGVyaWFsLmlzRGVyaXZlZE1hdGVyaWFsKSB7XG4gICAgICAgICAgICB0aGlzLmV4dGVuc2lvbnMgPSBhc3NpZ24oe30sIHNvdXJjZS5leHRlbnNpb25zKTtcbiAgICAgICAgICAgIHRoaXMuZGVmaW5lcyA9IGFzc2lnbih7fSwgc291cmNlLmRlZmluZXMpO1xuICAgICAgICAgICAgdGhpcy51bmlmb3JtcyA9IHRocmVlLlVuaWZvcm1zVXRpbHMuY2xvbmUoc291cmNlLnVuaWZvcm1zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVdGlsaXR5IHRvIGdldCBhIE1lc2hEZXB0aE1hdGVyaWFsIHRoYXQgd2lsbCBob25vciB0aGlzIGRlcml2ZWQgbWF0ZXJpYWwncyB2ZXJ0ZXhcbiAgICAgICAqIHRyYW5zZm9ybWF0aW9ucyBhbmQgZGlzY2FyZGVkIGZyYWdtZW50cy5cbiAgICAgICAqL1xuICAgICAgZ2V0RGVwdGhNYXRlcmlhbDoge3ZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRlcHRoTWF0ZXJpYWwgPSB0aGlzLl9kZXB0aE1hdGVyaWFsO1xuICAgICAgICBpZiAoIWRlcHRoTWF0ZXJpYWwpIHtcbiAgICAgICAgICBpZiAoIWRlcHRoTWF0ZXJpYWxUcGwpIHtcbiAgICAgICAgICAgIGRlcHRoTWF0ZXJpYWxUcGwgPSBjcmVhdGVEZXJpdmVkTWF0ZXJpYWwoXG4gICAgICAgICAgICAgIGJhc2VNYXRlcmlhbC5pc0Rlcml2ZWRNYXRlcmlhbFxuICAgICAgICAgICAgICAgID8gYmFzZU1hdGVyaWFsLmdldERlcHRoTWF0ZXJpYWwoKVxuICAgICAgICAgICAgICAgIDogbmV3IHRocmVlLk1lc2hEZXB0aE1hdGVyaWFsKHtkZXB0aFBhY2tpbmc6IHRocmVlLlJHQkFEZXB0aFBhY2tpbmd9KSxcbiAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGRlcHRoTWF0ZXJpYWxUcGwuZGVmaW5lcy5JU19ERVBUSF9NQVRFUklBTCA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZXB0aE1hdGVyaWFsID0gdGhpcy5fZGVwdGhNYXRlcmlhbCA9IGRlcHRoTWF0ZXJpYWxUcGwuY2xvbmUoKTtcbiAgICAgICAgICBkZXB0aE1hdGVyaWFsLnVuaWZvcm1zID0gdGhpcy51bmlmb3JtczsgLy9hdXRvbWF0aWNhbGx5IHJlY2lldmUgc2FtZSB1bmlmb3JtIHZhbHVlc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXB0aE1hdGVyaWFsXG4gICAgICB9fSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVdGlsaXR5IHRvIGdldCBhIE1lc2hEaXN0YW5jZU1hdGVyaWFsIHRoYXQgd2lsbCBob25vciB0aGlzIGRlcml2ZWQgbWF0ZXJpYWwncyB2ZXJ0ZXhcbiAgICAgICAqIHRyYW5zZm9ybWF0aW9ucyBhbmQgZGlzY2FyZGVkIGZyYWdtZW50cy5cbiAgICAgICAqL1xuICAgICAgZ2V0RGlzdGFuY2VNYXRlcmlhbDoge3ZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRpc3RhbmNlTWF0ZXJpYWwgPSB0aGlzLl9kaXN0YW5jZU1hdGVyaWFsO1xuICAgICAgICBpZiAoIWRpc3RhbmNlTWF0ZXJpYWwpIHtcbiAgICAgICAgICBpZiAoIWRpc3RhbmNlTWF0ZXJpYWxUcGwpIHtcbiAgICAgICAgICAgIGRpc3RhbmNlTWF0ZXJpYWxUcGwgPSBjcmVhdGVEZXJpdmVkTWF0ZXJpYWwoXG4gICAgICAgICAgICAgIGJhc2VNYXRlcmlhbC5pc0Rlcml2ZWRNYXRlcmlhbFxuICAgICAgICAgICAgICAgID8gYmFzZU1hdGVyaWFsLmdldERpc3RhbmNlTWF0ZXJpYWwoKVxuICAgICAgICAgICAgICAgIDogbmV3IHRocmVlLk1lc2hEaXN0YW5jZU1hdGVyaWFsKCksXG4gICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBkaXN0YW5jZU1hdGVyaWFsVHBsLmRlZmluZXMuSVNfRElTVEFOQ0VfTUFURVJJQUwgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGlzdGFuY2VNYXRlcmlhbCA9IHRoaXMuX2Rpc3RhbmNlTWF0ZXJpYWwgPSBkaXN0YW5jZU1hdGVyaWFsVHBsLmNsb25lKCk7XG4gICAgICAgICAgZGlzdGFuY2VNYXRlcmlhbC51bmlmb3JtcyA9IHRoaXMudW5pZm9ybXM7IC8vYXV0b21hdGljYWxseSByZWNpZXZlIHNhbWUgdW5pZm9ybSB2YWx1ZXNcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlzdGFuY2VNYXRlcmlhbFxuICAgICAgfX0sXG5cbiAgICAgIGRpc3Bvc2U6IHt2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgICB2YXIgX2RlcHRoTWF0ZXJpYWwgPSByZWYuX2RlcHRoTWF0ZXJpYWw7XG4gICAgICAgIHZhciBfZGlzdGFuY2VNYXRlcmlhbCA9IHJlZi5fZGlzdGFuY2VNYXRlcmlhbDtcbiAgICAgICAgaWYgKF9kZXB0aE1hdGVyaWFsKSB7IF9kZXB0aE1hdGVyaWFsLmRpc3Bvc2UoKTsgfVxuICAgICAgICBpZiAoX2Rpc3RhbmNlTWF0ZXJpYWwpIHsgX2Rpc3RhbmNlTWF0ZXJpYWwuZGlzcG9zZSgpOyB9XG4gICAgICAgIGJhc2VNYXRlcmlhbC5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgICB9fVxuICAgIH0pO1xuXG4gICAgdmFyIG1hdGVyaWFsID0gbmV3IERlcml2ZWRNYXRlcmlhbCgpO1xuICAgIG1hdGVyaWFsLmNvcHkoYmFzZU1hdGVyaWFsKTtcblxuICAgIC8vIE1lcmdlIHVuaWZvcm1zLCBkZWZpbmVzLCBhbmQgZXh0ZW5zaW9uc1xuICAgIG1hdGVyaWFsLnVuaWZvcm1zID0gYXNzaWduKHRocmVlLlVuaWZvcm1zVXRpbHMuY2xvbmUoYmFzZU1hdGVyaWFsLnVuaWZvcm1zIHx8IHt9KSwgb3B0aW9ucy51bmlmb3Jtcyk7XG4gICAgbWF0ZXJpYWwuZGVmaW5lcyA9IGFzc2lnbih7fSwgYmFzZU1hdGVyaWFsLmRlZmluZXMsIG9wdGlvbnMuZGVmaW5lcyk7XG4gICAgbWF0ZXJpYWwuZGVmaW5lc1soXCJUUk9JS0FfREVSSVZFRF9NQVRFUklBTF9cIiArIGlkKV0gPSAnJzsgLy9mb3JjZSBhIHByb2dyYW0gY2hhbmdlIGZyb20gdGhlIGJhc2UgbWF0ZXJpYWxcbiAgICBtYXRlcmlhbC5leHRlbnNpb25zID0gYXNzaWduKHt9LCBiYXNlTWF0ZXJpYWwuZXh0ZW5zaW9ucywgb3B0aW9ucy5leHRlbnNpb25zKTtcblxuICAgIGNhY2hlZFtvcHRpb25zSGFzaF0gPSBtYXRlcmlhbDtcbiAgICByZXR1cm4gbWF0ZXJpYWwuY2xvbmUoKSAvL3JldHVybiBhIGNsb25lIHNvIGNoYW5nZXMgbWFkZSB0byBpdCBkb24ndCBhZmZlY3QgdGhlIGNhY2hlZCBvYmplY3RcbiAgfVxuXG5cbiAgZnVuY3Rpb24gdXBncmFkZVNoYWRlcnMocmVmLCBvcHRpb25zLCBpZCkge1xuICAgIHZhciB2ZXJ0ZXhTaGFkZXIgPSByZWYudmVydGV4U2hhZGVyO1xuICAgIHZhciBmcmFnbWVudFNoYWRlciA9IHJlZi5mcmFnbWVudFNoYWRlcjtcblxuICAgIHZhciB2ZXJ0ZXhEZWZzID0gb3B0aW9ucy52ZXJ0ZXhEZWZzO1xuICAgIHZhciB2ZXJ0ZXhNYWluSW50cm8gPSBvcHRpb25zLnZlcnRleE1haW5JbnRybztcbiAgICB2YXIgdmVydGV4TWFpbk91dHJvID0gb3B0aW9ucy52ZXJ0ZXhNYWluT3V0cm87XG4gICAgdmFyIHZlcnRleFRyYW5zZm9ybSA9IG9wdGlvbnMudmVydGV4VHJhbnNmb3JtO1xuICAgIHZhciBmcmFnbWVudERlZnMgPSBvcHRpb25zLmZyYWdtZW50RGVmcztcbiAgICB2YXIgZnJhZ21lbnRNYWluSW50cm8gPSBvcHRpb25zLmZyYWdtZW50TWFpbkludHJvO1xuICAgIHZhciBmcmFnbWVudE1haW5PdXRybyA9IG9wdGlvbnMuZnJhZ21lbnRNYWluT3V0cm87XG4gICAgdmFyIGZyYWdtZW50Q29sb3JUcmFuc2Zvcm0gPSBvcHRpb25zLmZyYWdtZW50Q29sb3JUcmFuc2Zvcm07XG4gICAgdmFyIGN1c3RvbVJld3JpdGVyID0gb3B0aW9ucy5jdXN0b21SZXdyaXRlcjtcbiAgICB2YXIgdGltZVVuaWZvcm0gPSBvcHRpb25zLnRpbWVVbmlmb3JtO1xuXG4gICAgdmVydGV4RGVmcyA9IHZlcnRleERlZnMgfHwgJyc7XG4gICAgdmVydGV4TWFpbkludHJvID0gdmVydGV4TWFpbkludHJvIHx8ICcnO1xuICAgIHZlcnRleE1haW5PdXRybyA9IHZlcnRleE1haW5PdXRybyB8fCAnJztcbiAgICBmcmFnbWVudERlZnMgPSBmcmFnbWVudERlZnMgfHwgJyc7XG4gICAgZnJhZ21lbnRNYWluSW50cm8gPSBmcmFnbWVudE1haW5JbnRybyB8fCAnJztcbiAgICBmcmFnbWVudE1haW5PdXRybyA9IGZyYWdtZW50TWFpbk91dHJvIHx8ICcnO1xuXG4gICAgLy8gRXhwYW5kIGluY2x1ZGVzIGlmIG5lZWRlZFxuICAgIGlmICh2ZXJ0ZXhUcmFuc2Zvcm0gfHwgY3VzdG9tUmV3cml0ZXIpIHtcbiAgICAgIHZlcnRleFNoYWRlciA9IGV4cGFuZFNoYWRlckluY2x1ZGVzKHZlcnRleFNoYWRlcik7XG4gICAgfVxuICAgIGlmIChmcmFnbWVudENvbG9yVHJhbnNmb3JtIHx8IGN1c3RvbVJld3JpdGVyKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGJlIGFibGUgdG8gZmluZCBwb3N0cHJvY2Vzc2luZyBjaHVua3MgYWZ0ZXIgaW5jbHVkZSBleHBhbnNpb24gaW4gb3JkZXIgdG9cbiAgICAgIC8vIHB1dCB0aGVtIGFmdGVyIHRoZSBmcmFnbWVudENvbG9yVHJhbnNmb3JtLCBzbyBtYXJrIHRoZW0gd2l0aCBjb21tZW50cyBmaXJzdC4gRXZlbiBpZlxuICAgICAgLy8gdGhpcyBwYXJ0aWN1bGFyIGRlcml2YXRpb24gZG9lc24ndCBoYXZlIGEgZnJhZ21lbnRDb2xvclRyYW5zZm9ybSwgb3RoZXIgZGVyaXZhdGlvbnMgbWF5LFxuICAgICAgLy8gc28gd2Ugc3RpbGwgbWFyayB0aGVtLlxuICAgICAgZnJhZ21lbnRTaGFkZXIgPSBmcmFnbWVudFNoYWRlci5yZXBsYWNlKFxuICAgICAgICAvXlsgXFx0XSojaW5jbHVkZSA8KCg/OnRvbmVtYXBwaW5nfGVuY29kaW5nc3xmb2d8cHJlbXVsdGlwbGllZF9hbHBoYXxkaXRoZXJpbmcpX2ZyYWdtZW50KT4vZ20sXG4gICAgICAgICdcXG4vLyFCRUdJTl9QT1NUX0NIVU5LICQxXFxuJCZcXG4vLyFFTkRfUE9TVF9DSFVOS1xcbidcbiAgICAgICk7XG4gICAgICBmcmFnbWVudFNoYWRlciA9IGV4cGFuZFNoYWRlckluY2x1ZGVzKGZyYWdtZW50U2hhZGVyKTtcbiAgICB9XG5cbiAgICAvLyBBcHBseSBjdXN0b20gcmV3cml0ZXIgZnVuY3Rpb25cbiAgICBpZiAoY3VzdG9tUmV3cml0ZXIpIHtcbiAgICAgIHZhciByZXMgPSBjdXN0b21SZXdyaXRlcih7dmVydGV4U2hhZGVyOiB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyOiBmcmFnbWVudFNoYWRlcn0pO1xuICAgICAgdmVydGV4U2hhZGVyID0gcmVzLnZlcnRleFNoYWRlcjtcbiAgICAgIGZyYWdtZW50U2hhZGVyID0gcmVzLmZyYWdtZW50U2hhZGVyO1xuICAgIH1cblxuICAgIC8vIFRoZSBmcmFnbWVudENvbG9yVHJhbnNmb3JtIG5lZWRzIHRvIGdvIGJlZm9yZSBhbnkgcG9zdHByb2Nlc3NpbmcgY2h1bmtzLCBzbyBleHRyYWN0XG4gICAgLy8gdGhvc2UgYW5kIHJlLWluc2VydCB0aGVtIGludG8gdGhlIG91dHJvIGluIHRoZSBjb3JyZWN0IHBsYWNlOlxuICAgIGlmIChmcmFnbWVudENvbG9yVHJhbnNmb3JtKSB7XG4gICAgICB2YXIgcG9zdENodW5rcyA9IFtdO1xuICAgICAgZnJhZ21lbnRTaGFkZXIgPSBmcmFnbWVudFNoYWRlci5yZXBsYWNlKFxuICAgICAgICAvXlxcL1xcLyFCRUdJTl9QT1NUX0NIVU5LW15dKz9eXFwvXFwvIUVORF9QT1NUX0NIVU5LL2dtLCAvLyBbXl0rPyA9IG5vbi1ncmVlZHkgbWF0Y2ggb2YgYW55IGNoYXJzIGluY2x1ZGluZyBuZXdsaW5lc1xuICAgICAgICBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICBwb3N0Q2h1bmtzLnB1c2gobWF0Y2gpO1xuICAgICAgICAgIHJldHVybiAnJ1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgZnJhZ21lbnRNYWluT3V0cm8gPSBmcmFnbWVudENvbG9yVHJhbnNmb3JtICsgXCJcXG5cIiArIChwb3N0Q2h1bmtzLmpvaW4oJ1xcbicpKSArIFwiXFxuXCIgKyBmcmFnbWVudE1haW5PdXRybztcbiAgICB9XG5cbiAgICAvLyBJbmplY3QgYXV0by11cGRhdGluZyB0aW1lIHVuaWZvcm0gaWYgcmVxdWVzdGVkXG4gICAgaWYgKHRpbWVVbmlmb3JtKSB7XG4gICAgICB2YXIgY29kZSA9IFwiXFxudW5pZm9ybSBmbG9hdCBcIiArIHRpbWVVbmlmb3JtICsgXCI7XFxuXCI7XG4gICAgICB2ZXJ0ZXhEZWZzID0gY29kZSArIHZlcnRleERlZnM7XG4gICAgICBmcmFnbWVudERlZnMgPSBjb2RlICsgZnJhZ21lbnREZWZzO1xuICAgIH1cblxuICAgIC8vIEluamVjdCBhIGZ1bmN0aW9uIGZvciB0aGUgdmVydGV4VHJhbnNmb3JtIGFuZCByZW5hbWUgYWxsIHVzYWdlcyBvZiBwb3NpdGlvbi9ub3JtYWwvdXZcbiAgICBpZiAodmVydGV4VHJhbnNmb3JtKSB7XG4gICAgICB2ZXJ0ZXhEZWZzID0gdmVydGV4RGVmcyArIFwiXFxudmVjMyB0cm9pa2FfcG9zaXRpb25fXCIgKyBpZCArIFwiO1xcbnZlYzMgdHJvaWthX25vcm1hbF9cIiArIGlkICsgXCI7XFxudmVjMiB0cm9pa2FfdXZfXCIgKyBpZCArIFwiO1xcbnZvaWQgdHJvaWthVmVydGV4VHJhbnNmb3JtXCIgKyBpZCArIFwiKGlub3V0IHZlYzMgcG9zaXRpb24sIGlub3V0IHZlYzMgbm9ybWFsLCBpbm91dCB2ZWMyIHV2KSB7XFxuICBcIiArIHZlcnRleFRyYW5zZm9ybSArIFwiXFxufVxcblwiO1xuICAgICAgdmVydGV4TWFpbkludHJvID0gXCJcXG50cm9pa2FfcG9zaXRpb25fXCIgKyBpZCArIFwiID0gdmVjMyhwb3NpdGlvbik7XFxudHJvaWthX25vcm1hbF9cIiArIGlkICsgXCIgPSB2ZWMzKG5vcm1hbCk7XFxudHJvaWthX3V2X1wiICsgaWQgKyBcIiA9IHZlYzIodXYpO1xcbnRyb2lrYVZlcnRleFRyYW5zZm9ybVwiICsgaWQgKyBcIih0cm9pa2FfcG9zaXRpb25fXCIgKyBpZCArIFwiLCB0cm9pa2Ffbm9ybWFsX1wiICsgaWQgKyBcIiwgdHJvaWthX3V2X1wiICsgaWQgKyBcIik7XFxuXCIgKyB2ZXJ0ZXhNYWluSW50cm8gKyBcIlxcblwiO1xuICAgICAgdmVydGV4U2hhZGVyID0gdmVydGV4U2hhZGVyLnJlcGxhY2UoL1xcYihwb3NpdGlvbnxub3JtYWx8dXYpXFxiL2csIGZ1bmN0aW9uIChtYXRjaCwgbWF0Y2gxLCBpbmRleCwgZnVsbFN0cikge1xuICAgICAgICByZXR1cm4gL1xcYmF0dHJpYnV0ZVxccyt2ZWNbMjNdXFxzKyQvLnRlc3QoZnVsbFN0ci5zdWJzdHIoMCwgaW5kZXgpKSA/IG1hdGNoMSA6IChcInRyb2lrYV9cIiArIG1hdGNoMSArIFwiX1wiICsgaWQpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBJbmplY3QgZGVmcyBhbmQgaW50cm8vb3V0cm8gc25pcHBldHNcbiAgICB2ZXJ0ZXhTaGFkZXIgPSBpbmplY3RJbnRvU2hhZGVyQ29kZSh2ZXJ0ZXhTaGFkZXIsIGlkLCB2ZXJ0ZXhEZWZzLCB2ZXJ0ZXhNYWluSW50cm8sIHZlcnRleE1haW5PdXRybyk7XG4gICAgZnJhZ21lbnRTaGFkZXIgPSBpbmplY3RJbnRvU2hhZGVyQ29kZShmcmFnbWVudFNoYWRlciwgaWQsIGZyYWdtZW50RGVmcywgZnJhZ21lbnRNYWluSW50cm8sIGZyYWdtZW50TWFpbk91dHJvKTtcblxuICAgIHJldHVybiB7XG4gICAgICB2ZXJ0ZXhTaGFkZXI6IHZlcnRleFNoYWRlcixcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBmcmFnbWVudFNoYWRlclxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluamVjdEludG9TaGFkZXJDb2RlKHNoYWRlckNvZGUsIGlkLCBkZWZzLCBpbnRybywgb3V0cm8pIHtcbiAgICBpZiAoaW50cm8gfHwgb3V0cm8gfHwgZGVmcykge1xuICAgICAgc2hhZGVyQ29kZSA9IHNoYWRlckNvZGUucmVwbGFjZSh2b2lkTWFpblJlZ0V4cCwgKFwiXFxuXCIgKyBkZWZzICsgXCJcXG52b2lkIHRyb2lrYU9yaWdNYWluXCIgKyBpZCArIFwiKCkge1wiKVxuICAgICAgKTtcbiAgICAgIHNoYWRlckNvZGUgKz0gXCJcXG52b2lkIG1haW4oKSB7XFxuICBcIiArIGludHJvICsgXCJcXG4gIHRyb2lrYU9yaWdNYWluXCIgKyBpZCArIFwiKCk7XFxuICBcIiArIG91dHJvICsgXCJcXG59XCI7XG4gICAgfVxuICAgIHJldHVybiBzaGFkZXJDb2RlXG4gIH1cblxuICBmdW5jdGlvbiBnZXRPcHRpb25zSGFzaChvcHRpb25zKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMsIG9wdGlvbnNKc29uUmVwbGFjZXIpXG4gIH1cblxuICBmdW5jdGlvbiBvcHRpb25zSnNvblJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4ga2V5ID09PSAndW5pZm9ybXMnID8gdW5kZWZpbmVkIDogdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gdmFsdWUudG9TdHJpbmcoKSA6IHZhbHVlXG4gIH1cblxuICB2YXIgX2lkQ3RyID0gMDtcbiAgdmFyIG9wdGlvbnNIYXNoZXNUb0lkcyA9IG5ldyBNYXAoKTtcbiAgZnVuY3Rpb24gZ2V0SWRGb3JPcHRpb25zSGFzaChvcHRpb25zSGFzaCkge1xuICAgIHZhciBpZCA9IG9wdGlvbnNIYXNoZXNUb0lkcy5nZXQob3B0aW9uc0hhc2gpO1xuICAgIGlmIChpZCA9PSBudWxsKSB7XG4gICAgICBvcHRpb25zSGFzaGVzVG9JZHMuc2V0KG9wdGlvbnNIYXNoLCAoaWQgPSArK19pZEN0cikpO1xuICAgIH1cbiAgICByZXR1cm4gaWRcbiAgfVxuXG4gIC8vIENvcGllZCBmcm9tIHRocmVlanMgV2ViR0xQcm9ncmFtcy5qcyBzbyB3ZSBjYW4gcmVzb2x2ZSBidWlsdGluIG1hdGVyaWFscyB0byB0aGVpciBzaGFkZXJzXG4gIC8vIFRPRE8gaG93IGNhbiB3ZSBrZWVwIHRoaXMgZnJvbSBnZXR0aW5nIHN0YWxlP1xuICB2YXIgTUFURVJJQUxfVFlQRVNfVE9fU0hBREVSUyA9IHtcbiAgICBNZXNoRGVwdGhNYXRlcmlhbDogJ2RlcHRoJyxcbiAgICBNZXNoRGlzdGFuY2VNYXRlcmlhbDogJ2Rpc3RhbmNlUkdCQScsXG4gICAgTWVzaE5vcm1hbE1hdGVyaWFsOiAnbm9ybWFsJyxcbiAgICBNZXNoQmFzaWNNYXRlcmlhbDogJ2Jhc2ljJyxcbiAgICBNZXNoTGFtYmVydE1hdGVyaWFsOiAnbGFtYmVydCcsXG4gICAgTWVzaFBob25nTWF0ZXJpYWw6ICdwaG9uZycsXG4gICAgTWVzaFRvb25NYXRlcmlhbDogJ3Bob25nJyxcbiAgICBNZXNoU3RhbmRhcmRNYXRlcmlhbDogJ3BoeXNpY2FsJyxcbiAgICBNZXNoUGh5c2ljYWxNYXRlcmlhbDogJ3BoeXNpY2FsJyxcbiAgICBNZXNoTWF0Y2FwTWF0ZXJpYWw6ICdtYXRjYXAnLFxuICAgIExpbmVCYXNpY01hdGVyaWFsOiAnYmFzaWMnLFxuICAgIExpbmVEYXNoZWRNYXRlcmlhbDogJ2Rhc2hlZCcsXG4gICAgUG9pbnRzTWF0ZXJpYWw6ICdwb2ludHMnLFxuICAgIFNoYWRvd01hdGVyaWFsOiAnc2hhZG93JyxcbiAgICBTcHJpdGVNYXRlcmlhbDogJ3Nwcml0ZSdcbiAgfTtcblxuICAvKipcbiAgICogR2l2ZW4gYSBUaHJlZS5qcyBgTWF0ZXJpYWxgIGluc3RhbmNlLCBmaW5kIHRoZSBzaGFkZXJzL3VuaWZvcm1zIHRoYXQgd2lsbCBiZVxuICAgKiB1c2VkIHRvIHJlbmRlciB0aGF0IG1hdGVyaWFsLlxuICAgKlxuICAgKiBAcGFyYW0gbWF0ZXJpYWwgLSB0aGUgTWF0ZXJpYWwgaW5zdGFuY2VcbiAgICogQHJldHVybiB7b2JqZWN0fSAtIHRoZSBtYXRlcmlhbCdzIHNoYWRlciBpbmZvOiBge3VuaWZvcm1zOnt9LCBmcmFnbWVudFNoYWRlcjonJywgdmVydGV4U2hhZGVyOicnfWBcbiAgICovXG4gIGZ1bmN0aW9uIGdldFNoYWRlcnNGb3JNYXRlcmlhbChtYXRlcmlhbCkge1xuICAgIHZhciBidWlsdGluVHlwZSA9IE1BVEVSSUFMX1RZUEVTX1RPX1NIQURFUlNbbWF0ZXJpYWwudHlwZV07XG4gICAgcmV0dXJuIGJ1aWx0aW5UeXBlID8gdGhyZWUuU2hhZGVyTGliW2J1aWx0aW5UeXBlXSA6IG1hdGVyaWFsIC8vVE9ETyBmYWxsYmFjayBmb3IgdW5rbm93biB0eXBlP1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgYWxsIHVuaWZvcm1zIGFuZCB0aGVpciB0eXBlcyB3aXRoaW4gYSBzaGFkZXIgY29kZSBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzaGFkZXIgLSBUaGUgc2hhZGVyIGNvZGUgdG8gcGFyc2VcbiAgICogQHJldHVybiB7b2JqZWN0fSBtYXBwaW5nIG9mIHVuaWZvcm0gbmFtZXMgdG8gdGhlaXIgZ2xzbCB0eXBlXG4gICAqL1xuICBmdW5jdGlvbiBnZXRTaGFkZXJVbmlmb3JtVHlwZXMoc2hhZGVyKSB7XG4gICAgdmFyIHVuaWZvcm1SRSA9IC9cXGJ1bmlmb3JtXFxzKyhpbnR8ZmxvYXR8dmVjWzIzNF0pXFxzKyhbQS1aYS16X11bXFx3XSopL2c7XG4gICAgdmFyIHVuaWZvcm1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgbWF0Y2g7XG4gICAgd2hpbGUgKChtYXRjaCA9IHVuaWZvcm1SRS5leGVjKHNoYWRlcikpICE9PSBudWxsKSB7XG4gICAgICB1bmlmb3Jtc1ttYXRjaFsyXV0gPSBtYXRjaFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHVuaWZvcm1zXG4gIH1cblxuICAvKipcbiAgICogQGNsYXNzIFNoYWRlckZsb2F0QXJyYXlcbiAgICpcbiAgICogV2hlbiB3cml0aW5nIGEgY3VzdG9tIFdlYkdMIHNoYWRlciwgc29tZXRpbWVzIHlvdSBuZWVkIHRvIHBhc3MgaXQgYW4gYXJyYXkgb2YgZmxvYXRpbmdcbiAgICogcG9pbnQgbnVtYmVycyB0aGF0IGl0IGNhbiByZWFkIGZyb20uIFVuZm9ydHVuYXRlbHkgdGhpcyBpcyB2ZXJ5IGRpZmZpY3VsdCB0byBkbyBpbiBXZWJHTCxcbiAgICogYmVjYXVzZTpcbiAgICpcbiAgICogICAtIEdMU0wgXCJhcnJheVwiIHVuaWZvcm1zIGNhbiBvbmx5IGJlIG9mIGEgY29uc3RhbnQgbGVuZ3RoLlxuICAgKiAgIC0gVGV4dHVyZXMgY2FuIG9ubHkgaG9sZCBmbG9hdGluZyBwb2ludCBudW1iZXJzIGluIFdlYkdMMSBpZiB0aGUgYE9FU190ZXh0dXJlX2Zsb2F0YFxuICAgKiAgICAgZXh0ZW5zaW9uIGlzIGF2YWlsYWJsZS5cbiAgICpcbiAgICogU2hhZGVyRmxvYXRBcnJheSBpcyBhbiBhcnJheS1saWtlIGFic3RyYWN0aW9uIHRoYXQgZW5jb2RlcyBpdHMgZmxvYXRpbmcgcG9pbnQgZGF0YSBpbnRvXG4gICAqIGFuIFJHQkEgdGV4dHVyZSdzIGZvdXIgVWludDggY29tcG9uZW50cywgYW5kIHByb3ZpZGVzIHRoZSBjb3JyZXNwb25kaW5nIFRocmVlSlMgdW5pZm9ybXNcbiAgICogYW5kIEdMU0wgY29kZSBmb3IgeW91IHRvIHB1dCBpbiB5b3VyIGN1c3RvbSBzaGFkZXIgdG8gcXVlcnkgdGhlIGZsb2F0IHZhbHVlcyBieSBhcnJheSBpbmRleC5cbiAgICpcbiAgICogVGhpcyBzaG91bGQgZ2VuZXJhbGx5IG9ubHkgYmUgdXNlZCB3aXRoaW4gYSBmcmFnbWVudCBzaGFkZXIsIGFzIHNvbWUgZW52aXJvbm1lbnRzIChlLmcuIGlPUylcbiAgICogb25seSBhbGxvdyB0ZXh0dXJlIGxvb2t1cHMgaW4gZnJhZ21lbnQgc2hhZGVycy5cbiAgICpcbiAgICogVE9ETzpcbiAgICogICAtIEZpeCB0ZXh0dXJlIHRvIGZpbGwgYm90aCBkaW1lbnNpb25zIHNvIHdlIGRvbid0IGVhc2lseSBoaXQgbWF4IHRleHR1cmUgc2l6ZSBsaW1pdHNcbiAgICogICAtIFVzZSBhIGZsb2F0IHRleHR1cmUgaWYgdGhlIGV4dGVuc2lvbiBpcyBhdmFpbGFibGUgc28gd2UgY2FuIHNraXAgdGhlIGVuY29kaW5nIHByb2Nlc3NcbiAgICovXG4gIHZhciBTaGFkZXJGbG9hdEFycmF5ID0gZnVuY3Rpb24gU2hhZGVyRmxvYXRBcnJheShuYW1lKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnRleHR1cmVVbmlmb3JtID0gXCJkYXRhVGV4X1wiICsgbmFtZTtcbiAgICB0aGlzLnRleHR1cmVTaXplVW5pZm9ybSA9IFwiZGF0YVRleFNpemVfXCIgKyBuYW1lO1xuICAgIHRoaXMubXVsdGlwbGllclVuaWZvcm0gPSBcImRhdGFNdWx0aXBsaWVyX1wiICsgbmFtZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBkYXRhU2l6ZVVuaWZvcm0gLSB0aGUgbmFtZSBvZiB0aGUgR0xTTCB1bmlmb3JtIHRoYXQgd2lsbCBob2xkIHRoZVxuICAgICAqIGxlbmd0aCBvZiB0aGUgZGF0YSBhcnJheS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZGF0YVNpemVVbmlmb3JtID0gXCJkYXRhU2l6ZV9cIiArIG5hbWU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgcmVhZEZ1bmN0aW9uIC0gdGhlIG5hbWUgb2YgdGhlIEdMU0wgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkIHRvXG4gICAgICogcmVhZCBkYXRhIG91dCBvZiB0aGUgYXJyYXkgYnkgaW5kZXguXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnJlYWRGdW5jdGlvbiA9IFwicmVhZERhdGFfXCIgKyBuYW1lO1xuXG4gICAgdGhpcy5fcmF3ID0gbmV3IEZsb2F0MzJBcnJheSgwKTtcbiAgICB0aGlzLl90ZXh0dXJlID0gbmV3IHRocmVlLkRhdGFUZXh0dXJlKG5ldyBVaW50OEFycmF5KDApLCAwLCAxKTtcbiAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgIHRoaXMuX211bHRpcGxpZXIgPSAxO1xuICB9O1xuXG4gIHZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGxlbmd0aDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgbGVuZ3RoIC0gdGhlIGN1cnJlbnQgbGVuZ3RoIG9mIHRoZSBkYXRhIGFycmF5XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBwcm90b3R5cGVBY2Nlc3NvcnMubGVuZ3RoLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fbGVuZ3RoKSB7XG4gICAgICAvLyBGaW5kIG5lYXJlc3QgcG93ZXItb2YtMiB0aGF0IGhvbGRzIHRoZSBuZXcgbGVuZ3RoXG4gICAgICB2YXIgc2l6ZSA9IE1hdGgucG93KDIsIE1hdGguY2VpbChNYXRoLmxvZzIodmFsdWUpKSk7XG4gICAgICB2YXIgcmF3ID0gdGhpcy5fcmF3O1xuICAgICAgaWYgKHNpemUgPCByYXcubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX3JhdyA9IHJhdy5zdWJhcnJheSgwLCBzaXplKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYoc2l6ZSA+IHJhdy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fcmF3ID0gbmV3IEZsb2F0MzJBcnJheShzaXplKTtcbiAgICAgICAgdGhpcy5fcmF3LnNldChyYXcpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbGVuZ3RoID0gdmFsdWU7XG4gICAgfVxuICB9O1xuICBwcm90b3R5cGVBY2Nlc3NvcnMubGVuZ3RoLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGVuZ3RoXG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIHZhbHVlIHRvIHRoZSBlbmQgb2YgdGhlIGRhdGEgYXJyYXlcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAqL1xuICBTaGFkZXJGbG9hdEFycmF5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5zZXQodGhpcy5sZW5ndGgrKywgdmFsdWUpXG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcGxhY2UgdGhlIGV4aXN0aW5nIGRhdGEgd2l0aCB0aGF0IGZyb20gYSBuZXcgYXJyYXlcbiAgICogQHBhcmFtIHtBcnJheUxpa2U8bnVtYmVyPn0gYXJyYXlcbiAgICovXG4gIFNoYWRlckZsb2F0QXJyYXkucHJvdG90eXBlLnNldEFycmF5ID0gZnVuY3Rpb24gc2V0QXJyYXkgKGFycmF5KSB7XG4gICAgdGhpcy5sZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgdGhpcy5fcmF3LnNldChhcnJheSk7XG4gICAgdGhpcy5fbmVlZHNSZXBhY2sgPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgdmFsdWUgYXQgaW5kZXhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIFNoYWRlckZsb2F0QXJyYXkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmF3W2luZGV4XVxuICB9O1xuXG4gIFNoYWRlckZsb2F0QXJyYXkucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAoaW5kZXgsIHZhbHVlKSB7XG4gICAgaWYgKGluZGV4ICsgMSA+IHRoaXMuX2xlbmd0aCkge1xuICAgICAgdGhpcy5sZW5ndGggPSBpbmRleCArIDE7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fcmF3W2luZGV4XSkge1xuICAgICAgdGhpcy5fcmF3W2luZGV4XSA9IHZhbHVlO1xuICAgICAgZW5jb2RlRmxvYXRUb0ZvdXJJbnRzKFxuICAgICAgICB2YWx1ZSAvIHRoaXMuX211bHRpcGxpZXIsXG4gICAgICAgIHRoaXMuX3RleHR1cmUuaW1hZ2UuZGF0YSxcbiAgICAgICAgaW5kZXggKiA0XG4gICAgICApO1xuICAgICAgdGhpcy5fbmVlZHNNdWx0Q2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogTWFrZSBhIGNvcHkgb2YgdGhpcyBTaGFkZXJGbG9hdEFycmF5XG4gICAqIEByZXR1cm4ge1NoYWRlckZsb2F0QXJyYXl9XG4gICAqL1xuICBTaGFkZXJGbG9hdEFycmF5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICB2YXIgY2xvbmUgPSBuZXcgU2hhZGVyRmxvYXRBcnJheSh0aGlzLm5hbWUpO1xuICAgIGNsb25lLnNldEFycmF5KHRoaXMuX3Jhdyk7XG4gICAgcmV0dXJuIGNsb25lXG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBzZXQgb2YgVW5pZm9ybXMgdGhhdCBtdXN0IHRvIGJlIGFkZGVkIHRvIHRoZSB0YXJnZXQgU2hhZGVyTWF0ZXJpYWwgb3JcbiAgICogRGVyaXZlZE1hdGVyaWFsLCB0byBmZWVkIHRoZSBHTFNMIGNvZGUgZ2VuZXJhdGVkIGJ5IHtAbGluayAjZ2V0U2hhZGVySGVhZGVyQ29kZX0uXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIFNoYWRlckZsb2F0QXJyYXkucHJvdG90eXBlLmdldFNoYWRlclVuaWZvcm1zID0gZnVuY3Rpb24gZ2V0U2hhZGVyVW5pZm9ybXMgKCkge1xuICAgICAgdmFyIG9iajtcblxuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgcmV0dXJuICggb2JqID0ge30sIG9ialt0aGlzLnRleHR1cmVVbmlmb3JtXSA9IHtnZXQgdmFsdWUoKSB7XG4gICAgICAgIG1lLl9zeW5jKCk7XG4gICAgICAgIHJldHVybiBtZS5fdGV4dHVyZVxuICAgICAgfX0sIG9ialt0aGlzLnRleHR1cmVTaXplVW5pZm9ybV0gPSB7Z2V0IHZhbHVlKCkge1xuICAgICAgICBtZS5fc3luYygpO1xuICAgICAgICByZXR1cm4gbWUuX3RleHR1cmUuaW1hZ2Uud2lkdGhcbiAgICAgIH19LCBvYmpbdGhpcy5kYXRhU2l6ZVVuaWZvcm1dID0ge2dldCB2YWx1ZSgpIHtcbiAgICAgICAgbWUuX3N5bmMoKTtcbiAgICAgICAgcmV0dXJuIG1lLmxlbmd0aFxuICAgICAgfX0sIG9ialt0aGlzLm11bHRpcGxpZXJVbmlmb3JtXSA9IHtnZXQgdmFsdWUoKSB7XG4gICAgICAgIG1lLl9zeW5jKCk7XG4gICAgICAgIHJldHVybiBtZS5fbXVsdGlwbGllclxuICAgICAgfX0sIG9iaiApXG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBHTFNMIGNvZGUgdGhhdCBtdXN0IGJlIGluamVjdGVkIGludG8gdGhlIHNoYWRlcidzIGRlZmluaXRpb25zIGFyZWEgdG9cbiAgICogZW5hYmxlIHJlYWRpbmcgZnJvbSB0aGUgZGF0YSBhcnJheS4gVGhpcyBleHBvc2VzIGEgZnVuY3Rpb24gd2l0aCBhIG5hbWUgbWF0Y2hpbmdcbiAgICogdGhlIHtAbGluayAjcmVhZEZ1bmN0aW9ufSBwcm9wZXJ0eSwgd2hpY2ggb3RoZXIgc2hhZGVyIGNvZGUgY2FuIGNhbGwgdG8gcmVhZCB2YWx1ZXNcbiAgICogZnJvbSB0aGUgYXJyYXkgYnkgdGhlaXIgaW5kZXguXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIFNoYWRlckZsb2F0QXJyYXkucHJvdG90eXBlLmdldFNoYWRlckhlYWRlckNvZGUgPSBmdW5jdGlvbiBnZXRTaGFkZXJIZWFkZXJDb2RlICgpIHtcbiAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgIHZhciB0ZXh0dXJlVW5pZm9ybSA9IHJlZi50ZXh0dXJlVW5pZm9ybTtcbiAgICAgIHZhciB0ZXh0dXJlU2l6ZVVuaWZvcm0gPSByZWYudGV4dHVyZVNpemVVbmlmb3JtO1xuICAgICAgdmFyIGRhdGFTaXplVW5pZm9ybSA9IHJlZi5kYXRhU2l6ZVVuaWZvcm07XG4gICAgICB2YXIgbXVsdGlwbGllclVuaWZvcm0gPSByZWYubXVsdGlwbGllclVuaWZvcm07XG4gICAgICB2YXIgcmVhZEZ1bmN0aW9uID0gcmVmLnJlYWRGdW5jdGlvbjtcbiAgICByZXR1cm4gKFwiXFxudW5pZm9ybSBzYW1wbGVyMkQgXCIgKyB0ZXh0dXJlVW5pZm9ybSArIFwiO1xcbnVuaWZvcm0gZmxvYXQgXCIgKyB0ZXh0dXJlU2l6ZVVuaWZvcm0gKyBcIjtcXG51bmlmb3JtIGZsb2F0IFwiICsgZGF0YVNpemVVbmlmb3JtICsgXCI7XFxudW5pZm9ybSBmbG9hdCBcIiArIG11bHRpcGxpZXJVbmlmb3JtICsgXCI7XFxuXFxuZmxvYXQgXCIgKyByZWFkRnVuY3Rpb24gKyBcIihmbG9hdCBpbmRleCkge1xcbiAgdmVjMiB0ZXhVViA9IHZlYzIoKGluZGV4ICsgMC41KSAvIFwiICsgdGV4dHVyZVNpemVVbmlmb3JtICsgXCIsIDAuNSk7XFxuICB2ZWM0IHBpeGVsID0gdGV4dHVyZTJEKFwiICsgdGV4dHVyZVVuaWZvcm0gKyBcIiwgdGV4VVYpO1xcbiAgcmV0dXJuIGRvdChwaXhlbCwgMS4wIC8gdmVjNCgxLjAsIDI1NS4wLCA2NTAyNS4wLCAxNjU4MTM3NS4wKSkgKiBcIiArIG11bHRpcGxpZXJVbmlmb3JtICsgXCI7XFxufVxcblwiKVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZSBTeW5jaHJvbml6ZSBhbnkgcGVuZGluZyBjaGFuZ2VzIHRvIHRoZSB1bmRlcmx5aW5nIERhdGFUZXh0dXJlXG4gICAqL1xuICBTaGFkZXJGbG9hdEFycmF5LnByb3RvdHlwZS5fc3luYyA9IGZ1bmN0aW9uIF9zeW5jICgpIHtcbiAgICB2YXIgdGV4ID0gdGhpcy5fdGV4dHVyZTtcbiAgICB2YXIgcmF3ID0gdGhpcy5fcmF3O1xuICAgIHZhciBuZWVkc1JlcGFjayA9IHRoaXMuX25lZWRzUmVwYWNrO1xuXG4gICAgLy8gSWYgdGhlIHNpemUgb2YgdGhlIHJhdyBhcnJheSBjaGFuZ2VkLCByZXNpemUgdGhlIHRleHR1cmUgdG8gbWF0Y2hcbiAgICBpZiAocmF3Lmxlbmd0aCAhPT0gdGV4LmltYWdlLndpZHRoKSB7XG4gICAgICB0ZXguaW1hZ2UgPSB7XG4gICAgICAgIGRhdGE6IG5ldyBVaW50OEFycmF5KHJhdy5sZW5ndGggKiA0KSxcbiAgICAgICAgd2lkdGg6IHJhdy5sZW5ndGgsXG4gICAgICAgIGhlaWdodDogMVxuICAgICAgfTtcbiAgICAgIG5lZWRzUmVwYWNrID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdmFsdWVzIGNoYW5nZWQsIGNoZWNrIHRoZSBtdWx0aXBsaWVyLiBUaGlzIHNob3VsZCBiZSBhIHZhbHVlIGJ5IHdoaWNoXG4gICAgLy8gYWxsIHRoZSB2YWx1ZXMgYXJlIGRpdmlkZWQgdG8gY29uc3RyYWluIHRoZW0gdG8gdGhlIFswLDFdIHJhbmdlIHJlcXVpcmVkIGJ5XG4gICAgLy8gdGhlIFVpbnQ4IHBhY2tpbmcgYWxnb3JpdGhtLiBXZSBwaWNrIHRoZSBuZWFyZXN0IHBvd2VyIG9mIDIgdGhhdCBob2xkcyB0aGVcbiAgICAvLyBtYXhpbXVtIHZhbHVlIGZvciBncmVhdGVzdCBhY2N1cmFjeS5cbiAgICBpZiAobmVlZHNSZXBhY2sgfHwgdGhpcy5fbmVlZHNNdWx0Q2hlY2spIHtcbiAgICAgIHZhciBtYXhWYWwgPSB0aGlzLl9yYXcucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBNYXRoLm1heChhLCBiKTsgfSwgMCk7XG4gICAgICB2YXIgbXVsdCA9IE1hdGgucG93KDIsIE1hdGguY2VpbChNYXRoLmxvZzIobWF4VmFsKSkpO1xuICAgICAgaWYgKG11bHQgIT09IHRoaXMuX211bHRpcGxpZXIpIHtcbiAgICAgICAgdGhpcy5fbXVsdGlwbGllciA9IG11bHQ7XG4gICAgICAgIG5lZWRzUmVwYWNrID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRleC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICB0aGlzLl9uZWVkc011bHRDaGVjayA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIElmIHRoaW5ncyBjaGFuZ2VkIGluIGEgd2F5IHdlIG5lZWQgdG8gcmVwYWNrLCBkbyBzb1xuICAgIGlmIChuZWVkc1JlcGFjaykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJhdy5sZW5ndGgsIG11bHQkMSA9IHRoaXMuX211bHRpcGxpZXI7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBlbmNvZGVGbG9hdFRvRm91ckludHMocmF3W2ldIC8gbXVsdCQxLCB0ZXguaW1hZ2UuZGF0YSwgaSAqIDQpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbmVlZHNSZXBhY2sgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFNoYWRlckZsb2F0QXJyYXkucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxuXG5cbiAgLyoqXG4gICAqIEVuY29kZSBhIGZsb2F0aW5nIHBvaW50IG51bWJlciBpbnRvIGEgc2V0IG9mIGZvdXIgOC1iaXQgaW50ZWdlcnMuXG4gICAqIEFsc28gc2VlIHRoZSBjb21wYW5pb24gZGVjb2RlciBmdW5jdGlvbiAjZGVjb2RlRmxvYXRGcm9tRm91ckludHMuXG4gICAqXG4gICAqIFRoaXMgaXMgYWRhcHRlZCB0byBKYXZhU2NyaXB0IGZyb20gdGhlIGJhc2ljIGFwcHJvYWNoIGF0XG4gICAqIGh0dHA6Ly9hcmFzLXAuaW5mby9ibG9nLzIwMDkvMDcvMzAvZW5jb2RpbmctZmxvYXRzLXRvLXJnYmEtdGhlLWZpbmFsL1xuICAgKiBidXQgd3JpdGVzIG91dCBpbnRlZ2VycyBpbiB0aGUgcmFuZ2UgMC0yNTUgaW5zdGVhZCBvZiBmbG9hdHMgaW4gdGhlIHJhbmdlIDAtMVxuICAgKiBzbyB0aGV5IGNhbiBiZSBtb3JlIGVhc2lseSB1c2VkIGluIGEgVWludDhBcnJheSBmb3Igc3RhbmRhcmQgV2ViR0wgcmdiYSB0ZXh0dXJlcy5cbiAgICpcbiAgICogU29tZSBwcmVjaXNpb24gd2lsbCBuZWNlc3NhcmlseSBiZSBsb3N0IGR1cmluZyB0aGUgZW5jb2RpbmcgYW5kIGRlY29kaW5nIHByb2Nlc3MuXG4gICAqIFRlc3Rpbmcgc2hvd3MgdGhhdCB0aGUgbWF4aW11bSBwcmVjaXNpb24gZXJyb3IgaXMgfjEuMThlLTEwIHdoaWNoIHNob3VsZCBiZSBnb29kXG4gICAqIGVub3VnaCBmb3IgbW9zdCBjYXNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gdGhlIGZsb2F0aW5nIHBvaW50IG51bWJlciB0byBlbmNvZGUuIE11c3QgYmUgaW4gdGhlIHJhbmdlIFswLCAxXVxuICAgKiAgICAgICAgb3RoZXJ3aXNlIHRoZSByZXN1bHRzIHdpbGwgYmUgaW5jb3JyZWN0LlxuICAgKiBAcGFyYW0ge0FycmF5fFVpbnQ4QXJyYXl9IGFycmF5IC0gYW4gYXJyYXkgaW50byB3aGljaCB0aGUgZm91ciBpbnRzIHNob3VsZCBiZSB3cml0dGVuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEluZGV4IC0gaW5kZXggaW4gdGhlIG91dHB1dCBhcnJheSBhdCB3aGljaCB0byBzdGFydCB3cml0aW5nIHRoZSBpbnRzXG4gICAqIEByZXR1cm4ge0FycmF5fFVpbnQ4QXJyYXl9XG4gICAqL1xuICBmdW5jdGlvbiBlbmNvZGVGbG9hdFRvRm91ckludHModmFsdWUsIGFycmF5LCBzdGFydEluZGV4KSB7XG4gICAgLy8gVGhpcyBpcyBhZGFwdGVkIHRvIEpTIGZyb20gdGhlIGJhc2ljIGFwcHJvYWNoIGF0XG4gICAgLy8gaHR0cDovL2FyYXMtcC5pbmZvL2Jsb2cvMjAwOS8wNy8zMC9lbmNvZGluZy1mbG9hdHMtdG8tcmdiYS10aGUtZmluYWwvXG4gICAgLy8gYnV0IHdyaXRlcyB0byBhIFVpbnQ4QXJyYXkgaW5zdGVhZCBvZiBmbG9hdHMuIElucHV0IHZhbHVlcyBtdXN0IGJlIGluXG4gICAgLy8gdGhlIHJhbmdlIFswLCAxXS4gVGhlIG1heGltdW0gZXJyb3IgYWZ0ZXIgZW5jb2RpbmcgYW5kIGRlY29kaW5nIGlzIH4xLjE4ZS0xMFxuICAgIHZhciBlbmMwID0gMjU1ICogdmFsdWU7XG4gICAgdmFyIGVuYzEgPSAyNTUgKiAoZW5jMCAlIDEpO1xuICAgIHZhciBlbmMyID0gMjU1ICogKGVuYzEgJSAxKTtcbiAgICB2YXIgZW5jMyA9IDI1NSAqIChlbmMyICUgMSk7XG5cbiAgICBlbmMwID0gZW5jMCAmIDI1NTtcbiAgICBlbmMxID0gZW5jMSAmIDI1NTtcbiAgICBlbmMyID0gZW5jMiAmIDI1NTtcbiAgICBlbmMzID0gTWF0aC5yb3VuZChlbmMzKSAmIDI1NTtcblxuICAgIGFycmF5W3N0YXJ0SW5kZXhdID0gZW5jMDtcbiAgICBhcnJheVtzdGFydEluZGV4ICsgMV0gPSBlbmMxO1xuICAgIGFycmF5W3N0YXJ0SW5kZXggKyAyXSA9IGVuYzI7XG4gICAgYXJyYXlbc3RhcnRJbmRleCArIDNdID0gZW5jMztcbiAgICByZXR1cm4gYXJyYXlcbiAgfVxuXG4gIC8qXG4gIElucHV0IGdlb21ldHJ5IGlzIGEgY3lsaW5kZXIgd2l0aCByPTEsIGhlaWdodCBpbiB5IGRpbWVuc2lvbiBmcm9tIDAgdG8gMSxcbiAgZGl2aWRlZCBpbnRvIGEgcmVhc29uYWJsZSBudW1iZXIgb2YgaGVpZ2h0IHNlZ21lbnRzLlxuICAqL1xuXG4gIHZhciB2ZXJ0ZXhEZWZzID0gXCJcXG51bmlmb3JtIHZlYzMgcG9pbnRBO1xcbnVuaWZvcm0gdmVjMyBjb250cm9sQTtcXG51bmlmb3JtIHZlYzMgY29udHJvbEI7XFxudW5pZm9ybSB2ZWMzIHBvaW50QjtcXG51bmlmb3JtIGZsb2F0IHJhZGl1cztcXG52YXJ5aW5nIGZsb2F0IGJlemllclQ7XFxuXFxudmVjMyBjdWJpY0Jlemllcih2ZWMzIHAxLCB2ZWMzIGMxLCB2ZWMzIGMyLCB2ZWMzIHAyLCBmbG9hdCB0KSB7XFxuICBmbG9hdCB0MiA9IDEuMCAtIHQ7XFxuICBmbG9hdCBiMCA9IHQyICogdDIgKiB0MjtcXG4gIGZsb2F0IGIxID0gMy4wICogdCAqIHQyICogdDI7XFxuICBmbG9hdCBiMiA9IDMuMCAqIHQgKiB0ICogdDI7XFxuICBmbG9hdCBiMyA9IHQgKiB0ICogdDtcXG4gIHJldHVybiBiMCAqIHAxICsgYjEgKiBjMSArIGIyICogYzIgKyBiMyAqIHAyO1xcbn1cXG5cXG52ZWMzIGN1YmljQmV6aWVyRGVyaXZhdGl2ZSh2ZWMzIHAxLCB2ZWMzIGMxLCB2ZWMzIGMyLCB2ZWMzIHAyLCBmbG9hdCB0KSB7XFxuICBmbG9hdCB0MiA9IDEuMCAtIHQ7XFxuICByZXR1cm4gLTMuMCAqIHAxICogdDIgKiB0MiArXFxuICAgIGMxICogKDMuMCAqIHQyICogdDIgLSA2LjAgKiB0MiAqIHQpICtcXG4gICAgYzIgKiAoNi4wICogdDIgKiB0IC0gMy4wICogdCAqIHQpICtcXG4gICAgMy4wICogcDIgKiB0ICogdDtcXG59XFxuXCI7XG5cbiAgdmFyIHZlcnRleFRyYW5zZm9ybSA9IFwiXFxuZmxvYXQgdCA9IHBvc2l0aW9uLnk7XFxuYmV6aWVyVCA9IHQ7XFxudmVjMyBiZXppZXJDZW50ZXJQb3MgPSBjdWJpY0Jlemllcihwb2ludEEsIGNvbnRyb2xBLCBjb250cm9sQiwgcG9pbnRCLCB0KTtcXG52ZWMzIGJlemllckRpciA9IG5vcm1hbGl6ZShjdWJpY0JlemllckRlcml2YXRpdmUocG9pbnRBLCBjb250cm9sQSwgY29udHJvbEIsIHBvaW50QiwgdCkpO1xcblxcbi8vIE1ha2UgXFxcInNpZGV3YXlzXFxcIiBhbHdheXMgcGVycGVuZGljdWxhciB0byB0aGUgY2FtZXJhIHJheTsgdGhpcyBlbnN1cmVzIHRoYXQgYW55IHR3aXN0c1xcbi8vIGluIHRoZSBjeWxpbmRlciBvY2N1ciB3aGVyZSB5b3Ugd29uJ3Qgc2VlIHRoZW06IFxcbnZlYzMgdmlld0RpcmVjdGlvbiA9IG5vcm1hbE1hdHJpeCAqIHZlYzMoMC4wLCAwLjAsIDEuMCk7XFxuaWYgKGJlemllckRpciA9PSB2aWV3RGlyZWN0aW9uKSB7XFxuICBiZXppZXJEaXIgPSBub3JtYWxpemUoY3ViaWNCZXppZXJEZXJpdmF0aXZlKHBvaW50QSwgY29udHJvbEEsIGNvbnRyb2xCLCBwb2ludEIsIHQgPT0gMS4wID8gdCAtIDAuMDAwMSA6IHQgKyAwLjAwMDEpKTtcXG59XFxudmVjMyBzaWRld2F5cyA9IG5vcm1hbGl6ZShjcm9zcyhiZXppZXJEaXIsIHZpZXdEaXJlY3Rpb24pKTtcXG52ZWMzIHVwaXNoID0gbm9ybWFsaXplKGNyb3NzKHNpZGV3YXlzLCBiZXppZXJEaXIpKTtcXG5cXG4vLyBCdWlsZCBhIG1hdHJpeCBmb3IgdHJhbnNmb3JtaW5nIHRoaXMgZGlzYyBpbiB0aGUgY3lsaW5kZXI6XFxubWF0NCBkaXNjVHg7XFxuZGlzY1R4WzBdLnh5eiA9IHNpZGV3YXlzICogcmFkaXVzO1xcbmRpc2NUeFsxXS54eXogPSBiZXppZXJEaXIgKiByYWRpdXM7XFxuZGlzY1R4WzJdLnh5eiA9IHVwaXNoICogcmFkaXVzO1xcbmRpc2NUeFszXS54eXogPSBiZXppZXJDZW50ZXJQb3M7XFxuZGlzY1R4WzNdWzNdID0gMS4wO1xcblxcbi8vIEFwcGx5IHRyYW5zZm9ybSwgaWdub3Jpbmcgb3JpZ2luYWwgeVxcbnBvc2l0aW9uID0gKGRpc2NUeCAqIHZlYzQocG9zaXRpb24ueCwgMC4wLCBwb3NpdGlvbi56LCAxLjApKS54eXo7XFxubm9ybWFsID0gbm9ybWFsaXplKG1hdDMoZGlzY1R4KSAqIG5vcm1hbCk7XFxuXCI7XG5cbiAgdmFyIGZyYWdtZW50RGVmcyA9IFwiXFxudW5pZm9ybSB2ZWMzIGRhc2hpbmc7XFxudmFyeWluZyBmbG9hdCBiZXppZXJUO1xcblwiO1xuXG4gIHZhciBmcmFnbWVudE1haW5JbnRybyA9IFwiXFxuaWYgKGRhc2hpbmcueCArIGRhc2hpbmcueSA+IDAuMCkge1xcbiAgZmxvYXQgZGFzaEZyYWMgPSBtb2QoYmV6aWVyVCAtIGRhc2hpbmcueiwgZGFzaGluZy54ICsgZGFzaGluZy55KTtcXG4gIGlmIChkYXNoRnJhYyA+IGRhc2hpbmcueCkge1xcbiAgICBkaXNjYXJkO1xcbiAgfVxcbn1cXG5cIjtcblxuICAvLyBEZWJ1Z2dpbmc6IHNlcGFyYXRlIGNvbG9yIGZvciBlYWNoIG9mIHRoZSA2IHNpZGVzOlxuICAvLyBjb25zdCBmcmFnbWVudENvbG9yVHJhbnNmb3JtID0gYFxuICAvLyBmbG9hdCBzaWRlTnVtID0gZmxvb3IodlVWLnggKiA2LjApO1xuICAvLyB2ZWMzIG1peENvbG9yID0gc2lkZU51bSA8IDEuMCA/IHZlYzMoMS4wLCAwLjAsIDAuMCkgOlxuICAvLyAgIHNpZGVOdW0gPCAyLjAgPyB2ZWMzKDAuMCwgMS4wLCAxLjApIDpcbiAgLy8gICBzaWRlTnVtIDwgMy4wID8gdmVjMygxLjAsIDEuMCwgMC4wKSA6XG4gIC8vICAgc2lkZU51bSA8IDQuMCA/IHZlYzMoMC4wLCAwLjAsIDEuMCkgOlxuICAvLyAgIHNpZGVOdW0gPCA1LjAgPyB2ZWMzKDAuMCwgMS4wLCAwLjApIDpcbiAgLy8gICB2ZWMzKDEuMCwgMC4wLCAxLjApO1xuICAvLyBnbF9GcmFnQ29sb3IueHl6ID0gbWl4KGdsX0ZyYWdDb2xvci54eXosIG1peENvbG9yLCAwLjUpO1xuICAvLyBgXG5cblxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUJlemllck1lc2hNYXRlcmlhbChiYXNlTWF0ZXJpYWwpIHtcbiAgICByZXR1cm4gY3JlYXRlRGVyaXZlZE1hdGVyaWFsKFxuICAgICAgYmFzZU1hdGVyaWFsLFxuICAgICAge1xuICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgIHBvaW50QToge3ZhbHVlOiBuZXcgdGhyZWUuVmVjdG9yMygpfSxcbiAgICAgICAgICBjb250cm9sQToge3ZhbHVlOiBuZXcgdGhyZWUuVmVjdG9yMygpfSxcbiAgICAgICAgICBjb250cm9sQjoge3ZhbHVlOiBuZXcgdGhyZWUuVmVjdG9yMygpfSxcbiAgICAgICAgICBwb2ludEI6IHt2YWx1ZTogbmV3IHRocmVlLlZlY3RvcjMoKX0sXG4gICAgICAgICAgcmFkaXVzOiB7dmFsdWU6IDAuMDF9LFxuICAgICAgICAgIGRhc2hpbmc6IHt2YWx1ZTogbmV3IHRocmVlLlZlY3RvcjMoKX0gLy9vbiwgb2ZmLCBvZmZzZXRcbiAgICAgICAgfSxcbiAgICAgICAgdmVydGV4RGVmczogdmVydGV4RGVmcyxcbiAgICAgICAgdmVydGV4VHJhbnNmb3JtOiB2ZXJ0ZXhUcmFuc2Zvcm0sXG4gICAgICAgIGZyYWdtZW50RGVmczogZnJhZ21lbnREZWZzLFxuICAgICAgICBmcmFnbWVudE1haW5JbnRybzogZnJhZ21lbnRNYWluSW50cm9cbiAgICAgIH1cbiAgICApXG4gIH1cblxuICB2YXIgZ2VvbWV0cnkgPSBudWxsO1xuXG4gIHZhciBkZWZhdWx0QmFzZU1hdGVyaWFsID0gbmV3IHRocmVlLk1lc2hTdGFuZGFyZE1hdGVyaWFsKHtjb2xvcjogMHhmZmZmZmYsIHNpZGU6IHRocmVlLkRvdWJsZVNpZGV9KTtcblxuXG4gIC8qKlxuICAgKiBBIFRocmVlSlMgYE1lc2hgIHRoYXQgYmVuZHMgYSB0dWJlIHNoYXBlIGFsb25nIGEgM0QgY3ViaWMgYmV6aWVyIHBhdGguIFRoZSBiZW5kaW5nIGlzIGRvbmVcbiAgICogYnkgZGVmb3JtaW5nIGEgc3RyYWlnaHQgY3lsaW5kcmljYWwgZ2VvbWV0cnkgaW4gdGhlIHZlcnRleCBzaGFkZXIgYmFzZWQgb24gYSBzZXQgb2YgZm91clxuICAgKiBjb250cm9sIHBvaW50IHVuaWZvcm1zLiBJdCBwYXRjaGVzIHRoZSBuZWNlc3NhcnkgR0xTTCBpbnRvIHRoZSBtZXNoJ3MgYXNzaWduZWQgYG1hdGVyaWFsYFxuICAgKiBhdXRvbWF0aWNhbGx5LlxuICAgKlxuICAgKiBUaGUgY3ViaXogYmV6aWVyIHBhdGggaXMgZGV0ZXJtaW5lZCBieSBpdHMgZm91ciBgVmVjdG9yM2AgcHJvcGVydGllczpcbiAgICogLSBgcG9pbnRBYFxuICAgKiAtIGBjb250cm9sQWBcbiAgICogLSBgY29udHJvbEJgXG4gICAqIC0gYHBvaW50QmBcbiAgICpcbiAgICogVGhlIHR1YmUncyByYWRpdXMgaXMgY29udHJvbGxlZCBieSBpdHMgYHJhZGl1c2AgcHJvcGVydHksIHdoaWNoIGRlZmF1bHRzIHRvIGAwLjAxYC5cbiAgICpcbiAgICogWW91IGNhbiBhbHNvIGdpdmUgdGhlIHR1YmUgYSBkYXNoZWQgYXBwZWFyYW5jZSB3aXRoIHR3byBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAtIGBkYXNoQXJyYXlgIC0gYW4gYXJyYXkgb2YgdHdvIG51bWJlcnMsIGRlZmluaW5nIHRoZSBsZW5ndGggb2YgXCJvblwiIGFuZCBcIm9mZlwiIHBhcnRzIG9mXG4gICAqICAgdGhlIGRhc2guIEVhY2ggaXMgYSAwLTEgcmF0aW8gb2YgdGhlIGVudGlyZSBwYXRoJ3MgbGVuZ3RoLiAoQWN0dWFsbHkgdGhpcyBpcyB0aGUgYHRgIGxlbmd0aFxuICAgKiAgIHVzZWQgYXMgaW5wdXQgdG8gdGhlIGN1YmljIGJlemllciBmdW5jdGlvbiwgbm90IGl0cyB2aXNpYmxlIGxlbmd0aC4pXG4gICAqIC0gYGRhc2hPZmZzZXRgIC0gb2Zmc2V0IG9mIHdoZXJlIHRoZSBkYXNoIHN0YXJ0cy4gWW91IGNhbiBhbmltYXRlIHRoaXMgdG8gbWFrZSB0aGUgZGFzaGVzIG1vdmUuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgZGFzaGVzIHdpbGwgYXBwZWFyIGxpa2UgYSBob2xsb3cgdHViZSwgbm90IHNvbGlkLiBUaGlzIHdpbGwgYmUgbW9yZSBhcHBhcmVudCBvblxuICAgKiB0aGlja2VyIHR1YmVzLlxuICAgKlxuICAgKiBUT0RPOiBwcm9wZXIgZ2VvbWV0cnkgYm91bmRpbmcgc3BoZXJlIGFuZCByYXljYXN0aW5nXG4gICAqIFRPRE86IGFsbG93IGNvbnRyb2wgb2YgdGhlIGdlb21ldHJ5J3Mgc2VnbWVudCBjb3VudHNcbiAgICovXG4gIHZhciBCZXppZXJNZXNoID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoTWVzaCkge1xuICAgIGZ1bmN0aW9uIEJlemllck1lc2goKSB7XG4gICAgICBNZXNoLmNhbGwoXG4gICAgICAgIHRoaXMsIEJlemllck1lc2guZ2V0R2VvbWV0cnkoKSxcbiAgICAgICAgZGVmYXVsdEJhc2VNYXRlcmlhbFxuICAgICAgKTtcblxuICAgICAgdGhpcy5wb2ludEEgPSBuZXcgdGhyZWUuVmVjdG9yMygpO1xuICAgICAgdGhpcy5jb250cm9sQSA9IG5ldyB0aHJlZS5WZWN0b3IzKCk7XG4gICAgICB0aGlzLmNvbnRyb2xCID0gbmV3IHRocmVlLlZlY3RvcjMoKTtcbiAgICAgIHRoaXMucG9pbnRCID0gbmV3IHRocmVlLlZlY3RvcjMoKTtcbiAgICAgIHRoaXMucmFkaXVzID0gMC4wMTtcbiAgICAgIHRoaXMuZGFzaEFycmF5ID0gbmV3IHRocmVlLlZlY3RvcjIoKTtcbiAgICAgIHRoaXMuZGFzaE9mZnNldCA9IDA7XG5cbiAgICAgIC8vIFRPRE8gLSBkaXNhYmxpbmcgZnJ1c3R1bSBjdWxsaW5nIHVudGlsIEkgZmlndXJlIG91dCBob3cgdG8gY3VzdG9taXplIHRoZVxuICAgICAgLy8gIGdlb21ldHJ5J3MgYm91bmRpbmcgc3BoZXJlIHRoYXQgZ2V0cyB1c2VkXG4gICAgICB0aGlzLmZydXN0dW1DdWxsZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIE1lc2ggKSBCZXppZXJNZXNoLl9fcHJvdG9fXyA9IE1lc2g7XG4gICAgQmV6aWVyTWVzaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNZXNoICYmIE1lc2gucHJvdG90eXBlICk7XG4gICAgQmV6aWVyTWVzaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCZXppZXJNZXNoO1xuXG4gICAgdmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgbWF0ZXJpYWw6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sY3VzdG9tRGVwdGhNYXRlcmlhbDogeyBjb25maWd1cmFibGU6IHRydWUgfSxjdXN0b21EaXN0YW5jZU1hdGVyaWFsOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbiAgICAvLyBIYW5kbGVyIGZvciBhdXRvbWF0aWNhbGx5IHdyYXBwaW5nIHRoZSBiYXNlIG1hdGVyaWFsIHdpdGggb3VyIHVwZ3JhZGVzLiBXZSBkbyB0aGUgd3JhcHBpbmdcbiAgICAvLyBsYXppbHkgb24gX3JlYWRfIHJhdGhlciB0aGFuIHdyaXRlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdyYXBwaW5nIG9uIHRyYW5zaWVudCB2YWx1ZXMuXG4gICAgQmV6aWVyTWVzaC5nZXRHZW9tZXRyeSA9IGZ1bmN0aW9uIGdldEdlb21ldHJ5ICgpIHtcbiAgICAgIHJldHVybiBnZW9tZXRyeSB8fCAoZ2VvbWV0cnkgPVxuICAgICAgICBuZXcgdGhyZWUuQ3lsaW5kZXJCdWZmZXJHZW9tZXRyeSgxLCAxLCAxLCA2LCA2NCkudHJhbnNsYXRlKDAsIDAuNSwgMClcbiAgICAgIClcbiAgICB9O1xuXG4gICAgcHJvdG90eXBlQWNjZXNzb3JzLm1hdGVyaWFsLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkZXJpdmVkTWF0ZXJpYWwgPSB0aGlzLl9kZXJpdmVkTWF0ZXJpYWw7XG4gICAgICB2YXIgYmFzZU1hdGVyaWFsID0gdGhpcy5fYmFzZU1hdGVyaWFsIHx8IGRlZmF1bHRCYXNlTWF0ZXJpYWw7XG4gICAgICBpZiAoIWRlcml2ZWRNYXRlcmlhbCB8fCBkZXJpdmVkTWF0ZXJpYWwuYmFzZU1hdGVyaWFsICE9PSBiYXNlTWF0ZXJpYWwpIHtcbiAgICAgICAgZGVyaXZlZE1hdGVyaWFsID0gdGhpcy5fZGVyaXZlZE1hdGVyaWFsID0gY3JlYXRlQmV6aWVyTWVzaE1hdGVyaWFsKGJhc2VNYXRlcmlhbCk7XG4gICAgICAgIC8vIGRpc3Bvc2UgdGhlIGRlcml2ZWQgbWF0ZXJpYWwgd2hlbiBpdHMgYmFzZSBtYXRlcmlhbCBpcyBkaXNwb3NlZDpcbiAgICAgICAgYmFzZU1hdGVyaWFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBmdW5jdGlvbiBvbkRpc3Bvc2UoKSB7XG4gICAgICAgICAgYmFzZU1hdGVyaWFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBvbkRpc3Bvc2UpO1xuICAgICAgICAgIGRlcml2ZWRNYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlcml2ZWRNYXRlcmlhbFxuICAgIH07XG4gICAgcHJvdG90eXBlQWNjZXNzb3JzLm1hdGVyaWFsLnNldCA9IGZ1bmN0aW9uIChiYXNlTWF0ZXJpYWwpIHtcbiAgICAgIHRoaXMuX2Jhc2VNYXRlcmlhbCA9IGJhc2VNYXRlcmlhbDtcbiAgICB9O1xuXG4gICAgLy8gQ3JlYXRlIGFuZCB1cGRhdGUgbWF0ZXJpYWwgZm9yIHNoYWRvd3MgdXBvbiByZXF1ZXN0OlxuICAgIHByb3RvdHlwZUFjY2Vzc29ycy5jdXN0b21EZXB0aE1hdGVyaWFsLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hdGVyaWFsLmdldERlcHRoTWF0ZXJpYWwoKVxuICAgIH07XG4gICAgcHJvdG90eXBlQWNjZXNzb3JzLmN1c3RvbURpc3RhbmNlTWF0ZXJpYWwuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWF0ZXJpYWwuZ2V0RGlzdGFuY2VNYXRlcmlhbCgpXG4gICAgfTtcblxuICAgIEJlemllck1lc2gucHJvdG90eXBlLm9uQmVmb3JlUmVuZGVyID0gZnVuY3Rpb24gb25CZWZvcmVSZW5kZXIgKHNoYWRlckluZm8pIHtcbiAgICAgIHZhciByZWYgPSB0aGlzLm1hdGVyaWFsO1xuICAgICAgdmFyIHVuaWZvcm1zID0gcmVmLnVuaWZvcm1zO1xuICAgICAgdmFyIHJlZiQxID0gdGhpcztcbiAgICAgIHZhciBwb2ludEEgPSByZWYkMS5wb2ludEE7XG4gICAgICB2YXIgY29udHJvbEEgPSByZWYkMS5jb250cm9sQTtcbiAgICAgIHZhciBjb250cm9sQiA9IHJlZiQxLmNvbnRyb2xCO1xuICAgICAgdmFyIHBvaW50QiA9IHJlZiQxLnBvaW50QjtcbiAgICAgIHZhciByYWRpdXMgPSByZWYkMS5yYWRpdXM7XG4gICAgICB2YXIgZGFzaEFycmF5ID0gcmVmJDEuZGFzaEFycmF5O1xuICAgICAgdmFyIGRhc2hPZmZzZXQgPSByZWYkMS5kYXNoT2Zmc2V0O1xuICAgICAgdW5pZm9ybXMucG9pbnRBLnZhbHVlLmNvcHkocG9pbnRBKTtcbiAgICAgIHVuaWZvcm1zLmNvbnRyb2xBLnZhbHVlLmNvcHkoY29udHJvbEEpO1xuICAgICAgdW5pZm9ybXMuY29udHJvbEIudmFsdWUuY29weShjb250cm9sQik7XG4gICAgICB1bmlmb3Jtcy5wb2ludEIudmFsdWUuY29weShwb2ludEIpO1xuICAgICAgdW5pZm9ybXMucmFkaXVzLnZhbHVlID0gcmFkaXVzO1xuICAgICAgdW5pZm9ybXMuZGFzaGluZy52YWx1ZS5zZXQoZGFzaEFycmF5LngsIGRhc2hBcnJheS55LCBkYXNoT2Zmc2V0IHx8IDApO1xuICAgIH07XG5cbiAgICBCZXppZXJNZXNoLnByb3RvdHlwZS5yYXljYXN0ID0gZnVuY3Rpb24gcmF5Y2FzdCAocmF5Y2FzdGVyLCBpbnRlcnNlY3RzKSB7XG4gICAgICAvLyBUT0RPIC0ganVzdCBmYWlsIGZvciBub3dcbiAgICB9O1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEJlemllck1lc2gucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxuICAgIHJldHVybiBCZXppZXJNZXNoO1xuICB9KHRocmVlLk1lc2gpKTtcblxuICBleHBvcnRzLkJlemllck1lc2ggPSBCZXppZXJNZXNoO1xuICBleHBvcnRzLlNoYWRlckZsb2F0QXJyYXkgPSBTaGFkZXJGbG9hdEFycmF5O1xuICBleHBvcnRzLmNyZWF0ZURlcml2ZWRNYXRlcmlhbCA9IGNyZWF0ZURlcml2ZWRNYXRlcmlhbDtcbiAgZXhwb3J0cy5leHBhbmRTaGFkZXJJbmNsdWRlcyA9IGV4cGFuZFNoYWRlckluY2x1ZGVzO1xuICBleHBvcnRzLmdldFNoYWRlclVuaWZvcm1UeXBlcyA9IGdldFNoYWRlclVuaWZvcm1UeXBlcztcbiAgZXhwb3J0cy5nZXRTaGFkZXJzRm9yTWF0ZXJpYWwgPSBnZXRTaGFkZXJzRm9yTWF0ZXJpYWw7XG4gIGV4cG9ydHMudm9pZE1haW5SZWdFeHAgPSB2b2lkTWFpblJlZ0V4cDtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/troika-three-utils/dist/troika-three-utils.umd.js\n'
      );

      /***/
    },
};
